/*
 * ANGBAND BORG KERNEL V2 - GPU Implementation with Real Game Rules
 *
 * Integration layer for Phase 4: Uses real Angband combat, monsters, and dungeons
 * Based on APWBorg decision logic with authentic game mechanics.
 *
 * Memory Layout: Interleaved (best coalescing)
 */

#include "borg_state.h"
#include "../../common/interleaved.h"

// Real Angband rules (being created by other agents)
// NOTE: Include order matters! monsters.cuh defines monster_attack() and MonsterRace data
// combat.cuh references monster data for get_monster_damage_potential()
#include "angband_monsters.cuh"    // Real monster data and AI (must be first)
#include "angband_combat.cuh"      // Real hit/damage formulas (uses monster data)
#include "angband_dungeon.cuh"     // Real dungeon generation

#include <cuda_runtime.h>
#include <curand_kernel.h>
#include <stdio.h>
#include <chrono>
#include <vector>

// ============================================================================
// DEVICE HELPERS
// ============================================================================

// Calculate danger at position using REAL monster stats
// Config-aware: different personality types perceive danger differently
__device__ int calculate_danger(
    BorgStateInterleaved* s,
    int id, int x, int y,
    int num_instances
) {
    int danger = 0;
    int monster_count = s->monster_count[id];
    int player_level = s->level[id];
    int player_ac = s->ac[id];
    uint16_t config = s->config[id];

    for (int i = 0; i < monster_count && i < MAX_MONSTERS; i++) {
        int mx = IGET(s->monster_x, i, id, num_instances);
        int my = IGET(s->monster_y, i, id, num_instances);
        int mhp = IGET(s->monster_hp, i, id, num_instances);
        int mtype = IGET(s->monster_type, i, id, num_instances);
        int awake = IGET(s->monster_awake, i, id, num_instances);

        // Distance to monster
        int dx = abs(mx - x);
        int dy = abs(my - y);
        int dist = max(dx, dy);

        if (dist == 0) dist = 1;

        // Get REAL monster potential damage from monster race
        int monster_damage_potential = get_monster_damage_potential(mtype, player_ac);

        // Calculate threat based on real damage and distance
        int threat = (monster_damage_potential * (mhp / 10)) / dist;
        if (awake) threat *= 2;

        danger += threat;
    }

    // BASE DANGER from depth - even if no monsters nearby, deep dungeons are dangerous
    // This prevents Level 1 characters from trivially reaching depth 127
    int depth = s->depth[id];
    int base_danger = depth * depth / 10;  // depth 50 = 250, depth 100 = 1000
    danger += base_danger;

    // Level-adjusted danger - being underleveled is VERY dangerous
    int level_deficit = depth - player_level * 2;  // Safe depth = level * 2
    if (level_deficit > 0) {
        danger += level_deficit * level_deficit;  // Quadratic penalty for being underleveled
    }

    // Config-based danger perception modifiers
    // Risky borgs perceive less danger (aggressive)
    if (config_has(config, CFG_PLAYS_RISKY)) {
        danger = (danger * 7) / 10;  // 30% less scary
    }

    // Tank/defensive borgs perceive more danger (conservative)
    if (config_has(config, CFG_WORSHIPS_HP) && config_has(config, CFG_WORSHIPS_AC)) {
        danger = (danger * 13) / 10;  // 30% more scary
    }

    return danger;
}

// Find nearest monster
__device__ int find_nearest_monster(
    BorgStateInterleaved* s,
    int id, int x, int y,
    int num_instances,
    int* out_mx, int* out_my,
    int* out_idx
) {
    int monster_count = s->monster_count[id];
    int min_dist = 9999;
    int best_idx = -1;

    for (int i = 0; i < monster_count && i < MAX_MONSTERS; i++) {
        int mx = IGET(s->monster_x, i, id, num_instances);
        int my = IGET(s->monster_y, i, id, num_instances);
        int mhp = IGET(s->monster_hp, i, id, num_instances);

        // Skip dead monsters
        if (mhp <= 0) continue;

        int dx = abs(mx - x);
        int dy = abs(my - y);
        int dist = max(dx, dy);

        if (dist < min_dist) {
            min_dist = dist;
            best_idx = i;
            *out_mx = mx;
            *out_my = my;
            *out_idx = i;
        }
    }

    return min_dist;
}

// Check if config flag is set
__device__ bool config_has(uint16_t config, uint16_t flag) {
    return (config & flag) != 0;
}

// ============================================================================
// INITIALIZATION KERNELS
// ============================================================================

// Initialize RNG state for each instance
__global__ void init_rng_kernel(
    curandState* states,
    uint32_t seed,
    uint32_t num_instances
) {
    int id = blockIdx.x * blockDim.x + threadIdx.x;
    if (id >= num_instances) return;

    // Each instance gets unique seed
    curand_init(seed, id, 0, &states[id]);
}

// Generate initial dungeons for all instances
__global__ void init_dungeons_kernel(
    BorgStateInterleaved state,
    curandState* rng_states,
    uint32_t num_instances
) {
    int id = blockIdx.x * blockDim.x + threadIdx.x;
    if (id >= num_instances) return;

    curandState* rng = &rng_states[id];
    int depth = state.depth[id];

    // Generate level using REAL Angband dungeon generation
    int px, py;  // Player start position
    int sx, sy;  // Stairs position

    generate_level(
        state.dungeon_terrain,  // Terrain output
        depth,                  // Dungeon depth
        &px, &py,              // Player position output
        &sx, &sy,              // Stairs position output
        id,                    // Instance ID
        num_instances,         // Total instances (for interleaving)
        rng                    // RNG state
    );

    // Set player position
    state.x[id] = px;
    state.y[id] = py;

    // Spawn monsters using REAL monster selection for depth
    int monster_count = spawn_monsters_for_depth(
        depth,
        state.monster_x,
        state.monster_y,
        state.monster_hp,
        state.monster_type,
        state.monster_awake,
        state.dungeon_terrain,
        id,
        num_instances,
        rng
    );

    state.monster_count[id] = monster_count;
}

// ============================================================================
// BORG DECISION KERNEL
// ============================================================================

__global__ void borg_think_kernel(
    BorgStateInterleaved state,
    uint8_t* actions,           // Output: action per instance
    curandState* rng_states,
    uint32_t num_instances
) {
    int id = blockIdx.x * blockDim.x + threadIdx.x;
    if (id >= num_instances) return;

    // Skip dead borgs
    if (!state.alive[id]) {
        actions[id] = BORG_ACTION_NONE;
        return;
    }

    // Load state into registers
    int x = state.x[id];
    int y = state.y[id];
    int hp = state.hp[id];
    int max_hp = state.max_hp[id];
    int depth = state.depth[id];
    int speed = state.speed[id];
    int player_level = state.level[id];
    uint16_t config = state.config[id];
    int no_deeper = state.no_deeper[id];

    bool has_healing = state.has_healing[id];
    bool has_recall = state.has_recall[id];
    bool has_teleport = state.has_teleport[id];

    // Config flags (from APWBorg)
    bool plays_risky = config_has(config, CFG_PLAYS_RISKY);
    bool worships_damage = config_has(config, CFG_WORSHIPS_DAMAGE);
    bool worships_speed = config_has(config, CFG_WORSHIPS_SPEED);
    bool worships_hp = config_has(config, CFG_WORSHIPS_HP);
    bool worships_ac = config_has(config, CFG_WORSHIPS_AC);
    bool worships_gold = config_has(config, CFG_WORSHIPS_GOLD);
    bool kills_uniques = config_has(config, CFG_KILLS_UNIQUES);

    // Calculate danger using REAL monster stats (now config-aware)
    int danger = calculate_danger(&state, id, x, y, num_instances);

    // Find nearest monster
    int mx, my, nearest_idx;
    int monster_dist = find_nearest_monster(&state, id, x, y, num_instances, &mx, &my, &nearest_idx);

    // =========================================================================
    // CONFIG-BASED THRESHOLDS (from APWBorg analysis)
    // =========================================================================

    // HP thresholds (config-dependent)
    float critical_hp_threshold = 0.2f;
    float low_hp_threshold = 0.5f;
    float rest_hp_threshold = 0.8f;
    float descend_hp_threshold = 0.7f;

    // TANK: More conservative HP management (from borg4.c:4533)
    if (worships_hp && worships_ac) {
        critical_hp_threshold = 0.3f;  // Panic earlier
        low_hp_threshold = 0.6f;       // Heal more often
        rest_hp_threshold = 0.9f;      // Rest more frequently
        descend_hp_threshold = 0.85f;  // Require higher HP to descend
    }

    // AGGRO: More aggressive HP management (from borg6.c:2886)
    if (plays_risky && worships_damage) {
        critical_hp_threshold = 0.15f; // Fight longer
        low_hp_threshold = 0.35f;      // Less healing
        rest_hp_threshold = 0.6f;      // Rest less
        descend_hp_threshold = 0.5f;   // Descend with less HP
    }

    // Danger thresholds (config-dependent)
    int danger_flee_threshold = 300;
    int danger_fight_threshold = 200;
    int danger_descend_threshold = 50;

    // RISKY: Higher danger tolerance (from borg6.c:2092)
    if (plays_risky) {
        danger_flee_threshold = 450;      // +50% tolerance
        danger_fight_threshold = 300;
        danger_descend_threshold = 100;   // Will descend in more danger
    }

    // TANK: Lower danger tolerance (conservative)
    if (worships_hp && worships_ac) {
        danger_flee_threshold = 200;      // -33% tolerance
        danger_fight_threshold = 150;
        danger_descend_threshold = 30;    // Require safer descents
    }

    // =========================================================================
    // BORG DECISION TREE (Config-Aware, from APWBorg borg_think)
    // =========================================================================

    uint8_t action = BORG_ACTION_EXPLORE;  // Default
    float hp_pct = (float)hp / (float)max_hp;

    // 1. CRITICAL HP: Emergency survival (all configs)
    if (hp_pct < critical_hp_threshold) {
        if (has_healing) {
            action = BORG_ACTION_HEAL;
        } else if (has_teleport && danger > danger_flee_threshold / 6) {
            action = BORG_ACTION_FLEE;
        } else if (has_recall && !plays_risky) {
            action = BORG_ACTION_ASCEND;  // Conservative: recall to town
        } else if (!plays_risky && has_teleport) {
            action = BORG_ACTION_FLEE;
        } else {
            // Risky borgs fight even at low HP
            if (monster_dist <= 1) {
                action = BORG_ACTION_ATTACK;  // Desperate attack
            } else {
                action = BORG_ACTION_FLEE;
            }
        }
    }
    // 2. LOW HP + HIGH DANGER: Defensive actions
    else if (hp_pct < low_hp_threshold && danger > danger_flee_threshold) {
        if (has_healing) {
            action = BORG_ACTION_HEAL;
        } else if (has_teleport) {
            action = BORG_ACTION_FLEE;
        } else if (has_recall && !plays_risky) {
            action = BORG_ACTION_ASCEND;
        } else if (!plays_risky) {
            action = BORG_ACTION_FLEE;  // Run away even without teleport
        } else {
            action = BORG_ACTION_ATTACK;  // Risky: fight through it
        }
    }
    // 3. MELEE RANGE: Attack if acceptable danger
    else if (monster_dist <= 1) {
        if (danger < danger_flee_threshold || plays_risky) {
            action = BORG_ACTION_ATTACK;
        } else {
            action = BORG_ACTION_FLEE;  // Too dangerous even in melee
        }
    }
    // 4. NEARBY MONSTER: Approach if config allows
    else if (monster_dist <= 5) {
        // AGGRO: Charge in (from borg8.c analysis)
        if ((worships_damage || plays_risky) && danger < danger_fight_threshold) {
            action = BORG_ACTION_ATTACK;  // Approach to fight
        }
        // SPEED: Hit and run - only if we can escape
        else if (worships_speed && speed > 10 && danger < danger_fight_threshold && has_teleport) {
            action = BORG_ACTION_ATTACK;  // Speed borg: quick strike
        }
        // TANK/CONSERVATIVE: Only approach if very safe
        else if ((worships_hp || worships_ac) && danger < danger_descend_threshold) {
            action = BORG_ACTION_ATTACK;  // Careful approach
        }
        // SCUMMER: Prioritize uniques (simplified - would check monster type)
        else if (kills_uniques && danger < danger_fight_threshold) {
            action = BORG_ACTION_ATTACK;  // Hunt uniques
        }
        // DEFAULT: Attack if not too dangerous (encourage XP gain)
        else if (danger < danger_fight_threshold && hp_pct > 0.3f) {
            action = BORG_ACTION_ATTACK;  // Default: fight for XP
        }
        else {
            action = BORG_ACTION_EXPLORE;  // Not safe enough to approach
        }
    }
    // 5. REST: Recover HP when safe
    else if (hp_pct < rest_hp_threshold && danger < danger_descend_threshold) {
        action = BORG_ACTION_REST;
    }
    // 6. DESCEND: Go deeper (config-dependent conditions)
    // Priority order: TANK > AGGRO > SPEED > SCUMMER > ECONOMY > DEFAULT
    else if (depth < no_deeper && hp_pct > descend_hp_threshold && danger < danger_descend_threshold) {
        bool should_descend = false;

        // TANK: Very conservative about descending (highest priority - most restrictive)
        if (worships_hp && worships_ac) {
            should_descend = (hp_pct > 0.9f && danger < danger_descend_threshold / 2);
        }
        // AGGRO: Descend aggressively (from borg8.c:4570)
        else if (plays_risky && worships_damage) {
            should_descend = (hp_pct > 0.5f);  // Low bar
        }
        // SPEED worship: Need adequate speed first
        else if (worships_speed && !worships_hp && !plays_risky) {
            should_descend = (speed >= 10 + depth / 10);  // Need more speed at deeper levels
        }
        // SCUMMER: Clear level more before descending (moderate)
        else if (kills_uniques && !plays_risky) {
            // Would ideally track unique kills; simplified: just be more careful
            // Require higher HP and lower danger than default
            should_descend = (hp_pct > 0.85f && danger < 30);
        }
        // ECONOMY: Ensure we collected enough gold (simplified)
        else if (worships_gold && !plays_risky) {
            should_descend = (state.gold[id] > depth * 100 && hp_pct > 0.75f);
        }
        // DEFAULT: Moderate descending
        else {
            should_descend = (hp_pct > 0.7f && danger < 50);
        }

        if (should_descend) {
            action = BORG_ACTION_DESCEND;
        }
    }
    // 7. EXPLORE: Default wandering
    else {
        action = BORG_ACTION_EXPLORE;
    }

    actions[id] = action;
}

// ============================================================================
// GAME STEP KERNEL (Execute actions with REAL game rules)
// ============================================================================

__global__ void borg_execute_kernel(
    BorgStateInterleaved state,
    uint8_t* actions,
    curandState* rng_states,
    uint32_t num_instances
) {
    int id = blockIdx.x * blockDim.x + threadIdx.x;
    if (id >= num_instances) return;

    if (!state.alive[id]) return;

    curandState* rng = &rng_states[id];
    uint8_t action = actions[id];
    int x = state.x[id];
    int y = state.y[id];
    int hp = state.hp[id];
    int max_hp = state.max_hp[id];
    int depth = state.depth[id];
    int player_level = state.level[id];

    // Get player combat stats
    int equipment_power = state.equipment_power[id];
    int player_skill = state.level[id] * 3;  // Base to-hit skill
    int player_ac = state.ac[id] + equipment_power / 2;  // Equipment improves AC
    int player_deadliness = state.damage[id] + equipment_power;  // Equipment adds damage

    // Execute action
    switch (action) {
        case BORG_ACTION_REST:
            // Recover 1% HP
            hp = min(hp + max(1, max_hp / 100), max_hp);
            break;

        case BORG_ACTION_HEAL:
            // Use healing potion: restore 25% HP
            hp = min(hp + max_hp / 4, max_hp);
            state.has_healing[id] = 0;  // Used up (simplified)
            break;

        case BORG_ACTION_FLEE:
            // Teleport using REAL teleport logic
            teleport_player(
                &x, &y,
                state.dungeon_terrain,
                depth,
                id,
                num_instances,
                rng
            );
            break;

        case BORG_ACTION_ATTACK:
            {
                // Find nearest monster to attack
                int mx, my, target_idx;
                int dist = find_nearest_monster(&state, id, x, y, num_instances, &mx, &my, &target_idx);

                if (target_idx >= 0 && dist <= 1) {
                    // REAL COMBAT: Player attacks monster
                    int monster_type = IGET(state.monster_type, target_idx, id, num_instances);
                    int monster_hp = IGET(state.monster_hp, target_idx, id, num_instances);
                    int monster_ac = get_monster_ac(monster_type);

                    // Weapon stats (scale with equipment power)
                    // Start at 2d6, improve with better equipment
                    int weapon_dd = 2 + (equipment_power / 40);  // Max ~7 dice at depth 100
                    int weapon_ds = 6 + (equipment_power / 50);  // Max ~10 sides at depth 100
                    int weapon_to_hit = 5 + (equipment_power / 10);  // +20 to-hit at depth 100

                    // Calculate player to-hit
                    int to_hit = calc_player_to_hit(player_skill, weapon_to_hit);

                    // REAL MELEE ATTACK
                    int damage = melee_attack(
                        to_hit,
                        player_deadliness,
                        weapon_dd,
                        weapon_ds,
                        player_level,
                        monster_ac,
                        rng
                    );

                    monster_hp -= damage;

                    // Monster dies
                    if (monster_hp <= 0) {
                        // Award XP based on real monster
                        int xp_value = get_monster_xp(monster_type, depth);
                        state.exp[id] += xp_value;

                        // Remove monster (set HP to 0, will be cleaned up)
                        ISET(state.monster_hp, target_idx, id, num_instances, 0);

                        // Check for level up (REAL Angband XP curve)
                        while (state.level[id] < MAX_LEVEL && state.exp[id] >= LEVEL_XP[state.level[id]]) {
                            state.level[id]++;

                            // HP gain on level up (Angband: 10 + d10 for warrior)
                            // Simplified: 10 + random 0-9
                            int hp_gain = 10 + (curand(rng) % 10);
                            state.max_hp[id] += hp_gain;

                            // Fully heal on level up
                            hp = state.max_hp[id];

                            // Increase damage (simulates better to-hit and deadliness)
                            // Gain ~3 damage per level
                            state.damage[id] += 2 + (curand(rng) % 3);

                            // Increase AC slightly (simulates finding better armor)
                            state.ac[id] += 1;
                        }
                    } else {
                        ISET(state.monster_hp, target_idx, id, num_instances, monster_hp);

                        // MONSTER RETALIATES using REAL monster attack
                        int retaliation_damage = monster_attack(
                            monster_type,
                            player_ac,
                            rng
                        );

                        hp -= retaliation_damage;
                    }
                }
            }
            break;

        case BORG_ACTION_DESCEND:
            {
                // Go deeper - generate NEW level with REAL generation
                int new_depth = depth + 1;
                state.depth[id] = new_depth;

                // Generate level using REAL Angband dungeon generation
                int px, py, sx, sy;

                generate_level(
                    state.dungeon_terrain,
                    new_depth,
                    &px, &py,
                    &sx, &sy,
                    id,
                    num_instances,
                    rng
                );

                // Set new player position
                x = px;
                y = py;

                // Spawn monsters using REAL monster selection for depth
                int monster_count = spawn_monsters_for_depth(
                    new_depth,
                    state.monster_x,
                    state.monster_y,
                    state.monster_hp,
                    state.monster_type,
                    state.monster_awake,
                    state.dungeon_terrain,
                    id,
                    num_instances,
                    rng
                );

                state.monster_count[id] = monster_count;

                // EQUIPMENT DISCOVERY: Chance to find better gear when descending
                // In real Angband, this comes from items on the floor
                // Simplified: 10% chance per level to upgrade equipment
                if (curand(rng) % 10 == 0) {
                    // Equipment power scales with depth (approximately depth * 2)
                    int found_power = new_depth * 2;
                    // Only upgrade if better than current equipment
                    if (found_power > state.equipment_power[id]) {
                        state.equipment_power[id] = found_power;
                    }
                }
            }
            break;

        case BORG_ACTION_EXPLORE:
            {
                // Move randomly (simplified pathfinding)
                int dx = curand(rng) % 3 - 1;  // -1, 0, or 1
                int dy = curand(rng) % 3 - 1;

                int new_x = x + dx;
                int new_y = y + dy;

                // Check if walkable using REAL terrain
                if (is_walkable(state.dungeon_terrain, new_x, new_y, id, num_instances)) {
                    x = new_x;
                    y = new_y;

                    // Chance to wake nearby monsters
                    wake_nearby_monsters(
                        state.monster_x,
                        state.monster_y,
                        state.monster_awake,
                        state.monster_count[id],
                        x, y,
                        id,
                        num_instances,
                        rng
                    );
                }
            }
            break;

        default:
            break;
    }

    // MONSTER TURN - awake monsters attack adjacent player
    int monster_count = state.monster_count[id];
    for (int i = 0; i < monster_count && i < MAX_MONSTERS; i++) {
        int mx = IGET(state.monster_x, i, id, num_instances);
        int my = IGET(state.monster_y, i, id, num_instances);
        int mhp = IGET(state.monster_hp, i, id, num_instances);
        int mtype = IGET(state.monster_type, i, id, num_instances);
        int awake = IGET(state.monster_awake, i, id, num_instances);

        // Skip dead or sleeping monsters
        if (mhp <= 0 || !awake) continue;

        // Check if adjacent to player
        int dx = abs(mx - x);
        int dy = abs(my - y);
        int dist = max(dx, dy);

        if (dist == 1) {
            // Monster attacks!
            int damage = monster_attack(mtype, player_ac, rng);
            hp -= damage;

            // Check for death immediately
            if (hp <= 0) break;
        } else if (dist <= 20 && dist > 1) {
            // Move toward player (simple AI) - increased range from 10 to 20
            int move_dx = 0;
            int move_dy = 0;

            if (mx < x) move_dx = 1;
            else if (mx > x) move_dx = -1;

            if (my < y) move_dy = 1;
            else if (my > y) move_dy = -1;

            int new_mx = mx + move_dx;
            int new_my = my + move_dy;

            // Check if walkable
            if (is_walkable(state.dungeon_terrain, new_mx, new_my, id, num_instances)) {
                ISET(state.monster_x, i, id, num_instances, new_mx);
                ISET(state.monster_y, i, id, num_instances, new_my);
            }
        }
    }

    // Check for death
    if (hp <= 0) {
        state.alive[id] = 0;
        state.death_cause[id] = DEATH_MONSTER;
        state.final_depth[id] = state.depth[id];
        state.final_turns[id] = state.turns[id];
    }

    // Update state
    state.x[id] = x;
    state.y[id] = y;
    state.hp[id] = hp;
    state.turns[id]++;

    // Check for win (depth 100 = Morgoth defeated)
    if (state.depth[id] >= 100 && state.monster_count[id] == 0) {
        state.winner[id] = 1;
        state.alive[id] = 0;  // End game
    }
}

// ============================================================================
// HOST DRIVER
// ============================================================================

#define CHECK(call) \
do { \
    const cudaError_t error = call; \
    if (error != cudaSuccess) { \
        printf("CUDA Error: %s:%d, %s\n", __FILE__, __LINE__, cudaGetErrorString(error)); \
        exit(1); \
    } \
} while(0)

void run_borg_simulation(uint32_t num_instances, uint32_t max_turns, bool verify_mode = false, uint32_t verify_seed = 12345) {
    printf("Running Angband Borg GPU simulation (V2 - Real Rules)\n");
    printf("Instances: %d, Max turns: %d\n", num_instances, max_turns);
    if (verify_mode) {
        printf("VERIFICATION MODE: seed=%u\n", verify_seed);
    }

    // Allocate state
    BorgStateInterleaved* state = borg_state_alloc(num_instances);

    // Allocate actions
    uint8_t* d_actions;
    CHECK(cudaMalloc(&d_actions, num_instances));

    // Allocate RNG states
    curandState* d_rng_states;
    CHECK(cudaMalloc(&d_rng_states, num_instances * sizeof(curandState)));

    // Initialize RNG
    int threads = 256;
    int blocks = (num_instances + threads - 1) / threads;

    uint32_t seed = verify_mode ? verify_seed : (uint32_t)time(NULL);
    init_rng_kernel<<<blocks, threads>>>(d_rng_states, seed, num_instances);
    CHECK(cudaDeviceSynchronize());

    // Initialize state (simplified)
    std::vector<int16_t> init_depth(num_instances, 1);
    std::vector<int16_t> init_level(num_instances, 1);
    std::vector<int16_t> init_hp(num_instances, 100);
    std::vector<int16_t> init_speed(num_instances, 10);
    std::vector<int16_t> init_ac(num_instances, 20);
    std::vector<int16_t> init_damage(num_instances, 15);
    std::vector<int16_t> init_equipment_power(num_instances, 0);  // Start with no equipment
    std::vector<uint8_t> init_alive(num_instances, 1);
    std::vector<uint16_t> init_config(num_instances);
    std::vector<uint8_t> init_no_deeper(num_instances, 127);

    // Assign different configs to batches
    for (uint32_t i = 0; i < num_instances; i++) {
        int config_type = i % 8;
        switch (config_type) {
            case 0: init_config[i] = CFG_WORSHIPS_SPEED | CFG_WORSHIPS_DAMAGE | CFG_PLAYS_RISKY; break;  // Aggro
            case 1: init_config[i] = CFG_WORSHIPS_SPEED | CFG_PLAYS_RISKY; break;  // Speed
            case 2: init_config[i] = CFG_WORSHIPS_HP | CFG_WORSHIPS_AC; init_no_deeper[i] = 30; break;  // Tank
            case 3: init_config[i] = CFG_WORSHIPS_SPEED | CFG_WORSHIPS_HP | CFG_KILLS_UNIQUES; break;  // Scummer
            case 4: init_config[i] = CFG_WORSHIPS_SPEED | CFG_WORSHIPS_HP | CFG_PLAYS_RISKY; break;  // Meta
            case 5: init_config[i] = CFG_WORSHIPS_HP | CFG_WORSHIPS_AC | CFG_WORSHIPS_GOLD; break;  // Economy
            case 6: init_config[i] = CFG_WORSHIPS_SPEED | CFG_WORSHIPS_DAMAGE | CFG_PLAYS_RISKY | CFG_CHEAT_DEATH; break;  // Cheat
            default: init_config[i] = 0; break;  // Default
        }
    }

    CHECK(cudaMemcpy(state->depth, init_depth.data(), num_instances * sizeof(int16_t), cudaMemcpyHostToDevice));
    CHECK(cudaMemcpy(state->level, init_level.data(), num_instances * sizeof(int16_t), cudaMemcpyHostToDevice));
    CHECK(cudaMemcpy(state->hp, init_hp.data(), num_instances * sizeof(int16_t), cudaMemcpyHostToDevice));
    CHECK(cudaMemcpy(state->max_hp, init_hp.data(), num_instances * sizeof(int16_t), cudaMemcpyHostToDevice));
    CHECK(cudaMemcpy(state->speed, init_speed.data(), num_instances * sizeof(int16_t), cudaMemcpyHostToDevice));
    CHECK(cudaMemcpy(state->ac, init_ac.data(), num_instances * sizeof(int16_t), cudaMemcpyHostToDevice));
    CHECK(cudaMemcpy(state->damage, init_damage.data(), num_instances * sizeof(int16_t), cudaMemcpyHostToDevice));
    CHECK(cudaMemcpy(state->equipment_power, init_equipment_power.data(), num_instances * sizeof(int16_t), cudaMemcpyHostToDevice));
    CHECK(cudaMemcpy(state->alive, init_alive.data(), num_instances, cudaMemcpyHostToDevice));
    CHECK(cudaMemcpy(state->config, init_config.data(), num_instances * sizeof(uint16_t), cudaMemcpyHostToDevice));
    CHECK(cudaMemcpy(state->no_deeper, init_no_deeper.data(), num_instances, cudaMemcpyHostToDevice));

    // Initialize other fields
    CHECK(cudaMemset(state->has_healing, 1, num_instances));  // Start with healing
    CHECK(cudaMemset(state->has_recall, 1, num_instances));   // Start with recall
    CHECK(cudaMemset(state->has_teleport, 1, num_instances)); // Start with teleport
    CHECK(cudaMemset(state->turns, 0, num_instances * sizeof(uint32_t)));
    CHECK(cudaMemset(state->exp, 0, num_instances * sizeof(uint32_t)));
    CHECK(cudaMemset(state->winner, 0, num_instances));
    CHECK(cudaMemset(state->final_depth, 0, num_instances * sizeof(uint16_t)));
    CHECK(cudaMemset(state->final_turns, 0, num_instances * sizeof(uint32_t)));
    CHECK(cudaMemset(state->monster_count, 0, num_instances));

    // Generate initial dungeons
    printf("Generating initial dungeons...\n");
    init_dungeons_kernel<<<blocks, threads>>>(*state, d_rng_states, num_instances);
    CHECK(cudaDeviceSynchronize());

    // Run simulation
    printf("Starting simulation...\n");
    auto start = std::chrono::high_resolution_clock::now();

    for (uint32_t turn = 0; turn < max_turns; turn++) {
        // Think
        borg_think_kernel<<<blocks, threads>>>(*state, d_actions, d_rng_states, num_instances);

        // Execute
        borg_execute_kernel<<<blocks, threads>>>(*state, d_actions, d_rng_states, num_instances);

        // Progress indicator every 100 turns
        if ((turn + 1) % 100 == 0) {
            CHECK(cudaDeviceSynchronize());
            printf("Turn %d/%d completed\r", turn + 1, max_turns);
            fflush(stdout);
        }
    }

    CHECK(cudaDeviceSynchronize());
    printf("\n");

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> diff = end - start;

    printf("Simulation time: %.4f s\n", diff.count());
    printf("Throughput: %.2f instance-turns/sec\n", (double)num_instances * max_turns / diff.count());

    // Collect results
    std::vector<uint8_t> h_alive(num_instances);
    std::vector<int16_t> h_depth(num_instances);  // Current depth (for alive borgs)
    std::vector<uint16_t> h_final_depth(num_instances);  // Final depth (for dead borgs)
    std::vector<uint8_t> h_winner(num_instances);
    std::vector<int16_t> h_hp(num_instances);
    std::vector<int16_t> h_level(num_instances);
    std::vector<int16_t> h_equipment_power(num_instances);
    std::vector<uint32_t> h_exp(num_instances);

    CHECK(cudaMemcpy(h_alive.data(), state->alive, num_instances, cudaMemcpyDeviceToHost));
    CHECK(cudaMemcpy(h_depth.data(), state->depth, num_instances * sizeof(int16_t), cudaMemcpyDeviceToHost));
    CHECK(cudaMemcpy(h_final_depth.data(), state->final_depth, num_instances * sizeof(uint16_t), cudaMemcpyDeviceToHost));
    CHECK(cudaMemcpy(h_winner.data(), state->winner, num_instances, cudaMemcpyDeviceToHost));
    CHECK(cudaMemcpy(h_hp.data(), state->hp, num_instances * sizeof(int16_t), cudaMemcpyDeviceToHost));
    CHECK(cudaMemcpy(h_level.data(), state->level, num_instances * sizeof(int16_t), cudaMemcpyDeviceToHost));
    CHECK(cudaMemcpy(h_equipment_power.data(), state->equipment_power, num_instances * sizeof(int16_t), cudaMemcpyDeviceToHost));
    CHECK(cudaMemcpy(h_exp.data(), state->exp, num_instances * sizeof(uint32_t), cudaMemcpyDeviceToHost));

    // Count results by config type
    int alive_count[8] = {0};
    int winner_count[8] = {0};
    int dead_count[8] = {0};
    int total_depth[8] = {0};
    int max_depth[8] = {0};
    int total_level[8] = {0};
    int total_equipment[8] = {0};
    int count[8] = {0};

    for (uint32_t i = 0; i < num_instances; i++) {
        int config_type = i % 8;
        count[config_type]++;
        total_level[config_type] += h_level[i];
        total_equipment[config_type] += h_equipment_power[i];

        if (h_alive[i]) {
            alive_count[config_type]++;
            total_depth[config_type] += h_depth[i];  // Use current depth for alive
            if (h_depth[i] > max_depth[config_type]) max_depth[config_type] = h_depth[i];
        } else {
            dead_count[config_type]++;
            total_depth[config_type] += h_final_depth[i];  // Use final depth for dead
            if (h_final_depth[i] > max_depth[config_type]) max_depth[config_type] = h_final_depth[i];
        }
        if (h_winner[i]) winner_count[config_type]++;
    }

    const char* config_names[] = {"Aggro", "Speed", "Tank", "Scummer", "Meta", "Economy", "Cheat", "Default"};

    printf("\n=== RESULTS BY CONFIG ===\n");
    printf("%-10s %8s %8s %8s %8s %8s %8s %8s %8s\n",
           "Config", "Alive%", "Dead%", "Win%", "AvgDepth", "MaxDepth", "AvgLevel", "AvgEquip", "Count");
    for (int i = 0; i < 8; i++) {
        if (count[i] > 0) {
            printf("%-10s %7.1f%% %7.1f%% %7.1f%% %8.1f %8d %8.1f %8.1f %8d\n",
                config_names[i],
                100.0 * alive_count[i] / count[i],
                100.0 * dead_count[i] / count[i],
                100.0 * winner_count[i] / count[i],
                (double)total_depth[i] / count[i],
                max_depth[i],
                (double)total_level[i] / count[i],
                (double)total_equipment[i] / count[i],
                count[i]);
        }
    }

    // Summary stats
    int total_alive = 0, total_dead = 0, total_winners = 0;
    for (int i = 0; i < 8; i++) {
        total_alive += alive_count[i];
        total_dead += dead_count[i];
        total_winners += winner_count[i];
    }

    printf("\nSUMMARY: %d alive (%.1f%%), %d dead (%.1f%%), %d winners (%.3f%%)\n",
           total_alive, 100.0 * total_alive / num_instances,
           total_dead, 100.0 * total_dead / num_instances,
           total_winners, 100.0 * total_winners / num_instances);

    // Verification mode: print first 10 instances for reproducibility check
    if (verify_mode && num_instances >= 10) {
        printf("\n=== VERIFICATION DATA (first 10 instances) ===\n");
        printf("ID  Alive  Depth  Level  HP   Equip    Exp\n");
        for (int i = 0; i < 10; i++) {
            printf("%2d  %5s  %5d  %5d  %3d  %5d  %7u\n",
                   i,
                   h_alive[i] ? "YES" : "NO",
                   h_alive[i] ? h_depth[i] : h_final_depth[i],
                   h_level[i],
                   h_hp[i],
                   h_equipment_power[i],
                   h_exp[i]);
        }
    }

    // Cleanup
    cudaFree(d_actions);
    cudaFree(d_rng_states);
    borg_state_free(state);
}

int main(int argc, char** argv) {
    uint32_t num_instances = 10000;
    uint32_t max_turns = 1000;
    bool verify_mode = false;
    uint32_t verify_seed = 12345;

    // Parse arguments
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--verify") == 0) {
            verify_mode = true;
            num_instances = 100;  // Smaller for verification
            if (i + 1 < argc) {
                verify_seed = atoi(argv[i + 1]);
                i++;
            }
        } else if (i == 1) {
            num_instances = atoi(argv[i]);
        } else if (i == 2) {
            max_turns = atoi(argv[i]);
        }
    }

    run_borg_simulation(num_instances, max_turns, verify_mode, verify_seed);

    return 0;
}
