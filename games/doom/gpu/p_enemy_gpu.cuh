// GPU-transformed from p_enemy.c
// Generated by doom_cuda_transformer.py
// Original: id Software DOOM (1993)

#include "doom_types.cuh"

// Emacs style mode select   -*- C++ -*-
//-----------------------------------------------------------------------------
//
// $Id:$
//
// Copyright (C) 1993-1996 by id Software, Inc.
//
// This source is available for distribution and/or modification
// only under the terms of the DOOM Source Code License as
// published by id Software. All rights reserved.
//
// The source is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License
// for more details.
//
// $Log:$
//
// DESCRIPTION:
//	Enemy thinking, AI.
//	Action Pointer Functions
//	that are associated with states/frames.
//
//-----------------------------------------------------------------------------

static const char
rcsid[] = "$Id: p_enemy.c,v 1.5 1997/02/03 22:45:11 b1 Exp $";

#include <stdlib.h>

#include "m_random.h"
#include "i_system.h"

#include "doomdef.h"
#include "p_local.h"

#include "s_sound.h"

#include "g_game.h"

// State.
#include "doomstat.h"
#include "r_state.h"

// Data.
#include "sounds.h"




typedef enum
{
    DI_EAST,
    DI_NORTHEAST,
    DI_NORTH,
    DI_NORTHWEST,
    DI_WEST,
    DI_SOUTHWEST,
    DI_SOUTH,
    DI_SOUTHEAST,
    DI_NODIR,
    NUMDIRS

} dirtype_t;


//
// P_NewChaseDir related LUT.
//
dirtype_t opposite[] =
{
  DI_WEST, DI_SOUTHWEST, DI_SOUTH, DI_SOUTHEAST,
  DI_EAST, DI_NORTHEAST, DI_NORTH, DI_NORTHWEST, DI_NODIR
};

dirtype_t diags[] =
{
    DI_NORTHWEST, DI_NORTHEAST, DI_SOUTHWEST, DI_SOUTHEAST
};





__device__ void A_Fall_GPU(int actor_idx, int instance_id, int num_instances)


//
// ENEMY THINKING
// Enemies are allways spawned
// with targetplayer = -1, threshold = 0
// Most monsters are spawned unaware of all players,
// but some can be made preaware
//


//
// Called by P_NoiseAlert.
// Recursively traverse adjacent sectors,
// sound blocking lines cut off traversal.
//

mobj_t*		soundtarget;

void
P_RecursiveSound
( sector_t*	sec,
  int		soundblocks )
{
    int		i;
    line_t*	check;
    sector_t*	other;

    // wake up all monsters in this sector
    if (sec->validcount == validcount
	&& sec->soundtraversed <= soundblocks+1)
    {
	return;		// already flooded
    }

    sec->validcount = validcount;
    sec->soundtraversed = soundblocks+1;
    sec->soundtarget = soundtarget;

    for (i=0 ;i<sec->linecount ; i++)
    {
	check = sec->lines[i];
	if (! (check->flags & ML_TWOSIDED) )
	    continue;

	P_LineOpening (check);

	if (openrange <= 0)
	    continue;	// closed door

	if ( sides[ check->sidenum[0] ].sector == sec)
	    other = sides[ check->sidenum[1] ] .sector;
	else
	    other = sides[ check->sidenum[0] ].sector;

	if (check->flags & ML_SOUNDBLOCK)
	{
	    if (!soundblocks)
		P_RecursiveSound (other, 1);
	}
	else
	    P_RecursiveSound (other, soundblocks);
    }
}



//
// P_NoiseAlert
// If a monster yells at a player,
// it will alert other monsters to the player.
//
__device__ void P_NoiseAlert_GPU(int target_idx, int emmiter_idx, int instance_id, int num_instances)
{
    soundtarget = target_idx;
    validcount++;
    P_RecursiveSound (d_subsector_sector[d_mobj_subsector[emmiter_idx * num_instances + instance_id]], 0);
}




//
// P_CheckMeleeRange
//
__device__ boolean P_CheckMeleeRange_GPU(int actor_idx, int instance_id, int num_instances)
{
    mobj_t*	pl;
    fixed_t	dist;

    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return false;

    pl = d_mobj_target[actor_idx * num_instances + instance_id];
    dist = P_AproxDistance (pl->x-d_mobj_x[actor_idx * num_instances + instance_id], pl->y-d_mobj_y[actor_idx * num_instances + instance_id]);

    if (dist >= MELEERANGE-20*FRACUNIT+pl->info->radius)
	return false;

    if (! P_CheckSight (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id]) )
	return false;

    return true;
}

//
// P_CheckMissileRange
//
__device__ boolean P_CheckMissileRange_GPU(int actor_idx, int instance_id, int num_instances)
{
    fixed_t	dist;

    if (! P_CheckSight (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id]) )
	return false;

    if ( d_mobj_flags[actor_idx * num_instances + instance_id] & MF_JUSTHIT )
    {
	// the target just hit the enemy,
	// so fight back!
	d_mobj_flags[actor_idx * num_instances + instance_id] &= ~MF_JUSTHIT;
	return true;
    }

    if (d_mobj_reactiontime[actor_idx * num_instances + instance_id])
	return false;	// do not attack yet

    // OPTIMIZE: get this from a global checksight
    dist = P_AproxDistance ( d_mobj_x[actor_idx * num_instances + instance_id]-d_mobj_x[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id],
			     d_mobj_y[actor_idx * num_instances + instance_id]-d_mobj_y[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id]) - 64*FRACUNIT;

    if (!c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].meleestate)
	dist -= 128*FRACUNIT;	// no melee attack, so fire more

    dist >>= 16;

    if (d_mobj_type[actor_idx * num_instances + instance_id] == MT_VILE)
    {
	if (dist > 14*64)
	    return false;	// too far away
    }


    if (d_mobj_type[actor_idx * num_instances + instance_id] == MT_UNDEAD)
    {
	if (dist < 196)
	    return false;	// close for fist attack
	dist >>= 1;
    }


    if (d_mobj_type[actor_idx * num_instances + instance_id] == MT_CYBORG
	|| d_mobj_type[actor_idx * num_instances + instance_id] == MT_SPIDER
	|| d_mobj_type[actor_idx * num_instances + instance_id] == MT_SKULL)
    {
	dist >>= 1;
    }

    if (dist > 200)
	dist = 200;

    if (d_mobj_type[actor_idx * num_instances + instance_id] == MT_CYBORG && dist > 160)
	dist = 160;

    if (gpu_random () < dist)
	return false;

    return true;
}


//
// P_Move
// Move in the current direction,
// returns false if the move is blocked.
//
fixed_t	xspeed[8] = {FRACUNIT,47000,0,-47000,-FRACUNIT,-47000,0,47000};
fixed_t yspeed[8] = {0,47000,FRACUNIT,47000,0,-47000,-FRACUNIT,-47000};

#define MAXSPECIALCROSS	8

extern	line_t*	spechit[MAXSPECIALCROSS];
extern	int	numspechit;

__device__ boolean P_Move_GPU(int actor_idx, int instance_id, int num_instances)
{
    fixed_t	tryx;
    fixed_t	tryy;

    line_t*	ld;

    // warning: 'catch', 'throw', and 'try'
    // are all C++ reserved words
    boolean	try_ok;
    boolean	good;

    if (d_mobj_movedir[actor_idx * num_instances + instance_id] == DI_NODIR)
	return false;

    if ((unsigned)d_mobj_movedir[actor_idx * num_instances + instance_id] >= 8)
    // SKIP-GPU: I_Error ("Weird d_mobj_movedir[actor_idx * num_instances + instance_id]!");

    tryx = d_mobj_x[actor_idx * num_instances + instance_id] + c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].speed*xspeed[d_mobj_movedir[actor_idx * num_instances + instance_id]];
    tryy = d_mobj_y[actor_idx * num_instances + instance_id] + c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].speed*yspeed[d_mobj_movedir[actor_idx * num_instances + instance_id]];

    try_ok = P_TryMove (actor_idx,  tryx, tryy);

    if (!try_ok)
    {
	// open any specials
	if (d_mobj_flags[actor_idx * num_instances + instance_id] & MF_FLOAT && floatok)
	{
	    // must adjust height
	    if (d_mobj_z[actor_idx * num_instances + instance_id] < tmfloorz)
		d_mobj_z[actor_idx * num_instances + instance_id] += FLOATSPEED;
	    else
		d_mobj_z[actor_idx * num_instances + instance_id] -= FLOATSPEED;

	    d_mobj_flags[actor_idx * num_instances + instance_id] |= MF_INFLOAT;
	    return true;
	}

	if (!numspechit)
	    return false;

	d_mobj_movedir[actor_idx * num_instances + instance_id] = DI_NODIR;
	good = false;
	while (numspechit--)
	{
	    ld = spechit[numspechit];
	    // if the special is not a door
	    // that can be opened,
	    // return false
	    if (P_UseSpecialLine (actor_idx,  ld,0))
		good = true;
	}
	return good;
    }
    else
    {
	d_mobj_flags[actor_idx * num_instances + instance_id] &= ~MF_INFLOAT;
    }


    if (! (d_mobj_flags[actor_idx * num_instances + instance_id] & MF_FLOAT) )
	d_mobj_z[actor_idx * num_instances + instance_id] = d_mobj_floorz[actor_idx * num_instances + instance_id];
    return true;
}


//
// TryWalk
// Attempts to move actor on
// in its current (ob->moveangle) direction.
// If blocked by either a wall or an actor
// returns FALSE
// If move is either clear or blocked only by a door,
// returns TRUE and sets...
// If a door is in the way,
// an OpenDoor call is made to start it opening.
//
__device__ boolean P_TryWalk_GPU(int actor_idx, int instance_id, int num_instances)
{
    if (!P_Move_GPU (actor_idx, instance_id, num_instances))
    {
	return false;
    }

    d_mobj_movecount[actor_idx * num_instances + instance_id] = gpu_random()&15;
    return true;
}




__device__ void P_NewChaseDir_GPU(int actor_idx, int instance_id, int num_instances)
{
    fixed_t	deltax;
    fixed_t	deltay;

    dirtype_t	d[3];

    int		tdir;
    dirtype_t	olddir;

    dirtype_t	turnaround;

    if (!d_mobj_target[actor_idx * num_instances + instance_id])
    // SKIP-GPU: I_Error ("P_NewChaseDir: called with no target");

    olddir = d_mobj_movedir[actor_idx * num_instances + instance_id];
    turnaround=opposite[olddir];

    deltax = d_mobj_x[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id] - d_mobj_x[actor_idx * num_instances + instance_id];
    deltay = d_mobj_y[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id] - d_mobj_y[actor_idx * num_instances + instance_id];

    if (deltax>10*FRACUNIT)
	d[1]= DI_EAST;
    else if (deltax<-10*FRACUNIT)
	d[1]= DI_WEST;
    else
	d[1]=DI_NODIR;

    if (deltay<-10*FRACUNIT)
	d[2]= DI_SOUTH;
    else if (deltay>10*FRACUNIT)
	d[2]= DI_NORTH;
    else
	d[2]=DI_NODIR;

    // try direct route
    if (d[1] != DI_NODIR
	&& d[2] != DI_NODIR)
    {
	d_mobj_movedir[actor_idx * num_instances + instance_id] = diags[((deltay<0)<<1)+(deltax>0)];
	if (d_mobj_movedir[actor_idx * num_instances + instance_id] != turnaround && P_TryWalk_GPU(actor_idx, instance_id, num_instances))
	    return;
    }

    // try other directions
    if (gpu_random() > 200
	||  abs(deltay)>abs(deltax))
    {
	tdir=d[1];
	d[1]=d[2];
	d[2]=tdir;
    }

    if (d[1]==turnaround)
	d[1]=DI_NODIR;
    if (d[2]==turnaround)
	d[2]=DI_NODIR;

    if (d[1]!=DI_NODIR)
    {
	d_mobj_movedir[actor_idx * num_instances + instance_id] = d[1];
	if (P_TryWalk_GPU(actor_idx, instance_id, num_instances))
	{
	    // either moved forward or attacked
	    return;
	}
    }

    if (d[2]!=DI_NODIR)
    {
	d_mobj_movedir[actor_idx * num_instances + instance_id] =d[2];

	if (P_TryWalk_GPU(actor_idx, instance_id, num_instances))
	    return;
    }

    // there is no direct path to the player,
    // so pick another direction.
    if (olddir!=DI_NODIR)
    {
	d_mobj_movedir[actor_idx * num_instances + instance_id] =olddir;

	if (P_TryWalk_GPU(actor_idx, instance_id, num_instances))
	    return;
    }

    // randomly determine direction of search
    if (gpu_random()&1)
    {
	for ( tdir=DI_EAST;
	      tdir<=DI_SOUTHEAST;
	      tdir++ )
	{
	    if (tdir!=turnaround)
	    {
		d_mobj_movedir[actor_idx * num_instances + instance_id] =tdir;

		if ( P_TryWalk_GPU(actor_idx, instance_id, num_instances) )
		    return;
	    }
	}
    }
    else
    {
	for ( tdir=DI_SOUTHEAST;
	      tdir != (DI_EAST-1);
	      tdir-- )
	{
	    if (tdir!=turnaround)
	    {
		d_mobj_movedir[actor_idx * num_instances + instance_id] =tdir;

		if ( P_TryWalk_GPU(actor_idx, instance_id, num_instances) )
		    return;
	    }
	}
    }

    if (turnaround !=  DI_NODIR)
    {
	d_mobj_movedir[actor_idx * num_instances + instance_id] =turnaround;
	if ( P_TryWalk_GPU(actor_idx, instance_id, num_instances) )
	    return;
    }

    d_mobj_movedir[actor_idx * num_instances + instance_id] = DI_NODIR;	// can not move
}



//
// P_LookForPlayers
// If allaround is false, only look 180 degrees in front.
// Returns true if a player is targeted.
//
__device__ boolean P_LookForPlayers_GPU(int actor_idx, boolean allaround, int instance_id, int num_instances)
{
    int		c;
    int		stop;
    player_t*	player;
    sector_t*	sector;
    angle_t	an;
    fixed_t	dist;

    sector = d_subsector_sector[d_mobj_subsector[actor_idx * num_instances + instance_id]];

    c = 0;
    stop = (d_mobj_lastlook[actor_idx * num_instances + instance_id]-1)&3;

    for ( ; ; d_mobj_lastlook[actor_idx * num_instances + instance_id] = (d_mobj_lastlook[actor_idx * num_instances + instance_id]+1)&3 )
    {
	if (!playeringame[d_mobj_lastlook[actor_idx * num_instances + instance_id]])
	    continue;

	if (c++ == 2
	    || d_mobj_lastlook[actor_idx * num_instances + instance_id] == stop)
	{
	    // done looking
	    return false;
	}

	player = &players[d_mobj_lastlook[actor_idx * num_instances + instance_id]];

	if (player->health <= 0)
	    continue;		// dead

	if (!P_CheckSight (actor_idx,  player->mo))
	    continue;		// out of sight

	if (!allaround)
	{
	    an = R_PointToAngle2 (d_mobj_x[actor_idx * num_instances + instance_id],
				  d_mobj_y[actor_idx * num_instances + instance_id],
				  player->mo->x,
				  player->mo->y)
		- d_mobj_angle[actor_idx * num_instances + instance_id];

	    if (an > ANG90 && an < ANG270)
	    {
		dist = P_AproxDistance (player->mo->x - d_mobj_x[actor_idx * num_instances + instance_id],
					player->mo->y - d_mobj_y[actor_idx * num_instances + instance_id]);
		// if real close, react anyway
		if (dist > MELEERANGE)
		    continue;	// behind back
	    }
	}

	d_mobj_target[actor_idx * num_instances + instance_id] = player->mo;
	return true;
    }

    return false;
}


//
// A_KeenDie
// DOOM II special, map 32.
// Uses special tag 666.
//
__device__ void A_KeenDie_GPU(int mo_idx, int instance_id, int num_instances)
{
    thinker_t*	th;
    mobj_t*	mo2;
    line_t	junk;

    A_Fall (mo_idx, instance_id, num_instances);

    // scan the remaining thinkers
    // to see if all Keens are dead
    for (th = thinkercap.next ; th != &thinkercap ; th=th->next)
    {
	if (th->function.acp1 != (actionf_p1)P_MobjThinker)
	    continue;

	mo2 = (mobj_t *)th;
	if (mo2 != mo
	    && mo2->type == d_mobj_type[mo_idx * num_instances + instance_id]
	    && mo2->health > 0)
	{
	    // other Keen not dead
	    return;
	}
    }

    junk.tag = 666;
    EV_DoDoor(&junk,open);
}


//
// ACTION ROUTINES
//

//
// A_Look
// Stay in state until a player is sighted.
//
__device__ void A_Look_GPU(int actor_idx, int instance_id, int num_instances)
{
    mobj_t*	targ;

    d_mobj_threshold[actor_idx * num_instances + instance_id] = 0;	// any shot will wake up
    targ = d_sector_soundtarget[d_subsector_sector[d_mobj_subsector[actor_idx * num_instances + instance_id]]];

    if (targ
	&& (targ->flags & MF_SHOOTABLE) )
    {
	d_mobj_target[actor_idx * num_instances + instance_id] = targ;

	if ( d_mobj_flags[actor_idx * num_instances + instance_id] & MF_AMBUSH )
	{
	    if (P_CheckSight (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id]))
		goto seeyou;
	}
	else
	    goto seeyou;
    }


    if (!P_LookForPlayers_GPU (actor_idx,  false) )
	return;

    // go into chase state
  seeyou:
    if (c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].seesound)
    {
	int		sound;

	switch (c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].seesound)
	{
	  case sfx_posit1:
	  case sfx_posit2:
	  case sfx_posit3:
	    sound = sfx_posit1+gpu_random()%3;
	    break;

	  case sfx_bgsit1:
	  case sfx_bgsit2:
	    sound = sfx_bgsit1+gpu_random()%2;
	    break;

	  default:
	    sound = c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].seesound;
	    break;
	}

	if (d_mobj_type[actor_idx * num_instances + instance_id]==MT_SPIDER
	    || d_mobj_type[actor_idx * num_instances + instance_id] == MT_CYBORG)
	{
	    // full volume
    // SKIP-GPU: S_StartSound (NULL, sound);
	}
	else
    // SKIP-GPU: S_StartSound (actor, sound);
    }

    P_SetMobjState_GPU (actor_idx,  c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].seestate);
}


//
// A_Chase
// Actor has a melee attack,
// so it tries to close as fast as possible
//
__device__ void A_Chase_GPU(int actor_idx, int instance_id, int num_instances)
{
    int		delta;

    if (d_mobj_reactiontime[actor_idx * num_instances + instance_id])
	d_mobj_reactiontime[actor_idx * num_instances + instance_id]--;


    // modify target threshold
    if  (d_mobj_threshold[actor_idx * num_instances + instance_id])
    {
	if (!d_mobj_target[actor_idx * num_instances + instance_id]
	    || d_mobj_health[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id] <= 0)
	{
	    d_mobj_threshold[actor_idx * num_instances + instance_id] = 0;
	}
	else
	    d_mobj_threshold[actor_idx * num_instances + instance_id]--;
    }

    // turn towards movement direction if not there yet
    if (d_mobj_movedir[actor_idx * num_instances + instance_id] < 8)
    {
	d_mobj_angle[actor_idx * num_instances + instance_id] &= (7<<29);
	delta = d_mobj_angle[actor_idx * num_instances + instance_id] - (d_mobj_movedir[actor_idx * num_instances + instance_id] << 29);

	if (delta > 0)
	    d_mobj_angle[actor_idx * num_instances + instance_id] -= ANG90/2;
	else if (delta < 0)
	    d_mobj_angle[actor_idx * num_instances + instance_id] += ANG90/2;
    }

    if (!d_mobj_target[actor_idx * num_instances + instance_id]
	|| !(d_mobj_flags[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id]&MF_SHOOTABLE))
    {
	// look for a new target
	if (P_LookForPlayers_GPU(actor_idx, true))
	    return; 	// got a new target

	P_SetMobjState_GPU (actor_idx,  c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].spawnstate);
	return;
    }

    // do not attack twice in a row
    if (d_mobj_flags[actor_idx * num_instances + instance_id] & MF_JUSTATTACKED)
    {
	d_mobj_flags[actor_idx * num_instances + instance_id] &= ~MF_JUSTATTACKED;
	if (gameskill != sk_nightmare && !fastparm)
	    P_NewChaseDir_GPU (actor_idx, instance_id, num_instances);
	return;
    }

    // check for melee attack
    if (c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].meleestate
	&& P_CheckMeleeRange_GPU (actor_idx, instance_id, num_instances))
    {
	if (c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].attacksound)
    // SKIP-GPU: S_StartSound (actor, c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].attacksound);

	P_SetMobjState_GPU (actor_idx,  c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].meleestate);
	return;
    }

    // check for missile attack
    if (c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].missilestate)
    {
	if (gameskill < sk_nightmare
	    && !fastparm && d_mobj_movecount[actor_idx * num_instances + instance_id])
	{
	    goto nomissile;
	}

	if (!P_CheckMissileRange_GPU (actor_idx, instance_id, num_instances))
	    goto nomissile;

	P_SetMobjState_GPU (actor_idx,  c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].missilestate);
	d_mobj_flags[actor_idx * num_instances + instance_id] |= MF_JUSTATTACKED;
	return;
    }

    // ?
  nomissile:
    // possibly choose another target
    if (netgame
	&& !d_mobj_threshold[actor_idx * num_instances + instance_id]
	&& !P_CheckSight (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id]) )
    {
	if (P_LookForPlayers_GPU(actor_idx, true))
	    return;	// got a new target
    }

    // chase towards player
    if (--d_mobj_movecount[actor_idx * num_instances + instance_id]<0
	|| !P_Move_GPU (actor_idx, instance_id, num_instances))
    {
	P_NewChaseDir_GPU (actor_idx, instance_id, num_instances);
    }

    // make active sound
    if (c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].activesound
	&& gpu_random () < 3)
    {
    // SKIP-GPU: S_StartSound (actor, c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].activesound);
    }
}


//
// A_FaceTarget
//
__device__ void A_FaceTarget_GPU(int actor_idx, int instance_id, int num_instances)
{
    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;

    d_mobj_flags[actor_idx * num_instances + instance_id] &= ~MF_AMBUSH;

    d_mobj_angle[actor_idx * num_instances + instance_id] = R_PointToAngle2 (d_mobj_x[actor_idx * num_instances + instance_id],
				    d_mobj_y[actor_idx * num_instances + instance_id],
				    d_mobj_x[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id],
				    d_mobj_y[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id]);

    if (d_mobj_flags[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id] & MF_SHADOW)
	d_mobj_angle[actor_idx * num_instances + instance_id] += (gpu_random()-gpu_random())<<21;
}


//
// A_PosAttack
//
__device__ void A_PosAttack_GPU(int actor_idx, int instance_id, int num_instances)
{
    int		angle;
    int		damage;
    int		slope;

    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;

    A_FaceTarget (actor_idx, instance_id, num_instances);
    angle = d_mobj_angle[actor_idx * num_instances + instance_id];
    slope = P_AimLineAttack (actor_idx,  angle, MISSILERANGE);

    // SKIP-GPU: S_StartSound (actor, sfx_pistol);
    angle += (gpu_random()-gpu_random())<<20;
    damage = ((gpu_random()%5)+1)*3;
    P_LineAttack (actor_idx,  angle, MISSILERANGE, slope, damage);
}

__device__ void A_SPosAttack_GPU(int actor_idx, int instance_id, int num_instances)
{
    int		i;
    int		angle;
    int		bangle;
    int		damage;
    int		slope;

    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;

    // SKIP-GPU: S_StartSound (actor, sfx_shotgn);
    A_FaceTarget (actor_idx, instance_id, num_instances);
    bangle = d_mobj_angle[actor_idx * num_instances + instance_id];
    slope = P_AimLineAttack (actor_idx,  bangle, MISSILERANGE);

    for (i=0 ; i<3 ; i++)
    {
	angle = bangle + ((gpu_random()-gpu_random())<<20);
	damage = ((gpu_random()%5)+1)*3;
	P_LineAttack (actor_idx,  angle, MISSILERANGE, slope, damage);
    }
}

__device__ void A_CPosAttack_GPU(int actor_idx, int instance_id, int num_instances)
{
    int		angle;
    int		bangle;
    int		damage;
    int		slope;

    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;

    // SKIP-GPU: S_StartSound (actor, sfx_shotgn);
    A_FaceTarget (actor_idx, instance_id, num_instances);
    bangle = d_mobj_angle[actor_idx * num_instances + instance_id];
    slope = P_AimLineAttack (actor_idx,  bangle, MISSILERANGE);

    angle = bangle + ((gpu_random()-gpu_random())<<20);
    damage = ((gpu_random()%5)+1)*3;
    P_LineAttack (actor_idx,  angle, MISSILERANGE, slope, damage);
}

__device__ void A_CPosRefire_GPU(int actor_idx, int instance_id, int num_instances)
{
    // keep firing unless target got out of sight
    A_FaceTarget (actor_idx, instance_id, num_instances);

    if (gpu_random () < 40)
	return;

    if (!d_mobj_target[actor_idx * num_instances + instance_id]
	|| d_mobj_health[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id] <= 0
	|| !P_CheckSight (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id]) )
    {
	P_SetMobjState_GPU (actor_idx,  c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].seestate);
    }
}


__device__ void A_SpidRefire_GPU(int actor_idx, int instance_id, int num_instances)
{
    // keep firing unless target got out of sight
    A_FaceTarget (actor_idx, instance_id, num_instances);

    if (gpu_random () < 10)
	return;

    if (!d_mobj_target[actor_idx * num_instances + instance_id]
	|| d_mobj_health[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id] <= 0
	|| !P_CheckSight (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id]) )
    {
	P_SetMobjState_GPU (actor_idx,  c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].seestate);
    }
}

__device__ void A_BspiAttack_GPU(int actor_idx, int instance_id, int num_instances)
{
    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;

    A_FaceTarget (actor_idx, instance_id, num_instances);

    // launch a missile
    P_SpawnMissile_GPU (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id], MT_ARACHPLAZ);
}


//
// A_TroopAttack
//
__device__ void A_TroopAttack_GPU(int actor_idx, int instance_id, int num_instances)
{
    int		damage;

    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;

    A_FaceTarget (actor_idx, instance_id, num_instances);
    if (P_CheckMeleeRange_GPU (actor_idx, instance_id, num_instances))
    {
    // SKIP-GPU: S_StartSound (actor, sfx_claw);
	damage = (gpu_random()%8+1)*3;
	P_DamageMobj_GPU (d_mobj_target[actor_idx * num_instances + instance_id], actor_idx, actor, damage);
	return;
    }


    // launch a missile
    P_SpawnMissile_GPU (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id], MT_TROOPSHOT);
}


__device__ void A_SargAttack_GPU(int actor_idx, int instance_id, int num_instances)
{
    int		damage;

    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;

    A_FaceTarget (actor_idx, instance_id, num_instances);
    if (P_CheckMeleeRange_GPU (actor_idx, instance_id, num_instances))
    {
	damage = ((gpu_random()%10)+1)*4;
	P_DamageMobj_GPU (d_mobj_target[actor_idx * num_instances + instance_id], actor_idx, actor, damage);
    }
}

__device__ void A_HeadAttack_GPU(int actor_idx, int instance_id, int num_instances)
{
    int		damage;

    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;

    A_FaceTarget (actor_idx, instance_id, num_instances);
    if (P_CheckMeleeRange_GPU (actor_idx, instance_id, num_instances))
    {
	damage = (gpu_random()%6+1)*10;
	P_DamageMobj_GPU (d_mobj_target[actor_idx * num_instances + instance_id], actor_idx, actor, damage);
	return;
    }

    // launch a missile
    P_SpawnMissile_GPU (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id], MT_HEADSHOT);
}

__device__ void A_CyberAttack_GPU(int actor_idx, int instance_id, int num_instances)
{
    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;

    A_FaceTarget (actor_idx, instance_id, num_instances);
    P_SpawnMissile_GPU (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id], MT_ROCKET);
}


__device__ void A_BruisAttack_GPU(int actor_idx, int instance_id, int num_instances)
{
    int		damage;

    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;

    if (P_CheckMeleeRange_GPU (actor_idx, instance_id, num_instances))
    {
    // SKIP-GPU: S_StartSound (actor, sfx_claw);
	damage = (gpu_random()%8+1)*10;
	P_DamageMobj_GPU (d_mobj_target[actor_idx * num_instances + instance_id], actor_idx, actor, damage);
	return;
    }

    // launch a missile
    P_SpawnMissile_GPU (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id], MT_BRUISERSHOT);
}


//
// A_SkelMissile
//
__device__ void A_SkelMissile_GPU(int actor_idx, int instance_id, int num_instances)
{
    mobj_t*	mo;

    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;

    A_FaceTarget (actor_idx, instance_id, num_instances);
    d_mobj_z[actor_idx * num_instances + instance_id] += 16*FRACUNIT;	// so missile spawns higher
    mo = P_SpawnMissile_GPU (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id], MT_TRACER);
    d_mobj_z[actor_idx * num_instances + instance_id] -= 16*FRACUNIT;	// back to normal

    mo->x += mo->momx;
    mo->y += mo->momy;
    mo->tracer = d_mobj_target[actor_idx * num_instances + instance_id];
}

int	TRACEANGLE = 0xc000000;

__device__ void A_Tracer_GPU(int actor_idx, int instance_id, int num_instances)
{
    angle_t	exact;
    fixed_t	dist;
    fixed_t	slope;
    mobj_t*	dest;
    mobj_t*	th;

    if (gametic & 3)
	return;

    // spawn a puff of smoke behind the rocket
    P_SpawnPuff (d_mobj_x[actor_idx * num_instances + instance_id], d_mobj_y[actor_idx * num_instances + instance_id], d_mobj_z[actor_idx * num_instances + instance_id]);

    th = P_SpawnMobj_GPU (d_mobj_x[actor_idx * num_instances + instance_id]-d_mobj_momx[actor_idx * num_instances + instance_id],
		      d_mobj_y[actor_idx * num_instances + instance_id]-d_mobj_momy[actor_idx * num_instances + instance_id],
		      d_mobj_z[actor_idx * num_instances + instance_id], MT_SMOKE);

    th->momz = FRACUNIT;
    th->tics -= gpu_random()&3;
    if (th->tics < 1)
	th->tics = 1;

    // adjust direction
    dest = d_mobj_tracer[actor_idx * num_instances + instance_id];

    if (!dest || dest->health <= 0)
	return;

    // change angle
    exact = R_PointToAngle2 (d_mobj_x[actor_idx * num_instances + instance_id],
			     d_mobj_y[actor_idx * num_instances + instance_id],
			     dest->x,
			     dest->y);

    if (exact != d_mobj_angle[actor_idx * num_instances + instance_id])
    {
	if (exact - d_mobj_angle[actor_idx * num_instances + instance_id] > 0x80000000)
	{
	    d_mobj_angle[actor_idx * num_instances + instance_id] -= TRACEANGLE;
	    if (exact - d_mobj_angle[actor_idx * num_instances + instance_id] < 0x80000000)
		d_mobj_angle[actor_idx * num_instances + instance_id] = exact;
	}
	else
	{
	    d_mobj_angle[actor_idx * num_instances + instance_id] += TRACEANGLE;
	    if (exact - d_mobj_angle[actor_idx * num_instances + instance_id] > 0x80000000)
		d_mobj_angle[actor_idx * num_instances + instance_id] = exact;
	}
    }

    exact = d_mobj_angle[actor_idx * num_instances + instance_id]>>ANGLETOFINESHIFT;
    d_mobj_momx[actor_idx * num_instances + instance_id] = FixedMul (c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].speed, finecosine[exact]);
    d_mobj_momy[actor_idx * num_instances + instance_id] = FixedMul (c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].speed, finesine[exact]);

    // change slope
    dist = P_AproxDistance (dest->x - d_mobj_x[actor_idx * num_instances + instance_id],
			    dest->y - d_mobj_y[actor_idx * num_instances + instance_id]);

    dist = dist / c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].speed;

    if (dist < 1)
	dist = 1;
    slope = (dest->z+40*FRACUNIT - d_mobj_z[actor_idx * num_instances + instance_id]) / dist;

    if (slope < d_mobj_momz[actor_idx * num_instances + instance_id])
	d_mobj_momz[actor_idx * num_instances + instance_id] -= FRACUNIT/8;
    else
	d_mobj_momz[actor_idx * num_instances + instance_id] += FRACUNIT/8;
}


__device__ void A_SkelWhoosh_GPU(int actor_idx, int instance_id, int num_instances)
{
    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;
    A_FaceTarget (actor_idx, instance_id, num_instances);
    // SKIP-GPU: S_StartSound (actor,sfx_skeswg);
}

__device__ void A_SkelFist_GPU(int actor_idx, int instance_id, int num_instances)
{
    int		damage;

    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;

    A_FaceTarget (actor_idx, instance_id, num_instances);

    if (P_CheckMeleeRange_GPU (actor_idx, instance_id, num_instances))
    {
	damage = ((gpu_random()%10)+1)*6;
    // SKIP-GPU: S_StartSound (actor, sfx_skepch);
	P_DamageMobj_GPU (d_mobj_target[actor_idx * num_instances + instance_id], actor_idx, actor, damage);
    }
}



//
// PIT_VileCheck
// Detect a corpse that could be raised.
//
mobj_t*		corpsehit;
mobj_t*		vileobj;
fixed_t		viletryx;
fixed_t		viletryy;

__device__ boolean PIT_VileCheck_GPU(int thing_idx, int instance_id, int num_instances)
{
    int		maxdist;
    boolean	check;

    if (!(d_mobj_flags[thing_idx * num_instances + instance_id] & MF_CORPSE) )
	return true;	// not a monster

    if (d_mobj_tics[thing_idx * num_instances + instance_id] != -1)
	return true;	// not lying still yet

    if (c_mobjinfo[d_mobj_type[thing_idx * num_instances + instance_id]].raisestate == S_NULL)
	return true;	// monster doesn't have a raise state

    maxdist = c_mobjinfo[d_mobj_type[thing_idx * num_instances + instance_id]].radius + mobjinfo[MT_VILE].radius;

    if ( abs(d_mobj_x[thing_idx * num_instances + instance_id] - viletryx) > maxdist
	 || abs(d_mobj_y[thing_idx * num_instances + instance_id] - viletryy) > maxdist )
	return true;		// not actually touching

    corpsehit = thing_idx;
    corpsehit->momx = corpsehit->momy = 0;
    corpsehit->height <<= 2;
    check = P_CheckPosition (corpsehit, corpsehit->x, corpsehit->y);
    corpsehit->height >>= 2;

    if (!check)
	return true;		// doesn't fit here

    return false;		// got one, so stop checking
}



//
// A_VileChase
// Check for ressurecting a body
//
__device__ void A_VileChase_GPU(int actor_idx, int instance_id, int num_instances)
{
    int			xl;
    int			xh;
    int			yl;
    int			yh;

    int			bx;
    int			by;

    mobjinfo_t*		info;
    mobj_t*		temp;

    if (d_mobj_movedir[actor_idx * num_instances + instance_id] != DI_NODIR)
    {
	// check for corpses to raise
	viletryx =
	    d_mobj_x[actor_idx * num_instances + instance_id] + c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].speed*xspeed[d_mobj_movedir[actor_idx * num_instances + instance_id]];
	viletryy =
	    d_mobj_y[actor_idx * num_instances + instance_id] + c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].speed*yspeed[d_mobj_movedir[actor_idx * num_instances + instance_id]];

	xl = (viletryx - bmaporgx - MAXRADIUS*2)>>MAPBLOCKSHIFT;
	xh = (viletryx - bmaporgx + MAXRADIUS*2)>>MAPBLOCKSHIFT;
	yl = (viletryy - bmaporgy - MAXRADIUS*2)>>MAPBLOCKSHIFT;
	yh = (viletryy - bmaporgy + MAXRADIUS*2)>>MAPBLOCKSHIFT;

	vileobj = actor_idx;
	for (bx=xl ; bx<=xh ; bx++)
	{
	    for (by=yl ; by<=yh ; by++)
	    {
		// Call PIT_VileCheck to check
		// whether object is a corpse
		// that canbe raised.
		if (!P_BlockThingsIterator(bx,by,PIT_VileCheck))
		{
		    // got one!
		    temp = d_mobj_target[actor_idx * num_instances + instance_id];
		    d_mobj_target[actor_idx * num_instances + instance_id] = corpsehit;
		    A_FaceTarget (actor_idx, instance_id, num_instances);
		    d_mobj_target[actor_idx * num_instances + instance_id] = temp;

		    P_SetMobjState_GPU (actor_idx,  S_VILE_HEAL1);
    // SKIP-GPU: S_StartSound (corpsehit, sfx_slop);
		    info = corpsehit->info;

		    P_SetMobjState_GPU (corpsehit,info->raisestate);
		    corpsehit->height <<= 2;
		    corpsehit->flags = info->flags;
		    corpsehit->health = info->spawnhealth;
		    corpsehit->target = NULL;

		    return;
		}
	    }
	}
    }

    // Return to normal attack.
    A_Chase_GPU (actor_idx, instance_id, num_instances);
}


//
// A_VileStart
//
__device__ void A_VileStart_GPU(int actor_idx, int instance_id, int num_instances)
{
    // SKIP-GPU: S_StartSound (actor, sfx_vilatk);
}


//
// A_Fire
// Keep fire in front of player unless out of sight
//
__device__ void A_Fire_GPU(int actor_idx, int instance_id, int num_instances)

__device__ void A_StartFire_GPU(int actor_idx, int instance_id, int num_instances)
{
    // SKIP-GPU: S_StartSound(actor,sfx_flamst);
    A_Fire_GPU(actor_idx, instance_id, num_instances);
}

__device__ void A_FireCrackle_GPU(int actor_idx, int instance_id, int num_instances)
{
    // SKIP-GPU: S_StartSound(actor,sfx_flame);
    A_Fire_GPU(actor_idx, instance_id, num_instances);
}

__device__ void A_Fire_GPU(int actor_idx, int instance_id, int num_instances)
{
    mobj_t*	dest;
    unsigned	an;

    dest = d_mobj_tracer[actor_idx * num_instances + instance_id];
    if (!dest)
	return;

    // don't move it if the vile lost sight
    if (!P_CheckSight (d_mobj_target[actor_idx * num_instances + instance_id], dest) )
	return;

    an = dest->angle >> ANGLETOFINESHIFT;

    P_UnsetThingPosition (actor_idx, instance_id, num_instances);
    d_mobj_x[actor_idx * num_instances + instance_id] = dest->x + FixedMul (24*FRACUNIT, finecosine[an]);
    d_mobj_y[actor_idx * num_instances + instance_id] = dest->y + FixedMul (24*FRACUNIT, finesine[an]);
    d_mobj_z[actor_idx * num_instances + instance_id] = dest->z;
    P_SetThingPosition (actor_idx, instance_id, num_instances);
}



//
// A_VileTarget
// Spawn the hellfire
//
__device__ void A_VileTarget_GPU(int actor_idx, int instance_id, int num_instances)
{
    mobj_t*	fog;

    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;

    A_FaceTarget (actor_idx, instance_id, num_instances);

    fog = P_SpawnMobj_GPU (d_mobj_x[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id],
		       d_mobj_x[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id],
		       d_mobj_z[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id], MT_FIRE);

    d_mobj_tracer[actor_idx * num_instances + instance_id] = fog;
    fog->target = actor_idx;
    fog->tracer = d_mobj_target[actor_idx * num_instances + instance_id];
    A_Fire_GPU (fog);
}




//
// A_VileAttack
//
__device__ void A_VileAttack_GPU(int actor_idx, int instance_id, int num_instances)
{
    mobj_t*	fire;
    int		an;

    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;

    A_FaceTarget (actor_idx, instance_id, num_instances);

    if (!P_CheckSight (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id]) )
	return;

    // SKIP-GPU: S_StartSound (actor, sfx_barexp);
    P_DamageMobj_GPU (d_mobj_target[actor_idx * num_instances + instance_id], actor_idx, actor, 20);
    d_mobj_momz[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id] = 1000*FRACUNIT/c_mobjinfo[d_mobj_type[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id]].mass;

    an = d_mobj_angle[actor_idx * num_instances + instance_id] >> ANGLETOFINESHIFT;

    fire = d_mobj_tracer[actor_idx * num_instances + instance_id];

    if (!fire)
	return;

    // move the fire between the vile and the player
    fire->x = d_mobj_x[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id] - FixedMul (24*FRACUNIT, finecosine[an]);
    fire->y = d_mobj_y[d_mobj_target[actor_idx * num_instances + instance_id] * num_instances + instance_id] - FixedMul (24*FRACUNIT, finesine[an]);
    P_RadiusAttack (fire, actor_idx, 70 );
}




//
// Mancubus attack,
// firing three missiles (bruisers)
// in three different directions?
// Doesn't look like it.
//
#define	FATSPREAD	(ANG90/8)

__device__ void A_FatRaise_GPU(int actor_idx, int instance_id, int num_instances)
{
    A_FaceTarget (actor_idx, instance_id, num_instances);
    // SKIP-GPU: S_StartSound (actor, sfx_manatk);
}


__device__ void A_FatAttack1_GPU(int actor_idx, int instance_id, int num_instances)
{
    mobj_t*	mo;
    int		an;

    A_FaceTarget (actor_idx, instance_id, num_instances);
    // Change direction  to ...
    d_mobj_angle[actor_idx * num_instances + instance_id] += FATSPREAD;
    P_SpawnMissile_GPU (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id], MT_FATSHOT);

    mo = P_SpawnMissile_GPU (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id], MT_FATSHOT);
    mo->angle += FATSPREAD;
    an = mo->angle >> ANGLETOFINESHIFT;
    mo->momx = FixedMul (mo->info->speed, finecosine[an]);
    mo->momy = FixedMul (mo->info->speed, finesine[an]);
}

__device__ void A_FatAttack2_GPU(int actor_idx, int instance_id, int num_instances)
{
    mobj_t*	mo;
    int		an;

    A_FaceTarget (actor_idx, instance_id, num_instances);
    // Now here choose opposite deviation.
    d_mobj_angle[actor_idx * num_instances + instance_id] -= FATSPREAD;
    P_SpawnMissile_GPU (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id], MT_FATSHOT);

    mo = P_SpawnMissile_GPU (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id], MT_FATSHOT);
    mo->angle -= FATSPREAD*2;
    an = mo->angle >> ANGLETOFINESHIFT;
    mo->momx = FixedMul (mo->info->speed, finecosine[an]);
    mo->momy = FixedMul (mo->info->speed, finesine[an]);
}

__device__ void A_FatAttack3_GPU(int actor_idx, int instance_id, int num_instances)
{
    mobj_t*	mo;
    int		an;

    A_FaceTarget (actor_idx, instance_id, num_instances);

    mo = P_SpawnMissile_GPU (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id], MT_FATSHOT);
    mo->angle -= FATSPREAD/2;
    an = mo->angle >> ANGLETOFINESHIFT;
    mo->momx = FixedMul (mo->info->speed, finecosine[an]);
    mo->momy = FixedMul (mo->info->speed, finesine[an]);

    mo = P_SpawnMissile_GPU (actor_idx,  d_mobj_target[actor_idx * num_instances + instance_id], MT_FATSHOT);
    mo->angle += FATSPREAD/2;
    an = mo->angle >> ANGLETOFINESHIFT;
    mo->momx = FixedMul (mo->info->speed, finecosine[an]);
    mo->momy = FixedMul (mo->info->speed, finesine[an]);
}


//
// SkullAttack
// Fly at the player like a missile.
//
#define	SKULLSPEED		(20*FRACUNIT)

__device__ void A_SkullAttack_GPU(int actor_idx, int instance_id, int num_instances)
{
    mobj_t*		dest;
    angle_t		an;
    int			dist;

    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;

    dest = d_mobj_target[actor_idx * num_instances + instance_id];
    d_mobj_flags[actor_idx * num_instances + instance_id] |= MF_SKULLFLY;

    // SKIP-GPU: S_StartSound (actor, c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].attacksound);
    A_FaceTarget (actor_idx, instance_id, num_instances);
    an = d_mobj_angle[actor_idx * num_instances + instance_id] >> ANGLETOFINESHIFT;
    d_mobj_momx[actor_idx * num_instances + instance_id] = FixedMul (SKULLSPEED, finecosine[an]);
    d_mobj_momy[actor_idx * num_instances + instance_id] = FixedMul (SKULLSPEED, finesine[an]);
    dist = P_AproxDistance (dest->x - d_mobj_x[actor_idx * num_instances + instance_id], dest->y - d_mobj_y[actor_idx * num_instances + instance_id]);
    dist = dist / SKULLSPEED;

    if (dist < 1)
	dist = 1;
    d_mobj_momz[actor_idx * num_instances + instance_id] = (dest->z+(dest->height>>1) - d_mobj_z[actor_idx * num_instances + instance_id]) / dist;
}


//
// A_PainShootSkull
// Spawn a lost soul and launch it at the target
//
__device__ void A_PainShootSkull_GPU(int actor_idx, angle_t angle, int instance_id, int num_instances)
{
    fixed_t	x;
    fixed_t	y;
    fixed_t	z;

    mobj_t*	newmobj;
    angle_t	an;
    int		prestep;
    int		count;
    thinker_t*	currentthinker;

    // count total number of skull currently on the level
    count = 0;

    currentthinker = thinkercap.next;
    while (currentthinker != &thinkercap)
    {
	if (   (currentthinker->function.acp1 == (actionf_p1)P_MobjThinker)
	    && ((mobj_t *)currentthinker)->type == MT_SKULL)
	    count++;
	currentthinker = currentthinker->next;
    }

    // if there are allready 20 skulls on the level,
    // don't spit another one
    if (count > 20)
	return;


    // okay, there's playe for another one
    an = angle >> ANGLETOFINESHIFT;

    prestep =
	4*FRACUNIT
	+ 3*(c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].radius + mobjinfo[MT_SKULL].radius)/2;

    x = d_mobj_x[actor_idx * num_instances + instance_id] + FixedMul (prestep, finecosine[an]);
    y = d_mobj_y[actor_idx * num_instances + instance_id] + FixedMul (prestep, finesine[an]);
    z = d_mobj_z[actor_idx * num_instances + instance_id] + 8*FRACUNIT;

    newmobj = P_SpawnMobj_GPU (x , y, z, MT_SKULL);

    // Check for movements.
    if (!P_TryMove (newmobj, newmobj->x, newmobj->y))
    {
	// kill it immediately
	P_DamageMobj_GPU (newmobj, actor_idx,actor,10000);
	return;
    }

    newmobj->target = d_mobj_target[actor_idx * num_instances + instance_id];
    A_SkullAttack (newmobj);
}


//
// A_PainAttack
// Spawn a lost soul and launch it at the target
//
__device__ void A_PainAttack_GPU(int actor_idx, int instance_id, int num_instances)
{
    if (!d_mobj_target[actor_idx * num_instances + instance_id])
	return;

    A_FaceTarget (actor_idx, instance_id, num_instances);
    A_PainShootSkull (actor_idx,  d_mobj_angle[actor_idx * num_instances + instance_id]);
}


__device__ void A_PainDie_GPU(int actor_idx, int instance_id, int num_instances)
{
    A_Fall (actor_idx, instance_id, num_instances);
    A_PainShootSkull (actor_idx,  d_mobj_angle[actor_idx * num_instances + instance_id]+ANG90);
    A_PainShootSkull (actor_idx,  d_mobj_angle[actor_idx * num_instances + instance_id]+ANG180);
    A_PainShootSkull (actor_idx,  d_mobj_angle[actor_idx * num_instances + instance_id]+ANG270);
}






__device__ void A_Scream_GPU(int actor_idx, int instance_id, int num_instances)
{
    int		sound;

    switch (c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].deathsound)
    {
      case 0:
	return;

      case sfx_podth1:
      case sfx_podth2:
      case sfx_podth3:
	sound = sfx_podth1 + gpu_random ()%3;
	break;

      case sfx_bgdth1:
      case sfx_bgdth2:
	sound = sfx_bgdth1 + gpu_random ()%2;
	break;

      default:
	sound = c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].deathsound;
	break;
    }

    // Check for bosses.
    if (d_mobj_type[actor_idx * num_instances + instance_id]==MT_SPIDER
	|| d_mobj_type[actor_idx * num_instances + instance_id] == MT_CYBORG)
    {
	// full volume
    // SKIP-GPU: S_StartSound (NULL, sound);
    }
    else
    // SKIP-GPU: S_StartSound (actor, sound);
}


__device__ void A_XScream_GPU(int actor_idx, int instance_id, int num_instances)
{
    // SKIP-GPU: S_StartSound (actor, sfx_slop);
}

__device__ void A_Pain_GPU(int actor_idx, int instance_id, int num_instances)
{
    if (c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].painsound)
    // SKIP-GPU: S_StartSound (actor, c_mobjinfo[d_mobj_type[actor_idx * num_instances + instance_id]].painsound);
}



__device__ void A_Fall_GPU(int actor_idx, int instance_id, int num_instances)
{
    // actor is on ground, it can be walked over
    d_mobj_flags[actor_idx * num_instances + instance_id] &= ~MF_SOLID;

    // So change this if corpse objects
    // are meant to be obstacles.
}


//
// A_Explode
//
__device__ void A_Explode_GPU(int thingy_idx, int instance_id, int num_instances)
{
    P_RadiusAttack (thingy_idx,  d_mobj_target[thingy_idx * num_instances + instance_id], 128 );
}


//
// A_BossDeath
// Possibly trigger special effects
// if on first boss level
//
__device__ void A_BossDeath_GPU(int mo_idx, int instance_id, int num_instances)
{
    thinker_t*	th;
    mobj_t*	mo2;
    line_t	junk;
    int		i;

    if ( gamemode == commercial)
    {
	if (gamemap != 7)
	    return;

	if ((d_mobj_type[mo_idx * num_instances + instance_id] != MT_FATSO)
	    && (d_mobj_type[mo_idx * num_instances + instance_id] != MT_BABY))
	    return;
    }
    else
    {
	switch(gameepisode)
	{
	  case 1:
	    if (gamemap != 8)
		return;

	    if (d_mobj_type[mo_idx * num_instances + instance_id] != MT_BRUISER)
		return;
	    break;

	  case 2:
	    if (gamemap != 8)
		return;

	    if (d_mobj_type[mo_idx * num_instances + instance_id] != MT_CYBORG)
		return;
	    break;

	  case 3:
	    if (gamemap != 8)
		return;

	    if (d_mobj_type[mo_idx * num_instances + instance_id] != MT_SPIDER)
		return;

	    break;

	  case 4:
	    switch(gamemap)
	    {
	      case 6:
		if (d_mobj_type[mo_idx * num_instances + instance_id] != MT_CYBORG)
		    return;
		break;

	      case 8:
		if (d_mobj_type[mo_idx * num_instances + instance_id] != MT_SPIDER)
		    return;
		break;

	      default:
		return;
		break;
	    }
	    break;

	  default:
	    if (gamemap != 8)
		return;
	    break;
	}

    }


    // make sure there is a player alive for victory
    for (i=0 ; i<MAXPLAYERS ; i++)
	if (playeringame[i] && d_player_health[instance_id] > 0)
	    break;

    if (i==MAXPLAYERS)
	return;	// no one left alive, so do not end game

    // scan the remaining thinkers to see
    // if all bosses are dead
    for (th = thinkercap.next ; th != &thinkercap ; th=th->next)
    {
	if (th->function.acp1 != (actionf_p1)P_MobjThinker)
	    continue;

	mo2 = (mobj_t *)th;
	if (mo2 != mo
	    && mo2->type == d_mobj_type[mo_idx * num_instances + instance_id]
	    && mo2->health > 0)
	{
	    // other boss not dead
	    return;
	}
    }

    // victory!
    if ( gamemode == commercial)
    {
	if (gamemap == 7)
	{
	    if (d_mobj_type[mo_idx * num_instances + instance_id] == MT_FATSO)
	    {
		junk.tag = 666;
		EV_DoFloor(&junk,lowerFloorToLowest);
		return;
	    }

	    if (d_mobj_type[mo_idx * num_instances + instance_id] == MT_BABY)
	    {
		junk.tag = 667;
		EV_DoFloor(&junk,raiseToTexture);
		return;
	    }
	}
    }
    else
    {
	switch(gameepisode)
	{
	  case 1:
	    junk.tag = 666;
	    EV_DoFloor (&junk, lowerFloorToLowest);
	    return;
	    break;

	  case 4:
	    switch(gamemap)
	    {
	      case 6:
		junk.tag = 666;
		EV_DoDoor (&junk, blazeOpen);
		return;
		break;

	      case 8:
		junk.tag = 666;
		EV_DoFloor (&junk, lowerFloorToLowest);
		return;
		break;
	    }
	}
    }

    G_ExitLevel ();
}


__device__ void A_Hoof_GPU(int mo_idx, int instance_id, int num_instances)
{
    // SKIP-GPU: S_StartSound (mo, sfx_hoof);
    A_Chase_GPU (mo_idx, instance_id, num_instances);
}

__device__ void A_Metal_GPU(int mo_idx, int instance_id, int num_instances)
{
    // SKIP-GPU: S_StartSound (mo, sfx_metal);
    A_Chase_GPU (mo_idx, instance_id, num_instances);
}

__device__ void A_BabyMetal_GPU(int mo_idx, int instance_id, int num_instances)
{
    // SKIP-GPU: S_StartSound (mo, sfx_bspwlk);
    A_Chase_GPU (mo_idx, instance_id, num_instances);
}

void
A_OpenShotgun2
( player_t*	player,
  pspdef_t*	psp )
{
    // SKIP-GPU: S_StartSound (player->mo, sfx_dbopn);
}

void
A_LoadShotgun2
( player_t*	player,
  pspdef_t*	psp )
{
    // SKIP-GPU: S_StartSound (player->mo, sfx_dbload);
}

void
A_ReFire
( player_t*	player,
  pspdef_t*	psp );

void
A_CloseShotgun2
( player_t*	player,
  pspdef_t*	psp )
{
    // SKIP-GPU: S_StartSound (player->mo, sfx_dbcls);
    A_ReFire(player,psp);
}



mobj_t*		braintargets[32];
int		numbraintargets;
int		braintargeton;

__device__ void A_BrainAwake_GPU(int mo_idx, int instance_id, int num_instances)
{
    thinker_t*	thinker;
    mobj_t*	m;

    // find all the target spots
    numbraintargets = 0;
    braintargeton = 0;

    thinker = thinkercap.next;
    for (thinker = thinkercap.next ;
	 thinker != &thinkercap ;
	 thinker = thinker->next)
    {
	if (thinker->function.acp1 != (actionf_p1)P_MobjThinker)
	    continue;	// not a mobj

	m = (mobj_t *)thinker;

	if (m->type == MT_BOSSTARGET )
	{
	    braintargets[numbraintargets] = m;
	    numbraintargets++;
	}
    }

    // SKIP-GPU: S_StartSound (NULL,sfx_bossit);
}


__device__ void A_BrainPain_GPU(int mo_idx, int instance_id, int num_instances)
{
    // SKIP-GPU: S_StartSound (NULL,sfx_bospn);
}


__device__ void A_BrainScream_GPU(int mo_idx, int instance_id, int num_instances)
{
    int		x;
    int		y;
    int		z;
    mobj_t*	th;

    for (x=d_mobj_x[mo_idx * num_instances + instance_id] - 196*FRACUNIT ; x< d_mobj_x[mo_idx * num_instances + instance_id] + 320*FRACUNIT ; x+= FRACUNIT*8)
    {
	y = d_mobj_y[mo_idx * num_instances + instance_id] - 320*FRACUNIT;
	z = 128 + gpu_random()*2*FRACUNIT;
	th = P_SpawnMobj_GPU (x,y,z, MT_ROCKET);
	th->momz = gpu_random()*512;

	P_SetMobjState_GPU (th, S_BRAINEXPLODE1);

	th->tics -= gpu_random()&7;
	if (th->tics < 1)
	    th->tics = 1;
    }

    // SKIP-GPU: S_StartSound (NULL,sfx_bosdth);
}



__device__ void A_BrainExplode_GPU(int mo_idx, int instance_id, int num_instances)
{
    int		x;
    int		y;
    int		z;
    mobj_t*	th;

    x = d_mobj_x[mo_idx * num_instances + instance_id] + (gpu_random () - gpu_random ())*2048;
    y = d_mobj_y[mo_idx * num_instances + instance_id];
    z = 128 + gpu_random()*2*FRACUNIT;
    th = P_SpawnMobj_GPU (x,y,z, MT_ROCKET);
    th->momz = gpu_random()*512;

    P_SetMobjState_GPU (th, S_BRAINEXPLODE1);

    th->tics -= gpu_random()&7;
    if (th->tics < 1)
	th->tics = 1;
}


__device__ void A_BrainDie_GPU(int mo_idx, int instance_id, int num_instances)
{
    G_ExitLevel ();
}

__device__ void A_BrainSpit_GPU(int mo_idx, int instance_id, int num_instances)
{
    mobj_t*	targ;
    mobj_t*	newmobj;

    static int	easy = 0;

    easy ^= 1;
    if (gameskill <= sk_easy && (!easy))
	return;

    // shoot a cube at current target
    targ = braintargets[braintargeton];
    braintargeton = (braintargeton+1)%numbraintargets;

    // spawn brain missile
    newmobj = P_SpawnMissile_GPU (mo_idx,  targ, MT_SPAWNSHOT);
    newmobj->target = targ;
    newmobj->reactiontime =
	((targ->y - d_mobj_y[mo_idx * num_instances + instance_id])/newmobj->momy) / newmobj->state->tics;

    // SKIP-GPU: S_StartSound(NULL, sfx_bospit);
}



__device__ void A_SpawnFly_GPU(int mo_idx, int instance_id, int num_instances)

// travelling cube sound
__device__ void A_SpawnSound_GPU(int mo_idx, int instance_id, int num_instances)
{
    // SKIP-GPU: S_StartSound (mo,sfx_boscub);
    A_SpawnFly(mo_idx, instance_id, num_instances);
}

__device__ void A_SpawnFly_GPU(int mo_idx, int instance_id, int num_instances)
{
    mobj_t*	newmobj;
    mobj_t*	fog;
    mobj_t*	targ;
    int		r;
    mobjtype_t	type;

    if (--d_mobj_reactiontime[mo_idx * num_instances + instance_id])
	return;	// still flying

    targ = d_mobj_target[mo_idx * num_instances + instance_id];

    // First spawn teleport fog.
    fog = P_SpawnMobj_GPU (targ->x, targ->y, targ->z, MT_SPAWNFIRE);
    // SKIP-GPU: S_StartSound (fog, sfx_telept);

    // Randomly select monster to spawn.
    r = gpu_random ();

    // Probability distribution (kind of :),
    // decreasing likelihood.
    if ( r<50 )
	type = MT_TROOP;
    else if (r<90)
	type = MT_SERGEANT;
    else if (r<120)
	type = MT_SHADOWS;
    else if (r<130)
	type = MT_PAIN;
    else if (r<160)
	type = MT_HEAD;
    else if (r<162)
	type = MT_VILE;
    else if (r<172)
	type = MT_UNDEAD;
    else if (r<192)
	type = MT_BABY;
    else if (r<222)
	type = MT_FATSO;
    else if (r<246)
	type = MT_KNIGHT;
    else
	type = MT_BRUISER;

    newmobj	= P_SpawnMobj_GPU (targ->x, targ->y, targ->z, type);
    if (P_LookForPlayers_GPU (newmobj, true) )
	P_SetMobjState_GPU (newmobj, newmobj->info->seestate);

    // telefrag anything in this spot
    P_TeleportMove (newmobj, newmobj->x, newmobj->y);

    // remove self (i.e., cube).
    P_RemoveMobj (mo_idx, instance_id, num_instances);
}



__device__ void A_PlayerScream_GPU(int mo_idx, int instance_id, int num_instances)
{
    // Default death sound.
    int		sound = sfx_pldeth;

    if ( (gamemode == commercial)
	&& 	(d_mobj_health[mo_idx * num_instances + instance_id] < -50))
    {
	// IF THE PLAYER DIES
	// LESS THAN -50% WITHOUT GIBBING
	sound = sfx_pdiehi;
    }

    // SKIP-GPU: S_StartSound (mo, sound);
}
