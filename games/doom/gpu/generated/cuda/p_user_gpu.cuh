// GPU-transformed from p_user.c
// Generated by doom_cuda_transformer.py (backend: cuda)
// Original: id Software DOOM (1993)

#include "doom_types.cuh"

// Emacs style mode select   -*- C++ -*-
//-----------------------------------------------------------------------------
//
// $Id:$
//
// Copyright (C) 1993-1996 by id Software, Inc.
//
// This source is available for distribution and/or modification
// only under the terms of the DOOM Source Code License as
// published by id Software. All rights reserved.
//
// The source is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License
// for more details.
//
// $Log:$
//
// DESCRIPTION:
//	Player related stuff.
//	Bobbing POV/weapon, movement.
//	Pending weapon.
//
//-----------------------------------------------------------------------------


static const char
rcsid[] = "$Id: p_user.c,v 1.3 1997/01/28 22:08:29 b1 Exp $";


#include "doomdef.h"
#include "d_event.h"

#include "p_local.h"

#include "doomstat.h"



// Index of the special effects (INVUL inverse) map.
#define INVERSECOLORMAP		32


//
// Movement.
//

// 16 pixels of bob
#define MAXBOB	0x100000

boolean		onground;


//
// P_Thrust
// Moves the given origin along a given angle.
//
void
P_Thrust
( player_t*	player,
  angle_t	angle,
  fixed_t	move )
{
    angle >>= ANGLETOFINESHIFT;

    d_mobj_momx[d_player_mo[instance_id] * num_instances + instance_id] += FixedMul(move,finecosine[angle]);
    d_mobj_momy[d_player_mo[instance_id] * num_instances + instance_id] += FixedMul(move,finesine[angle]);
}




//
// P_CalcHeight
// Calculate the walking / running height adjustment
//
void P_CalcHeight (player_t* player)
{
    int		angle;
    fixed_t	bob;

    // Regular movement bobbing
    // (needs to be calculated for gun swing
    // even if not on ground)
    // OPTIMIZE: tablify angle
    // Note: a LUT allows for effects
    //  like a ramp with low health.
    d_player_bob[instance_id] =
	FixedMul (d_mobj_momx[d_player_mo[instance_id] * num_instances + instance_id], d_mobj_momx[d_player_mo[instance_id] * num_instances + instance_id])
	+ FixedMul (d_mobj_momy[d_player_mo[instance_id] * num_instances + instance_id],d_mobj_momy[d_player_mo[instance_id] * num_instances + instance_id]);

    d_player_bob[instance_id] >>= 2;

    if (d_player_bob[instance_id]>MAXBOB)
	d_player_bob[instance_id] = MAXBOB;

    if ((d_player_cheats[instance_id] & CF_NOMOMENTUM) || !onground)
    {
	d_player_viewz[instance_id] = d_mobj_z[d_player_mo[instance_id] * num_instances + instance_id] + VIEWHEIGHT;

	if (d_player_viewz[instance_id] > d_mobj_ceilingz[d_player_mo[instance_id] * num_instances + instance_id]-4*FRACUNIT)
	    d_player_viewz[instance_id] = d_mobj_ceilingz[d_player_mo[instance_id] * num_instances + instance_id]-4*FRACUNIT;

	d_player_viewz[instance_id] = d_mobj_z[d_player_mo[instance_id] * num_instances + instance_id] + d_player_viewheight[instance_id];
	return;
    }

    angle = (FINEANGLES/20*leveltime)&FINEMASK;
    bob = FixedMul ( d_player_bob[instance_id]/2, finesine[angle]);


    // move viewheight
    if (d_player_playerstate[instance_id] == PST_LIVE)
    {
	d_player_viewheight[instance_id] += d_player_deltaviewheight[instance_id];

	if (d_player_viewheight[instance_id] > VIEWHEIGHT)
	{
	    d_player_viewheight[instance_id] = VIEWHEIGHT;
	    d_player_deltaviewheight[instance_id] = 0;
	}

	if (d_player_viewheight[instance_id] < VIEWHEIGHT/2)
	{
	    d_player_viewheight[instance_id] = VIEWHEIGHT/2;
	    if (d_player_deltaviewheight[instance_id] <= 0)
		d_player_deltaviewheight[instance_id] = 1;
	}

	if (d_player_deltaviewheight[instance_id])
	{
	    d_player_deltaviewheight[instance_id] += FRACUNIT/4;
	    if (!d_player_deltaviewheight[instance_id])
		d_player_deltaviewheight[instance_id] = 1;
	}
    }
    d_player_viewz[instance_id] = d_mobj_z[d_player_mo[instance_id] * num_instances + instance_id] + d_player_viewheight[instance_id] + bob;

    if (d_player_viewz[instance_id] > d_mobj_ceilingz[d_player_mo[instance_id] * num_instances + instance_id]-4*FRACUNIT)
	d_player_viewz[instance_id] = d_mobj_ceilingz[d_player_mo[instance_id] * num_instances + instance_id]-4*FRACUNIT;
}



//
// P_MovePlayer
//
void P_MovePlayer (player_t* player)
{
    ticcmd_t*		cmd;

    cmd = &d_player_cmd[instance_id];

    d_mobj_angle[d_player_mo[instance_id] * num_instances + instance_id] += (cmd->angleturn<<16);

    // Do not let the player control movement
    //  if not onground.
    onground = (d_mobj_z[d_player_mo[instance_id] * num_instances + instance_id] <= d_mobj_floorz[d_player_mo[instance_id] * num_instances + instance_id]);

    if (cmd->forwardmove && onground)
	P_Thrust (player, d_mobj_angle[d_player_mo[instance_id] * num_instances + instance_id], cmd->forwardmove*2048);

    if (cmd->sidemove && onground)
	P_Thrust (player, d_mobj_angle[d_player_mo[instance_id] * num_instances + instance_id]-ANG90, cmd->sidemove*2048);

    if ( (cmd->forwardmove || cmd->sidemove)
	 && d_mobj_state[d_player_mo[instance_id] * num_instances + instance_id] == &states[S_PLAY] )
    {
	P_SetMobjState_GPU (d_player_mo[instance_id], S_PLAY_RUN1);
    }
}



//
// P_DeathThink
// Fall on your face when dying.
// Decrease POV height to floor height.
//
#define ANG5   	(ANG90/18)

void P_DeathThink (player_t* player)
{
    angle_t		angle;
    angle_t		delta;

    P_MovePsprites (player);

    // fall to the ground
    if (d_player_viewheight[instance_id] > 6*FRACUNIT)
	d_player_viewheight[instance_id] -= FRACUNIT;

    if (d_player_viewheight[instance_id] < 6*FRACUNIT)
	d_player_viewheight[instance_id] = 6*FRACUNIT;

    d_player_deltaviewheight[instance_id] = 0;
    onground = (d_mobj_z[d_player_mo[instance_id] * num_instances + instance_id] <= d_mobj_floorz[d_player_mo[instance_id] * num_instances + instance_id]);
    P_CalcHeight (player);

    if (d_player_attacker[instance_id] && d_player_attacker[instance_id] != d_player_mo[instance_id])
    {
	angle = R_PointToAngle2 (d_mobj_x[d_player_mo[instance_id] * num_instances + instance_id],
				 d_mobj_y[d_player_mo[instance_id] * num_instances + instance_id],
				 d_player_attacker[instance_id]->x,
				 d_player_attacker[instance_id]->y);

	delta = angle - d_mobj_angle[d_player_mo[instance_id] * num_instances + instance_id];

	if (delta < ANG5 || delta > (unsigned)-ANG5)
	{
	    // Looking at killer,
	    //  so fade damage flash down.
	    d_mobj_angle[d_player_mo[instance_id] * num_instances + instance_id] = angle;

	    if (d_player_damagecount[instance_id])
		d_player_damagecount[instance_id]--;
	}
	else if (delta < ANG180)
	    d_mobj_angle[d_player_mo[instance_id] * num_instances + instance_id] += ANG5;
	else
	    d_mobj_angle[d_player_mo[instance_id] * num_instances + instance_id] -= ANG5;
    }
    else if (d_player_damagecount[instance_id])
	d_player_damagecount[instance_id]--;


    if (d_player_cmd[instance_id].buttons & BT_USE)
	d_player_playerstate[instance_id] = PST_REBORN;
}



//
// P_PlayerThink
//
void P_PlayerThink (player_t* player)
{
    ticcmd_t*		cmd;
    weapontype_t	newweapon;

    // fixme: do this in the cheat code
    if (d_player_cheats[instance_id] & CF_NOCLIP)
	d_mobj_flags[d_player_mo[instance_id] * num_instances + instance_id] |= MF_NOCLIP;
    else
	d_mobj_flags[d_player_mo[instance_id] * num_instances + instance_id] &= ~MF_NOCLIP;

    // chain saw run forward
    cmd = &d_player_cmd[instance_id];
    if (d_mobj_flags[d_player_mo[instance_id] * num_instances + instance_id] & MF_JUSTATTACKED)
    {
	cmd->angleturn = 0;
	cmd->forwardmove = 0xc800/512;
	cmd->sidemove = 0;
	d_mobj_flags[d_player_mo[instance_id] * num_instances + instance_id] &= ~MF_JUSTATTACKED;
    }


    if (d_player_playerstate[instance_id] == PST_DEAD)
    {
	P_DeathThink (player);
	return;
    }

    // Move around.
    // Reactiontime is used to prevent movement
    //  for a bit after a teleport.
    if (d_mobj_reactiontime[d_player_mo[instance_id] * num_instances + instance_id])
	d_mobj_reactiontime[d_player_mo[instance_id] * num_instances + instance_id]--;
    else
	P_MovePlayer (player);

    P_CalcHeight (player);

    if (d_mobj_subsector[d_player_mo[instance_id] * num_instances + instance_id]->sector->special)
	P_PlayerInSpecialSector (player);

    // Check for weapon change.

    // A special event has no other buttons.
    if (cmd->buttons & BT_SPECIAL)
	cmd->buttons = 0;

    if (cmd->buttons & BT_CHANGE)
    {
	// The actual changing of the weapon is done
	//  when the weapon psprite can do it
	//  (read: not in the middle of an attack).
	newweapon = (cmd->buttons&BT_WEAPONMASK)>>BT_WEAPONSHIFT;

	if (newweapon == wp_fist
	    && d_player_weaponowned[instance_id][wp_chainsaw]
	    && !(d_player_readyweapon[instance_id] == wp_chainsaw
		 && d_player_powers[instance_id][pw_strength]))
	{
	    newweapon = wp_chainsaw;
	}

	if ( (gamemode == commercial)
	    && newweapon == wp_shotgun
	    && d_player_weaponowned[instance_id][wp_supershotgun]
	    && d_player_readyweapon[instance_id] != wp_supershotgun)
	{
	    newweapon = wp_supershotgun;
	}


	if (d_player_weaponowned[instance_id][newweapon]
	    && newweapon != d_player_readyweapon[instance_id])
	{
	    // Do not go to plasma or BFG in shareware,
	    //  even if cheated.
	    if ((newweapon != wp_plasma
		 && newweapon != wp_bfg)
		|| (gamemode != shareware) )
	    {
		d_player_pendingweapon[instance_id] = newweapon;
	    }
	}
    }

    // check for use
    if (cmd->buttons & BT_USE)
    {
	if (!d_player_usedown[instance_id])
	{
	    P_UseLines (player);
	    d_player_usedown[instance_id] = true;
	}
    }
    else
	d_player_usedown[instance_id] = false;

    // cycle psprites
    P_MovePsprites (player);

    // Counters, time dependend power ups.

    // Strength counts up to diminish fade.
    if (d_player_powers[instance_id][pw_strength])
	d_player_powers[instance_id][pw_strength]++;

    if (d_player_powers[instance_id][pw_invulnerability])
	d_player_powers[instance_id][pw_invulnerability]--;

    if (d_player_powers[instance_id][pw_invisibility])
	if (! --d_player_powers[instance_id][pw_invisibility] )
	    d_mobj_flags[d_player_mo[instance_id] * num_instances + instance_id] &= ~MF_SHADOW;

    if (d_player_powers[instance_id][pw_infrared])
	d_player_powers[instance_id][pw_infrared]--;

    if (d_player_powers[instance_id][pw_ironfeet])
	d_player_powers[instance_id][pw_ironfeet]--;

    if (d_player_damagecount[instance_id])
	d_player_damagecount[instance_id]--;

    if (d_player_bonuscount[instance_id])
	d_player_bonuscount[instance_id]--;


    // Handling colormaps.
    if (d_player_powers[instance_id][pw_invulnerability])
    {
	if (d_player_powers[instance_id][pw_invulnerability] > 4*32
	    || (d_player_powers[instance_id][pw_invulnerability]&8) )
	    d_player_fixedcolormap[instance_id] = INVERSECOLORMAP;
	else
	    d_player_fixedcolormap[instance_id] = 0;
    }
    else if (d_player_powers[instance_id][pw_infrared])
    {
	if (d_player_powers[instance_id][pw_infrared] > 4*32
	    || (d_player_powers[instance_id][pw_infrared]&8) )
	{
	    // almost full bright
	    d_player_fixedcolormap[instance_id] = 1;
	}
	else
	    d_player_fixedcolormap[instance_id] = 0;
    }
    else
	d_player_fixedcolormap[instance_id] = 0;
}


