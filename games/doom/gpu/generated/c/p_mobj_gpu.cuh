// GPU-transformed from p_mobj.c
// Generated by doom_cuda_transformer.py (backend: c)
// Original: id Software DOOM (1993)

#include "doom_types.h"
#include <stdint.h>

// Emacs style mode select   -*- C++ -*-
//-----------------------------------------------------------------------------
//
// $Id:$
//
// Copyright (C) 1993-1996 by id Software, Inc.
//
// This source is available for distribution and/or modification
// only under the terms of the DOOM Source Code License as
// published by id Software. All rights reserved.
//
// The source is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License
// for more details.
//
// $Log:$
//
// DESCRIPTION:
//	Moving object handling. Spawn functions.
//
//-----------------------------------------------------------------------------

static const char
rcsid[] = "$Id: p_mobj.c,v 1.5 1997/02/03 22:45:12 b1 Exp $";

#include "i_system.h"
#include "z_zone.h"
#include "m_random.h"

#include "doomdef.h"
#include "p_local.h"
#include "sounds.h"

#include "st_stuff.h"
#include "hu_stuff.h"

#include "s_sound.h"

#include "doomstat.h"


void G_PlayerReborn (int player);
void P_SpawnMapThing (mapthing_t*	mthing);


//
// P_SetMobjState
// Returns true if the mobj is still present.
//
int test;

static inline boolean P_SetMobjState_GPU(int mobj_idx, statenum_t state, int instance_id, int num_instances)
{
    state_t*	st;

    do
    {
	if (state == S_NULL)
	{
	    d_mobj_state[mobj_idx * num_instances + instance_id] = (state_t *) S_NULL;
	    P_RemoveMobj (mobj_idx, instance_id, num_instances);
	    return false;
	}

	st = &states[state];
	d_mobj_state[mobj_idx * num_instances + instance_id] = st;
	d_mobj_tics[mobj_idx * num_instances + instance_id] = st->tics;
	d_mobj_sprite[mobj_idx * num_instances + instance_id] = st->sprite;
	d_mobj_frame[mobj_idx * num_instances + instance_id] = st->frame;

	// Modified handling.
	// Call action functions when the state is set
	if (st->action.acp1)
	    st->action.acp1(mobj_idx, instance_id, num_instances);

	state = st->nextstate;
    } while (!d_mobj_tics[mobj_idx * num_instances + instance_id]);

    return true;
}


//
// P_ExplodeMissile
//
static inline void P_ExplodeMissile_GPU(int mo_idx, int instance_id, int num_instances)
{
    d_mobj_momx[mo_idx * num_instances + instance_id] = d_mobj_momy[mo_idx * num_instances + instance_id] = d_mobj_momz[mo_idx * num_instances + instance_id] = 0;

    P_SetMobjState_GPU (mo_idx,  mobjinfo[d_mobj_type[mo_idx * num_instances + instance_id]].deathstate);

    d_mobj_tics[mo_idx * num_instances + instance_id] -= gpu_random()&3;

    if (d_mobj_tics[mo_idx * num_instances + instance_id] < 1)
	d_mobj_tics[mo_idx * num_instances + instance_id] = 1;

    d_mobj_flags[mo_idx * num_instances + instance_id] &= ~MF_MISSILE;

    if (c_mobjinfo[d_mobj_type[mo_idx * num_instances + instance_id]].deathsound)
    // SKIP-GPU: S_StartSound (mo, c_mobjinfo[d_mobj_type[mo_idx * num_instances + instance_id]].deathsound);
}


//
// P_XYMovement
//
#define STOPSPEED		0x1000
#define FRICTION		0xe800

static inline void P_XYMovement_GPU(int mo_idx, int instance_id, int num_instances)
{
    fixed_t 	ptryx;
    fixed_t	ptryy;
    player_t*	player;
    fixed_t	xmove;
    fixed_t	ymove;

    if (!d_mobj_momx[mo_idx * num_instances + instance_id] && !d_mobj_momy[mo_idx * num_instances + instance_id])
    {
	if (d_mobj_flags[mo_idx * num_instances + instance_id] & MF_SKULLFLY)
	{
	    // the skull slammed into something
	    d_mobj_flags[mo_idx * num_instances + instance_id] &= ~MF_SKULLFLY;
	    d_mobj_momx[mo_idx * num_instances + instance_id] = d_mobj_momy[mo_idx * num_instances + instance_id] = d_mobj_momz[mo_idx * num_instances + instance_id] = 0;

	    P_SetMobjState_GPU (mo_idx,  c_mobjinfo[d_mobj_type[mo_idx * num_instances + instance_id]].spawnstate);
	}
	return;
    }

    player = d_mobj_player[mo_idx * num_instances + instance_id];

    if (d_mobj_momx[mo_idx * num_instances + instance_id] > MAXMOVE)
	d_mobj_momx[mo_idx * num_instances + instance_id] = MAXMOVE;
    else if (d_mobj_momx[mo_idx * num_instances + instance_id] < -MAXMOVE)
	d_mobj_momx[mo_idx * num_instances + instance_id] = -MAXMOVE;

    if (d_mobj_momy[mo_idx * num_instances + instance_id] > MAXMOVE)
	d_mobj_momy[mo_idx * num_instances + instance_id] = MAXMOVE;
    else if (d_mobj_momy[mo_idx * num_instances + instance_id] < -MAXMOVE)
	d_mobj_momy[mo_idx * num_instances + instance_id] = -MAXMOVE;

    xmove = d_mobj_momx[mo_idx * num_instances + instance_id];
    ymove = d_mobj_momy[mo_idx * num_instances + instance_id];

    do
    {
	if (xmove > MAXMOVE/2 || ymove > MAXMOVE/2)
	{
	    ptryx = d_mobj_x[mo_idx * num_instances + instance_id] + xmove/2;
	    ptryy = d_mobj_y[mo_idx * num_instances + instance_id] + ymove/2;
	    xmove >>= 1;
	    ymove >>= 1;
	}
	else
	{
	    ptryx = d_mobj_x[mo_idx * num_instances + instance_id] + xmove;
	    ptryy = d_mobj_y[mo_idx * num_instances + instance_id] + ymove;
	    xmove = ymove = 0;
	}

	if (!P_TryMove (mo_idx,  ptryx, ptryy))
	{
	    // blocked move
	    if (d_mobj_player[mo_idx * num_instances + instance_id])
	    {	// try to slide along it
		P_SlideMove (mo_idx, instance_id, num_instances);
	    }
	    else if (d_mobj_flags[mo_idx * num_instances + instance_id] & MF_MISSILE)
	    {
		// explode a missile
		if (ceilingline &&
		    ceilingline->backsector &&
		    ceilingline->backsector->ceilingpic == skyflatnum)
		{
		    // Hack to prevent missiles exploding
		    // against the sky.
		    // Does not handle sky floors.
		    P_RemoveMobj (mo_idx, instance_id, num_instances);
		    return;
		}
		P_ExplodeMissile (mo_idx, instance_id, num_instances);
	    }
	    else
		d_mobj_momx[mo_idx * num_instances + instance_id] = d_mobj_momy[mo_idx * num_instances + instance_id] = 0;
	}
    } while (xmove || ymove);

    // slow down
    if (player && d_player_cheats[instance_id] & CF_NOMOMENTUM)
    {
	// debug option for no sliding at all
	d_mobj_momx[mo_idx * num_instances + instance_id] = d_mobj_momy[mo_idx * num_instances + instance_id] = 0;
	return;
    }

    if (d_mobj_flags[mo_idx * num_instances + instance_id] & (MF_MISSILE | MF_SKULLFLY) )
	return; 	// no friction for missiles ever

    if (d_mobj_z[mo_idx * num_instances + instance_id] > d_mobj_floorz[mo_idx * num_instances + instance_id])
	return;		// no friction when airborne

    if (d_mobj_flags[mo_idx * num_instances + instance_id] & MF_CORPSE)
    {
	// do not stop sliding
	//  if halfway off a step with some momentum
	if (d_mobj_momx[mo_idx * num_instances + instance_id] > FRACUNIT/4
	    || d_mobj_momx[mo_idx * num_instances + instance_id] < -FRACUNIT/4
	    || d_mobj_momy[mo_idx * num_instances + instance_id] > FRACUNIT/4
	    || d_mobj_momy[mo_idx * num_instances + instance_id] < -FRACUNIT/4)
	{
	    if (d_mobj_floorz[mo_idx * num_instances + instance_id] != d_sector_floorheight[d_subsector_sector[d_mobj_subsector[mo_idx * num_instances + instance_id]]])
		return;
	}
    }

    if (d_mobj_momx[mo_idx * num_instances + instance_id] > -STOPSPEED
	&& d_mobj_momx[mo_idx * num_instances + instance_id] < STOPSPEED
	&& d_mobj_momy[mo_idx * num_instances + instance_id] > -STOPSPEED
	&& d_mobj_momy[mo_idx * num_instances + instance_id] < STOPSPEED
	&& (!player
	    || (d_player_cmd[instance_id].forwardmove== 0
		&& d_player_cmd[instance_id].sidemove == 0 ) ) )
    {
	// if in a walking frame, stop moving
	if ( player&&(unsigned)((/* TODO: player->d_mobj_state */ 0[mo_idx * num_instances + instance_id] - states)- S_PLAY_RUN1) < 4)
	    P_SetMobjState_GPU (d_player_mo[instance_id], S_PLAY);

	d_mobj_momx[mo_idx * num_instances + instance_id] = 0;
	d_mobj_momy[mo_idx * num_instances + instance_id] = 0;
    }
    else
    {
	d_mobj_momx[mo_idx * num_instances + instance_id] = FixedMul (d_mobj_momx[mo_idx * num_instances + instance_id], FRICTION);
	d_mobj_momy[mo_idx * num_instances + instance_id] = FixedMul (d_mobj_momy[mo_idx * num_instances + instance_id], FRICTION);
    }
}

//
// P_ZMovement
//
static inline void P_ZMovement_GPU(int mo_idx, int instance_id, int num_instances)
{
    fixed_t	dist;
    fixed_t	delta;

    // check for smooth step up
    if (d_mobj_player[mo_idx * num_instances + instance_id] && d_mobj_z[mo_idx * num_instances + instance_id] < d_mobj_floorz[mo_idx * num_instances + instance_id])
    {
	d_player_viewheight[d_mobj_player[mo_idx * num_instances + instance_id]] -= d_mobj_floorz[mo_idx * num_instances + instance_id]-d_mobj_z[mo_idx * num_instances + instance_id];

	d_player_deltaviewheight[d_mobj_player[mo_idx * num_instances + instance_id]]
	    = (VIEWHEIGHT - d_player_viewheight[d_mobj_player[mo_idx * num_instances + instance_id]])>>3;
    }

    // adjust height
    d_mobj_z[mo_idx * num_instances + instance_id] += d_mobj_momz[mo_idx * num_instances + instance_id];

    if ( d_mobj_flags[mo_idx * num_instances + instance_id] & MF_FLOAT
	 && d_mobj_target[mo_idx * num_instances + instance_id])
    {
	// float down towards target if too close
	if ( !(d_mobj_flags[mo_idx * num_instances + instance_id] & MF_SKULLFLY)
	     && !(d_mobj_flags[mo_idx * num_instances + instance_id] & MF_INFLOAT) )
	{
	    dist = P_AproxDistance (d_mobj_x[mo_idx * num_instances + instance_id] - d_mobj_x[d_mobj_target[mo_idx * num_instances + instance_id] * num_instances + instance_id],
				    d_mobj_y[mo_idx * num_instances + instance_id] - d_mobj_y[d_mobj_target[mo_idx * num_instances + instance_id] * num_instances + instance_id]);

	    delta =(d_mobj_z[d_mobj_target[mo_idx * num_instances + instance_id] * num_instances + instance_id] + (d_mobj_height[mo_idx * num_instances + instance_id]>>1)) - d_mobj_z[mo_idx * num_instances + instance_id];

	    if (delta<0 && dist < -(delta*3) )
		d_mobj_z[mo_idx * num_instances + instance_id] -= FLOATSPEED;
	    else if (delta>0 && dist < (delta*3) )
		d_mobj_z[mo_idx * num_instances + instance_id] += FLOATSPEED;
	}

    }

    // clip movement
    if (d_mobj_z[mo_idx * num_instances + instance_id] <= d_mobj_floorz[mo_idx * num_instances + instance_id])
    {
	// hit the floor

	// Note (id):
	//  somebody left this after the setting momz to 0,
	//  kinda useless there.
	if (d_mobj_flags[mo_idx * num_instances + instance_id] & MF_SKULLFLY)
	{
	    // the skull slammed into something
	    d_mobj_momz[mo_idx * num_instances + instance_id] = -d_mobj_momz[mo_idx * num_instances + instance_id];
	}

	if (d_mobj_momz[mo_idx * num_instances + instance_id] < 0)
	{
	    if (d_mobj_player[mo_idx * num_instances + instance_id]
		&& d_mobj_momz[mo_idx * num_instances + instance_id] < -GRAVITY*8)
	    {
		// Squat down.
		// Decrease viewheight for a moment
		// after hitting the ground (hard),
		// and utter appropriate sound.
		d_player_deltaviewheight[d_mobj_player[mo_idx * num_instances + instance_id]] = d_mobj_momz[mo_idx * num_instances + instance_id]>>3;
    // SKIP-GPU: S_StartSound (mo, sfx_oof);
	    }
	    d_mobj_momz[mo_idx * num_instances + instance_id] = 0;
	}
	d_mobj_z[mo_idx * num_instances + instance_id] = d_mobj_floorz[mo_idx * num_instances + instance_id];

	if ( (d_mobj_flags[mo_idx * num_instances + instance_id] & MF_MISSILE)
	     && !(d_mobj_flags[mo_idx * num_instances + instance_id] & MF_NOCLIP) )
	{
	    P_ExplodeMissile (mo_idx, instance_id, num_instances);
	    return;
	}
    }
    else if (! (d_mobj_flags[mo_idx * num_instances + instance_id] & MF_NOGRAVITY) )
    {
	if (d_mobj_momz[mo_idx * num_instances + instance_id] == 0)
	    d_mobj_momz[mo_idx * num_instances + instance_id] = -GRAVITY*2;
	else
	    d_mobj_momz[mo_idx * num_instances + instance_id] -= GRAVITY;
    }

    if (d_mobj_z[mo_idx * num_instances + instance_id] + d_mobj_height[mo_idx * num_instances + instance_id] > d_mobj_ceilingz[mo_idx * num_instances + instance_id])
    {
	// hit the ceiling
	if (d_mobj_momz[mo_idx * num_instances + instance_id] > 0)
	    d_mobj_momz[mo_idx * num_instances + instance_id] = 0;
	{
	    d_mobj_z[mo_idx * num_instances + instance_id] = d_mobj_ceilingz[mo_idx * num_instances + instance_id] - d_mobj_height[mo_idx * num_instances + instance_id];
	}

	if (d_mobj_flags[mo_idx * num_instances + instance_id] & MF_SKULLFLY)
	{	// the skull slammed into something
	    d_mobj_momz[mo_idx * num_instances + instance_id] = -d_mobj_momz[mo_idx * num_instances + instance_id];
	}

	if ( (d_mobj_flags[mo_idx * num_instances + instance_id] & MF_MISSILE)
	     && !(d_mobj_flags[mo_idx * num_instances + instance_id] & MF_NOCLIP) )
	{
	    P_ExplodeMissile (mo_idx, instance_id, num_instances);
	    return;
	}
    }
}



//
// P_NightmareRespawn
//
void
P_NightmareRespawn (mobj_t* mobj)
{
    fixed_t		x;
    fixed_t		y;
    fixed_t		z;
    subsector_t*	ss;
    mobj_t*		mo;
    mapthing_t*		mthing;

    x = mobj->spawnpoint.x << FRACBITS;
    y = mobj->spawnpoint.y << FRACBITS;

    // somthing is occupying it's position?
    if (!P_CheckPosition (mobj, x, y) )
	return;	// no respwan

    // spawn a teleport fog at old spot
    // because of removal of the body?
    mo = P_SpawnMobj_GPU (mobj->x,
		      mobj->y,
		      mobj->subsector->sector->floorheight , MT_TFOG);
    // initiate teleport sound
    // SKIP-GPU: S_StartSound (mo, sfx_telept);

    // spawn a teleport fog at the new spot
    ss = R_PointInSubsector (x,y);

    mo = P_SpawnMobj_GPU (x, y, ss->sector->floorheight , MT_TFOG);

    // SKIP-GPU: S_StartSound (mo, sfx_telept);

    // spawn the new monster
    mthing = &mobj->spawnpoint;

    // spawn it
    if (mobj->info->flags & MF_SPAWNCEILING)
	z = ONCEILINGZ;
    else
	z = ONFLOORZ;

    // inherit attributes from deceased one
    mo = P_SpawnMobj_GPU (x,y,z, mobj->type);
    /* SPAWNPOINT:mo_idx */ = mobj->spawnpoint;
    d_mobj_angle[mo_idx * num_instances + instance_id] = ANG45 * (mthing->angle/45);

    if (mthing->options & MTF_AMBUSH)
	d_mobj_flags[mo_idx * num_instances + instance_id] |= MF_AMBUSH;

    d_mobj_reactiontime[mo_idx * num_instances + instance_id] = 18;

    // remove the old monster,
    P_RemoveMobj (mobj);
}


//
// P_MobjThinker
//
static inline void P_MobjThinker_GPU(int mobj_idx, int instance_id, int num_instances)
{
    // momentum movement
    if (d_mobj_momx[mobj_idx * num_instances + instance_id]
	|| d_mobj_momy[mobj_idx * num_instances + instance_id]
	|| (d_mobj_flags[mobj_idx * num_instances + instance_id]&MF_SKULLFLY) )
    {
	P_XYMovement (mobj_idx, instance_id, num_instances);

	// FIXME: decent NOP/NULL/Nil function pointer please.
	if (/* GPU_THINKER */.acv == (actionf_v) (-1))
	    return;		// mobj was removed
    }
    if ( (d_mobj_z[mobj_idx * num_instances + instance_id] != d_mobj_floorz[mobj_idx * num_instances + instance_id])
	 || d_mobj_momz[mobj_idx * num_instances + instance_id] )
    {
	P_ZMovement (mobj_idx, instance_id, num_instances);

	// FIXME: decent NOP/NULL/Nil function pointer please.
	if (/* GPU_THINKER */.acv == (actionf_v) (-1))
	    return;		// mobj was removed
    }


    // cycle through states,
    // calling action functions at transitions
    if (d_mobj_tics[mobj_idx * num_instances + instance_id] != -1)
    {
	d_mobj_tics[mobj_idx * num_instances + instance_id]--;

	// you can cycle through multiple states in a tic
	if (!d_mobj_tics[mobj_idx * num_instances + instance_id])
	    if (!P_SetMobjState_GPU (mobj_idx,  d_mobj_state[mobj_idx * num_instances + instance_id]->nextstate) )
		return;		// freed itself
    }
    else
    {
	// check for nightmare respawn
	if (! (d_mobj_flags[mobj_idx * num_instances + instance_id] & MF_COUNTKILL) )
	    return;

	if (!respawnmonsters)
	    return;

	d_mobj_movecount[mobj_idx * num_instances + instance_id]++;

	if (d_mobj_movecount[mobj_idx * num_instances + instance_id] < 12*35)
	    return;

	if ( leveltime&31 )
	    return;

	if (gpu_random () > 4)
	    return;

	P_NightmareRespawn (mobj_idx, instance_id, num_instances);
    }

}


//
// P_SpawnMobj
//
mobj_t* P_SpawnMobj ( fixed_t x, fixed_t y, fixed_t z, mobjtype_t type )
{
    mobj_t*	mobj;
    state_t*	st;
    mobjinfo_t*	info;

    mobj = Z_Malloc (sizeof(*mobj), PU_LEVEL, NULL);
    memset (mobj_idx,  0, sizeof (*mobj));
    info = &mobjinfo[type];

    d_mobj_type[mobj_idx * num_instances + instance_id] = type;
    c_mobjinfo[d_mobj_type[mobj_idx * num_instances + instance_id]] = info;
    d_mobj_x[mobj_idx * num_instances + instance_id] = x;
    d_mobj_y[mobj_idx * num_instances + instance_id] = y;
    d_mobj_radius[mobj_idx * num_instances + instance_id] = info->radius;
    d_mobj_height[mobj_idx * num_instances + instance_id] = info->height;
    d_mobj_flags[mobj_idx * num_instances + instance_id] = info->flags;
    d_mobj_health[mobj_idx * num_instances + instance_id] = info->spawnhealth;

    if (gameskill != sk_nightmare)
	d_mobj_reactiontime[mobj_idx * num_instances + instance_id] = info->reactiontime;

    d_mobj_lastlook[mobj_idx * num_instances + instance_id] = gpu_random () % MAXPLAYERS;
    // do not set the state with P_SetMobjState,
    // because action routines can not be called yet
    st = &states[info->spawnstate];

    d_mobj_state[mobj_idx * num_instances + instance_id] = st;
    d_mobj_tics[mobj_idx * num_instances + instance_id] = st->tics;
    d_mobj_sprite[mobj_idx * num_instances + instance_id] = st->sprite;
    d_mobj_frame[mobj_idx * num_instances + instance_id] = st->frame;

    // set subsector and/or block links
    P_SetThingPosition (mobj_idx, instance_id, num_instances);

    d_mobj_floorz[mobj_idx * num_instances + instance_id] = d_sector_floorheight[d_subsector_sector[d_mobj_subsector[mobj_idx * num_instances + instance_id]]];
    d_mobj_ceilingz[mobj_idx * num_instances + instance_id] = d_sector_ceilingheight[d_subsector_sector[d_mobj_subsector[mobj_idx * num_instances + instance_id]]];

    if (z == ONFLOORZ)
	d_mobj_z[mobj_idx * num_instances + instance_id] = d_mobj_floorz[mobj_idx * num_instances + instance_id];
    else if (z == ONCEILINGZ)
	d_mobj_z[mobj_idx * num_instances + instance_id] = d_mobj_ceilingz[mobj_idx * num_instances + instance_id] - c_mobjinfo[d_mobj_type[mobj_idx * num_instances + instance_id]].height;
    else
	d_mobj_z[mobj_idx * num_instances + instance_id] = z;

    /* GPU_THINKER */.acp1 = (actionf_p1)P_MobjThinker;

    P_AddThinker (&/* GPU_THINKER */);

    return mobj;
}


//
// P_RemoveMobj
//
mapthing_t	itemrespawnque[ITEMQUESIZE];
int		itemrespawntime[ITEMQUESIZE];
int		iquehead;
int		iquetail;


static inline void P_RemoveMobj_GPU(int mobj_idx, int instance_id, int num_instances)
{
    if ((d_mobj_flags[mobj_idx * num_instances + instance_id] & MF_SPECIAL)
	&& !(d_mobj_flags[mobj_idx * num_instances + instance_id] & MF_DROPPED)
	&& (d_mobj_type[mobj_idx * num_instances + instance_id] != MT_INV)
	&& (d_mobj_type[mobj_idx * num_instances + instance_id] != MT_INS))
    {
	itemrespawnque[iquehead] = /* SPAWNPOINT:mobj_idx */;
	itemrespawntime[iquehead] = leveltime;
	iquehead = (iquehead+1)&(ITEMQUESIZE-1);

	// lose one off the end?
	if (iquehead == iquetail)
	    iquetail = (iquetail+1)&(ITEMQUESIZE-1);
    }

    // unlink from sector and block lists
    P_UnsetThingPosition (mobj_idx, instance_id, num_instances);

    // stop any playing sound
    // SKIP-GPU: S_StopSound (mobj);

    // free block
    P_RemoveThinker ((thinker_t*)mobj);
}




//
// P_RespawnSpecials
//
void P_RespawnSpecials (void)
{
    fixed_t		x;
    fixed_t		y;
    fixed_t		z;

    subsector_t*	ss;
    mobj_t*		mo;
    mapthing_t*		mthing;

    int			i;

    // only respawn items in deathmatch
    if (deathmatch != 2)
	return;	//

    // nothing left to respawn?
    if (iquehead == iquetail)
	return;

    // wait at least 30 seconds
    if (leveltime - itemrespawntime[iquetail] < 30*35)
	return;

    mthing = &itemrespawnque[iquetail];

    x = mthing->x << FRACBITS;
    y = mthing->y << FRACBITS;

    // spawn a teleport fog at the new spot
    ss = R_PointInSubsector (x,y);
    mo = P_SpawnMobj_GPU (x, y, ss->sector->floorheight , MT_IFOG);
    // SKIP-GPU: S_StartSound (mo, sfx_itmbk);

    // find which type to spawn
    for (i=0 ; i< NUMMOBJTYPES ; i++)
    {
	if (mthing->type == mobjinfo[i].doomednum)
	    break;
    }

    // spawn it
    if (mobjinfo[i].flags & MF_SPAWNCEILING)
	z = ONCEILINGZ;
    else
	z = ONFLOORZ;

    mo = P_SpawnMobj_GPU (x,y,z, i);
    mo->spawnpoint = *mthing;
    mo->angle = ANG45 * (mthing->angle/45);

    // pull it from the que
    iquetail = (iquetail+1)&(ITEMQUESIZE-1);
}




//
// P_SpawnPlayer
// Called when a player is spawned on the level.
// Most of the player structure stays unchanged
//  between levels.
//
void P_SpawnPlayer (mapthing_t* mthing)
{
    player_t*		p;
    fixed_t		x;
    fixed_t		y;
    fixed_t		z;

    mobj_t*		mobj;

    int			i;

    // not playing?
    if (!playeringame[mthing->type-1])
	return;

    p = &players[mthing->type-1];

    if (p->playerstate == PST_REBORN)
	G_PlayerReborn (mthing->type-1);

    x 		= mthing->x << FRACBITS;
    y 		= mthing->y << FRACBITS;
    z		= ONFLOORZ;
    mobj	= P_SpawnMobj_GPU (x,y,z, MT_PLAYER);

    // set color translations for player sprites
    if (mthing->type > 1)
	d_mobj_flags[mobj_idx * num_instances + instance_id] |= (mthing->type-1)<<MF_TRANSSHIFT;

    d_mobj_angle[mobj_idx * num_instances + instance_id]	= ANG45 * (mthing->angle/45);
    d_mobj_player[mobj_idx * num_instances + instance_id] = p;
    d_mobj_health[mobj_idx * num_instances + instance_id] = p->health;

    p->mo = mobj_idx;
    p->playerstate = PST_LIVE;
    p->refire = 0;
    p->message = NULL;
    p->damagecount = 0;
    p->bonuscount = 0;
    p->extralight = 0;
    p->fixedcolormap = 0;
    p->viewheight = VIEWHEIGHT;

    // setup gun psprite
    P_SetupPsprites (p);

    // give all cards in death match mode
    if (deathmatch)
	for (i=0 ; i<NUMCARDS ; i++)
	    p->cards[i] = true;

    if (mthing->type-1 == consoleplayer)
    {
	// wake up the status bar
	ST_Start ();
	// wake up the heads up text
	HU_Start ();
    }
}


//
// P_SpawnMapThing
// The fields of the mapthing should
// already be in host byte order.
//
void P_SpawnMapThing (mapthing_t* mthing)
{
    int			i;
    int			bit;
    mobj_t*		mobj;
    fixed_t		x;
    fixed_t		y;
    fixed_t		z;

    // count deathmatch start positions
    if (mthing->type == 11)
    {
	if (deathmatch_p < &deathmatchstarts[10])
	{
	    memcpy (deathmatch_p, mthing, sizeof(*mthing));
	    deathmatch_p++;
	}
	return;
    }

    // check for players specially
    if (mthing->type <= 4)
    {
	// save spots for respawning in network games
	playerstarts[mthing->type-1] = *mthing;
	if (!deathmatch)
	    P_SpawnPlayer (mthing);

	return;
    }

    // check for apropriate skill level
    if (!netgame && (mthing->options & 16) )
	return;

    if (gameskill == sk_baby)
	bit = 1;
    else if (gameskill == sk_nightmare)
	bit = 4;
    else
	bit = 1<<(gameskill-1);

    if (!(mthing->options & bit) )
	return;

    // find which type to spawn
    for (i=0 ; i< NUMMOBJTYPES ; i++)
	if (mthing->type == mobjinfo[i].doomednum)
	    break;

    if (i==NUMMOBJTYPES)
    // SKIP-GPU: I_Error ("P_SpawnMapThing: Unknown type %i at (%i, %i)",
		 mthing->type,
		 mthing->x, mthing->y);

    // don't spawn keycards and players in deathmatch
    if (deathmatch && mobjinfo[i].flags & MF_NOTDMATCH)
	return;

    // don't spawn any monsters if -nomonsters
    if (nomonsters
	&& ( i == MT_SKULL
	     || (mobjinfo[i].flags & MF_COUNTKILL)) )
    {
	return;
    }

    // spawn it
    x = mthing->x << FRACBITS;
    y = mthing->y << FRACBITS;

    if (mobjinfo[i].flags & MF_SPAWNCEILING)
	z = ONCEILINGZ;
    else
	z = ONFLOORZ;

    mobj = P_SpawnMobj_GPU (x,y,z, i);
    /* SPAWNPOINT:mobj_idx */ = *mthing;

    if (d_mobj_tics[mobj_idx * num_instances + instance_id] > 0)
	d_mobj_tics[mobj_idx * num_instances + instance_id] = 1 + (gpu_random () % d_mobj_tics[mobj_idx * num_instances + instance_id]);
    if (d_mobj_flags[mobj_idx * num_instances + instance_id] & MF_COUNTKILL)
	totalkills++;
    if (d_mobj_flags[mobj_idx * num_instances + instance_id] & MF_COUNTITEM)
	totalitems++;

    d_mobj_angle[mobj_idx * num_instances + instance_id] = ANG45 * (mthing->angle/45);
    if (mthing->options & MTF_AMBUSH)
	d_mobj_flags[mobj_idx * num_instances + instance_id] |= MF_AMBUSH;
}



//
// GAME SPAWN FUNCTIONS
//


//
// P_SpawnPuff
//
extern fixed_t attackrange;

void
P_SpawnPuff
( fixed_t	x,
  fixed_t	y,
  fixed_t	z )
{
    mobj_t*	th;

    z += ((gpu_random()-gpu_random())<<10);

    th = P_SpawnMobj_GPU (x,y,z, MT_PUFF);
    th->momz = FRACUNIT;
    th->tics -= gpu_random()&3;

    if (th->tics < 1)
	th->tics = 1;

    // don't make punches spark on the wall
    if (attackrange == MELEERANGE)
	P_SetMobjState_GPU (th, S_PUFF3);
}



//
// P_SpawnBlood
//
void
P_SpawnBlood
( fixed_t	x,
  fixed_t	y,
  fixed_t	z,
  int		damage )
{
    mobj_t*	th;

    z += ((gpu_random()-gpu_random())<<10);
    th = P_SpawnMobj_GPU (x,y,z, MT_BLOOD);
    th->momz = FRACUNIT*2;
    th->tics -= gpu_random()&3;

    if (th->tics < 1)
	th->tics = 1;

    if (damage <= 12 && damage >= 9)
	P_SetMobjState_GPU (th,S_BLOOD2);
    else if (damage < 9)
	P_SetMobjState_GPU (th,S_BLOOD3);
}



//
// P_CheckMissileSpawn
// Moves the missile forward a bit
//  and possibly explodes it right there.
//
static inline void P_CheckMissileSpawn_GPU(int th_idx, int instance_id, int num_instances)
{
    d_mobj_tics[th_idx * num_instances + instance_id] -= gpu_random()&3;
    if (d_mobj_tics[th_idx * num_instances + instance_id] < 1)
	d_mobj_tics[th_idx * num_instances + instance_id] = 1;

    // move a little forward so an angle can
    // be computed if it immediately explodes
    d_mobj_x[th_idx * num_instances + instance_id] += (d_mobj_momx[th_idx * num_instances + instance_id]>>1);
    d_mobj_y[th_idx * num_instances + instance_id] += (d_mobj_momy[th_idx * num_instances + instance_id]>>1);
    d_mobj_z[th_idx * num_instances + instance_id] += (d_mobj_momz[th_idx * num_instances + instance_id]>>1);

    if (!P_TryMove (th_idx,  d_mobj_x[th_idx * num_instances + instance_id], d_mobj_y[th_idx * num_instances + instance_id]))
	P_ExplodeMissile (th_idx, instance_id, num_instances);
}


//
// P_SpawnMissile
//
mobj_t* P_SpawnMissile ( mobj_t* source, mobj_t* dest, mobjtype_t type )
{
    mobj_t*	th;
    angle_t	an;
    int		dist;

    th = P_SpawnMobj_GPU (source->x,
		      source->y,
		      source->z + 4*8*FRACUNIT, type);

    if (c_mobjinfo[d_mobj_type[th_idx * num_instances + instance_id]].seesound)
    // SKIP-GPU: S_StartSound (th, c_mobjinfo[d_mobj_type[th_idx * num_instances + instance_id]].seesound);

    d_mobj_target[th_idx * num_instances + instance_id] = source;	// where it came from
    an = R_PointToAngle2 (source->x, source->y, dest->x, dest->y);

    // fuzzy player
    if (dest->flags & MF_SHADOW)
	an += (gpu_random()-gpu_random())<<20;

    d_mobj_angle[th_idx * num_instances + instance_id] = an;
    an >>= ANGLETOFINESHIFT;
    d_mobj_momx[th_idx * num_instances + instance_id] = FixedMul (c_mobjinfo[d_mobj_type[th_idx * num_instances + instance_id]].speed, finecosine[an]);
    d_mobj_momy[th_idx * num_instances + instance_id] = FixedMul (c_mobjinfo[d_mobj_type[th_idx * num_instances + instance_id]].speed, finesine[an]);

    dist = P_AproxDistance (dest->x - source->x, dest->y - source->y);
    dist = dist / c_mobjinfo[d_mobj_type[th_idx * num_instances + instance_id]].speed;

    if (dist < 1)
	dist = 1;

    d_mobj_momz[th_idx * num_instances + instance_id] = (dest->z - source->z) / dist;
    P_CheckMissileSpawn (th_idx, instance_id, num_instances);

    return th;
}


//
// P_SpawnPlayerMissile
// Tries to aim at a nearby monster
//
static inline void P_SpawnPlayerMissile_GPU(int source_idx, mobjtype_t type, int instance_id, int num_instances)
{
    mobj_t*	th;
    angle_t	an;

    fixed_t	x;
    fixed_t	y;
    fixed_t	z;
    fixed_t	slope;

    // see which target is to be aimed at
    an = d_mobj_angle[source_idx * num_instances + instance_id];
    slope = P_AimLineAttack (source_idx,  an, 16*64*FRACUNIT);

    if (!linetarget)
    {
	an += 1<<26;
	slope = P_AimLineAttack (source_idx,  an, 16*64*FRACUNIT);

	if (!linetarget)
	{
	    an -= 2<<26;
	    slope = P_AimLineAttack (source_idx,  an, 16*64*FRACUNIT);
	}

	if (!linetarget)
	{
	    an = d_mobj_angle[source_idx * num_instances + instance_id];
	    slope = 0;
	}
    }

    x = d_mobj_x[source_idx * num_instances + instance_id];
    y = d_mobj_y[source_idx * num_instances + instance_id];
    z = d_mobj_z[source_idx * num_instances + instance_id] + 4*8*FRACUNIT;

    th = P_SpawnMobj_GPU (x,y,z, type);

    if (th->info->seesound)
    // SKIP-GPU: S_StartSound (th, th->info->seesound);

    th->target = source_idx;
    th->angle = an;
    th->momx = FixedMul( th->info->speed,
			 finecosine[an>>ANGLETOFINESHIFT]);
    th->momy = FixedMul( th->info->speed,
			 finesine[an>>ANGLETOFINESHIFT]);
    th->momz = FixedMul( th->info->speed, slope);

    P_CheckMissileSpawn (th);
}

