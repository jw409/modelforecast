// GPU-transformed from p_inter.c
// Generated by doom_cuda_transformer.py (backend: c)
// Original: id Software DOOM (1993)

#include "doom_types.h"
#include <stdint.h>

// Emacs style mode select   -*- C++ -*-
//-----------------------------------------------------------------------------
//
// $Id:$
//
// Copyright (C) 1993-1996 by id Software, Inc.
//
// This source is available for distribution and/or modification
// only under the terms of the DOOM Source Code License as
// published by id Software. All rights reserved.
//
// The source is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License
// for more details.
//
// $Log:$
//
// DESCRIPTION:
//	Handling interactions (i.e., collisions).
//
//-----------------------------------------------------------------------------


static const char
rcsid[] = "$Id: p_inter.c,v 1.4 1997/02/03 22:45:11 b1 Exp $";


// Data.
#include "doomdef.h"
#include "dstrings.h"
#include "sounds.h"

#include "doomstat.h"

#include "m_random.h"
#include "i_system.h"

#include "am_map.h"

#include "p_local.h"

#include "s_sound.h"

#ifdef __GNUG__
#pragma implementation "p_inter.h"
#endif
#include "p_inter.h"


#define BONUSADD	6




// a weapon is found with two clip loads,
// a big item has five clip loads
int	maxammo[NUMAMMO] = {200, 50, 300, 50};
int	clipammo[NUMAMMO] = {10, 4, 20, 1};


//
// GET STUFF
//

//
// P_GiveAmmo
// Num is the number of clip loads,
// not the individual count (0= 1/2 clip).
// Returns false if the ammo can't be picked up at all
//

boolean
P_GiveAmmo
( player_t*	player,
  ammotype_t	ammo,
  int		num )
{
    int		oldammo;

    if (ammo == am_noammo)
	return false;

    if (ammo < 0 || ammo > NUMAMMO)
    // SKIP-GPU: I_Error ("P_GiveAmmo: bad type %i", ammo);

    if ( d_player_ammo[instance_id][ammo] == d_player_maxammo[instance_id][ammo]  )
	return false;

    if (num)
	num *= clipammo[ammo];
    else
	num = clipammo[ammo]/2;

    if (gameskill == sk_baby
	|| gameskill == sk_nightmare)
    {
	// give double ammo in trainer mode,
	// you'll need in nightmare
	num <<= 1;
    }


    oldammo = d_player_ammo[instance_id][ammo];
    d_player_ammo[instance_id][ammo] += num;

    if (d_player_ammo[instance_id][ammo] > d_player_maxammo[instance_id][ammo])
	d_player_ammo[instance_id][ammo] = d_player_maxammo[instance_id][ammo];

    // If non zero ammo,
    // don't change up weapons,
    // player was lower on purpose.
    if (oldammo)
	return true;

    // We were down to zero,
    // so select a new weapon.
    // Preferences are not user selectable.
    switch (ammo)
    {
      case am_clip:
	if (d_player_readyweapon[instance_id] == wp_fist)
	{
	    if (d_player_weaponowned[instance_id][wp_chaingun])
		d_player_pendingweapon[instance_id] = wp_chaingun;
	    else
		d_player_pendingweapon[instance_id] = wp_pistol;
	}
	break;

      case am_shell:
	if (d_player_readyweapon[instance_id] == wp_fist
	    || d_player_readyweapon[instance_id] == wp_pistol)
	{
	    if (d_player_weaponowned[instance_id][wp_shotgun])
		d_player_pendingweapon[instance_id] = wp_shotgun;
	}
	break;

      case am_cell:
	if (d_player_readyweapon[instance_id] == wp_fist
	    || d_player_readyweapon[instance_id] == wp_pistol)
	{
	    if (d_player_weaponowned[instance_id][wp_plasma])
		d_player_pendingweapon[instance_id] = wp_plasma;
	}
	break;

      case am_misl:
	if (d_player_readyweapon[instance_id] == wp_fist)
	{
	    if (d_player_weaponowned[instance_id][wp_missile])
		d_player_pendingweapon[instance_id] = wp_missile;
	}
      default:
	break;
    }

    return true;
}


//
// P_GiveWeapon
// The weapon name may have a MF_DROPPED flag ored in.
//
boolean
P_GiveWeapon
( player_t*	player,
  weapontype_t	weapon,
  boolean	dropped )
{
    boolean	gaveammo;
    boolean	gaveweapon;

    if (netgame
	&& (deathmatch!=2)
	 && !dropped )
    {
	// leave placed weapons forever on net games
	if (d_player_weaponowned[instance_id][weapon])
	    return false;

	d_player_bonuscount[instance_id] += BONUSADD;
	d_player_weaponowned[instance_id][weapon] = true;

	if (deathmatch)
	    P_GiveAmmo (player, weaponinfo[weapon].ammo, 5);
	else
	    P_GiveAmmo (player, weaponinfo[weapon].ammo, 2);
	d_player_pendingweapon[instance_id] = weapon;

	if (player == &players[consoleplayer])
    // SKIP-GPU: S_StartSound (NULL, sfx_wpnup);
	return false;
    }

    if (weaponinfo[weapon].ammo != am_noammo)
    {
	// give one clip with a dropped weapon,
	// two clips with a found weapon
	if (dropped)
	    gaveammo = P_GiveAmmo (player, weaponinfo[weapon].ammo, 1);
	else
	    gaveammo = P_GiveAmmo (player, weaponinfo[weapon].ammo, 2);
    }
    else
	gaveammo = false;

    if (d_player_weaponowned[instance_id][weapon])
	gaveweapon = false;
    else
    {
	gaveweapon = true;
	d_player_weaponowned[instance_id][weapon] = true;
	d_player_pendingweapon[instance_id] = weapon;
    }

    return (gaveweapon || gaveammo);
}



//
// P_GiveBody
// Returns false if the body isn't needed at all
//
boolean
P_GiveBody
( player_t*	player,
  int		num )
{
    if (d_player_health[instance_id] >= MAXHEALTH)
	return false;

    d_player_health[instance_id] += num;
    if (d_player_health[instance_id] > MAXHEALTH)
	d_player_health[instance_id] = MAXHEALTH;
    d_mobj_health[d_player_mo[instance_id] * num_instances + instance_id] = d_player_health[instance_id];

    return true;
}



//
// P_GiveArmor
// Returns false if the armor is worse
// than the current armor.
//
boolean
P_GiveArmor
( player_t*	player,
  int		armortype )
{
    int		hits;

    hits = armortype*100;
    if (d_player_armorpoints[instance_id] >= hits)
	return false;	// don't pick up

    d_player_armortype[instance_id] = armortype;
    d_player_armorpoints[instance_id] = hits;

    return true;
}



//
// P_GiveCard
//
void
P_GiveCard
( player_t*	player,
  card_t	card )
{
    if (d_player_cards[instance_id][card])
	return;

    d_player_bonuscount[instance_id] = BONUSADD;
    d_player_cards[instance_id][card] = 1;
}


//
// P_GivePower
//
boolean
P_GivePower
( player_t*	player,
  int /*powertype_t*/	power )
{
    if (power == pw_invulnerability)
    {
	d_player_powers[instance_id][power] = INVULNTICS;
	return true;
    }

    if (power == pw_invisibility)
    {
	d_player_powers[instance_id][power] = INVISTICS;
	d_mobj_flags[d_player_mo[instance_id] * num_instances + instance_id] |= MF_SHADOW;
	return true;
    }

    if (power == pw_infrared)
    {
	d_player_powers[instance_id][power] = INFRATICS;
	return true;
    }

    if (power == pw_ironfeet)
    {
	d_player_powers[instance_id][power] = IRONTICS;
	return true;
    }

    if (power == pw_strength)
    {
	P_GiveBody (player, 100);
	d_player_powers[instance_id][power] = 1;
	return true;
    }

    if (d_player_powers[instance_id][power])
	return false;	// already got it

    d_player_powers[instance_id][power] = 1;
    return true;
}



//
// P_TouchSpecialThing
//
static inline void P_TouchSpecialThing_GPU(int special_idx, int toucher_idx, int instance_id, int num_instances)
{
    player_t*	player;
    int		i;
    fixed_t	delta;
    int		sound;

    delta = d_mobj_z[special_idx * num_instances + instance_id] - d_mobj_z[toucher_idx * num_instances + instance_id];

    if (delta > d_mobj_height[toucher_idx * num_instances + instance_id]
	|| delta < -8*FRACUNIT)
    {
	// out of reach
	return;
    }


    sound = sfx_itemup;
    player = d_mobj_player[toucher_idx * num_instances + instance_id];

    // Dead thing touching.
    // Can happen with a sliding player corpse.
    if (d_mobj_health[toucher_idx * num_instances + instance_id] <= 0)
	return;

    // Identify by sprite.
    switch (d_mobj_sprite[special_idx * num_instances + instance_id])
    {
	// armor
      case SPR_ARM1:
	if (!P_GiveArmor (player, 1))
	    return;
	d_player_message[instance_id] = GOTARMOR;
	break;

      case SPR_ARM2:
	if (!P_GiveArmor (player, 2))
	    return;
	d_player_message[instance_id] = GOTMEGA;
	break;

	// bonus items
      case SPR_BON1:
	d_player_health[instance_id]++;		// can go over 100%
	if (d_player_health[instance_id] > 200)
	    d_player_health[instance_id] = 200;
	d_mobj_health[d_player_mo[instance_id] * num_instances + instance_id] = d_player_health[instance_id];
	d_player_message[instance_id] = GOTHTHBONUS;
	break;

      case SPR_BON2:
	d_player_armorpoints[instance_id]++;		// can go over 100%
	if (d_player_armorpoints[instance_id] > 200)
	    d_player_armorpoints[instance_id] = 200;
	if (!d_player_armortype[instance_id])
	    d_player_armortype[instance_id] = 1;
	d_player_message[instance_id] = GOTARMBONUS;
	break;

      case SPR_SOUL:
	d_player_health[instance_id] += 100;
	if (d_player_health[instance_id] > 200)
	    d_player_health[instance_id] = 200;
	d_mobj_health[d_player_mo[instance_id] * num_instances + instance_id] = d_player_health[instance_id];
	d_player_message[instance_id] = GOTSUPER;
	sound = sfx_getpow;
	break;

      case SPR_MEGA:
	if (gamemode != commercial)
	    return;
	d_player_health[instance_id] = 200;
	d_mobj_health[d_player_mo[instance_id] * num_instances + instance_id] = d_player_health[instance_id];
	P_GiveArmor (player,2);
	d_player_message[instance_id] = GOTMSPHERE;
	sound = sfx_getpow;
	break;

	// cards
	// leave cards for everyone
      case SPR_BKEY:
	if (!d_player_cards[instance_id][it_bluecard])
	    d_player_message[instance_id] = GOTBLUECARD;
	P_GiveCard (player, it_bluecard);
	if (!netgame)
	    break;
	return;

      case SPR_YKEY:
	if (!d_player_cards[instance_id][it_yellowcard])
	    d_player_message[instance_id] = GOTYELWCARD;
	P_GiveCard (player, it_yellowcard);
	if (!netgame)
	    break;
	return;

      case SPR_RKEY:
	if (!d_player_cards[instance_id][it_redcard])
	    d_player_message[instance_id] = GOTREDCARD;
	P_GiveCard (player, it_redcard);
	if (!netgame)
	    break;
	return;

      case SPR_BSKU:
	if (!d_player_cards[instance_id][it_blueskull])
	    d_player_message[instance_id] = GOTBLUESKUL;
	P_GiveCard (player, it_blueskull);
	if (!netgame)
	    break;
	return;

      case SPR_YSKU:
	if (!d_player_cards[instance_id][it_yellowskull])
	    d_player_message[instance_id] = GOTYELWSKUL;
	P_GiveCard (player, it_yellowskull);
	if (!netgame)
	    break;
	return;

      case SPR_RSKU:
	if (!d_player_cards[instance_id][it_redskull])
	    d_player_message[instance_id] = GOTREDSKULL;
	P_GiveCard (player, it_redskull);
	if (!netgame)
	    break;
	return;

	// medikits, heals
      case SPR_STIM:
	if (!P_GiveBody (player, 10))
	    return;
	d_player_message[instance_id] = GOTSTIM;
	break;

      case SPR_MEDI:
	if (!P_GiveBody (player, 25))
	    return;

	if (d_player_health[instance_id] < 25)
	    d_player_message[instance_id] = GOTMEDINEED;
	else
	    d_player_message[instance_id] = GOTMEDIKIT;
	break;


	// power ups
      case SPR_PINV:
	if (!P_GivePower (player, pw_invulnerability))
	    return;
	d_player_message[instance_id] = GOTINVUL;
	sound = sfx_getpow;
	break;

      case SPR_PSTR:
	if (!P_GivePower (player, pw_strength))
	    return;
	d_player_message[instance_id] = GOTBERSERK;
	if (d_player_readyweapon[instance_id] != wp_fist)
	    d_player_pendingweapon[instance_id] = wp_fist;
	sound = sfx_getpow;
	break;

      case SPR_PINS:
	if (!P_GivePower (player, pw_invisibility))
	    return;
	d_player_message[instance_id] = GOTINVIS;
	sound = sfx_getpow;
	break;

      case SPR_SUIT:
	if (!P_GivePower (player, pw_ironfeet))
	    return;
	d_player_message[instance_id] = GOTSUIT;
	sound = sfx_getpow;
	break;

      case SPR_PMAP:
	if (!P_GivePower (player, pw_allmap))
	    return;
	d_player_message[instance_id] = GOTMAP;
	sound = sfx_getpow;
	break;

      case SPR_PVIS:
	if (!P_GivePower (player, pw_infrared))
	    return;
	d_player_message[instance_id] = GOTVISOR;
	sound = sfx_getpow;
	break;

	// ammo
      case SPR_CLIP:
	if (d_mobj_flags[special_idx * num_instances + instance_id] & MF_DROPPED)
	{
	    if (!P_GiveAmmo (player,am_clip,0))
		return;
	}
	else
	{
	    if (!P_GiveAmmo (player,am_clip,1))
		return;
	}
	d_player_message[instance_id] = GOTCLIP;
	break;

      case SPR_AMMO:
	if (!P_GiveAmmo (player, am_clip,5))
	    return;
	d_player_message[instance_id] = GOTCLIPBOX;
	break;

      case SPR_ROCK:
	if (!P_GiveAmmo (player, am_misl,1))
	    return;
	d_player_message[instance_id] = GOTROCKET;
	break;

      case SPR_BROK:
	if (!P_GiveAmmo (player, am_misl,5))
	    return;
	d_player_message[instance_id] = GOTROCKBOX;
	break;

      case SPR_CELL:
	if (!P_GiveAmmo (player, am_cell,1))
	    return;
	d_player_message[instance_id] = GOTCELL;
	break;

      case SPR_CELP:
	if (!P_GiveAmmo (player, am_cell,5))
	    return;
	d_player_message[instance_id] = GOTCELLBOX;
	break;

      case SPR_SHEL:
	if (!P_GiveAmmo (player, am_shell,1))
	    return;
	d_player_message[instance_id] = GOTSHELLS;
	break;

      case SPR_SBOX:
	if (!P_GiveAmmo (player, am_shell,5))
	    return;
	d_player_message[instance_id] = GOTSHELLBOX;
	break;

      case SPR_BPAK:
	if (!d_player_backpack[instance_id])
	{
	    for (i=0 ; i<NUMAMMO ; i++)
		d_player_maxammo[instance_id][i] *= 2;
	    d_player_backpack[instance_id] = true;
	}
	for (i=0 ; i<NUMAMMO ; i++)
	    P_GiveAmmo (player, i, 1);
	d_player_message[instance_id] = GOTBACKPACK;
	break;

	// weapons
      case SPR_BFUG:
	if (!P_GiveWeapon (player, wp_bfg, false) )
	    return;
	d_player_message[instance_id] = GOTBFG9000;
	sound = sfx_wpnup;
	break;

      case SPR_MGUN:
	if (!P_GiveWeapon (player, wp_chaingun, d_mobj_flags[special_idx * num_instances + instance_id]&MF_DROPPED) )
	    return;
	d_player_message[instance_id] = GOTCHAINGUN;
	sound = sfx_wpnup;
	break;

      case SPR_CSAW:
	if (!P_GiveWeapon (player, wp_chainsaw, false) )
	    return;
	d_player_message[instance_id] = GOTCHAINSAW;
	sound = sfx_wpnup;
	break;

      case SPR_LAUN:
	if (!P_GiveWeapon (player, wp_missile, false) )
	    return;
	d_player_message[instance_id] = GOTLAUNCHER;
	sound = sfx_wpnup;
	break;

      case SPR_PLAS:
	if (!P_GiveWeapon (player, wp_plasma, false) )
	    return;
	d_player_message[instance_id] = GOTPLASMA;
	sound = sfx_wpnup;
	break;

      case SPR_SHOT:
	if (!P_GiveWeapon (player, wp_shotgun, d_mobj_flags[special_idx * num_instances + instance_id]&MF_DROPPED ) )
	    return;
	d_player_message[instance_id] = GOTSHOTGUN;
	sound = sfx_wpnup;
	break;

      case SPR_SGN2:
	if (!P_GiveWeapon (player, wp_supershotgun, d_mobj_flags[special_idx * num_instances + instance_id]&MF_DROPPED ) )
	    return;
	d_player_message[instance_id] = GOTSHOTGUN2;
	sound = sfx_wpnup;
	break;

      default:
    // SKIP-GPU: I_Error ("P_SpecialThing: Unknown gettable thing");
    }

    if (d_mobj_flags[special_idx * num_instances + instance_id] & MF_COUNTITEM)
	d_player_itemcount[instance_id]++;
    P_RemoveMobj (special_idx, instance_id, num_instances);
    d_player_bonuscount[instance_id] += BONUSADD;
    if (player == &players[consoleplayer])
    // SKIP-GPU: S_StartSound (NULL, sound);
}


//
// KillMobj
//
static inline void P_KillMobj_GPU(int source_idx, int target_idx, int instance_id, int num_instances)
{
    mobjtype_t	item;
    mobj_t*	mo;

    d_mobj_flags[target_idx * num_instances + instance_id] &= ~(MF_SHOOTABLE|MF_FLOAT|MF_SKULLFLY);

    if (d_mobj_type[target_idx * num_instances + instance_id] != MT_SKULL)
	d_mobj_flags[target_idx * num_instances + instance_id] &= ~MF_NOGRAVITY;

    d_mobj_flags[target_idx * num_instances + instance_id] |= MF_CORPSE|MF_DROPOFF;
    d_mobj_height[target_idx * num_instances + instance_id] >>= 2;

    if (source && d_mobj_player[source_idx * num_instances + instance_id])
    {
	// count for intermission
	if (d_mobj_flags[target_idx * num_instances + instance_id] & MF_COUNTKILL)
	    d_player_killcount[d_mobj_player[source_idx * num_instances + instance_id]]++;

	if (d_mobj_player[target_idx * num_instances + instance_id])
	    d_player_frags[d_mobj_player[source_idx * num_instances + instance_id]][d_mobj_player[target_idx * num_instances + instance_id]-players]++;
    }
    else if (!netgame && (d_mobj_flags[target_idx * num_instances + instance_id] & MF_COUNTKILL) )
    {
	// count all monster deaths,
	// even those caused by other monsters
	d_player_killcount[instance_id]++;
    }

    if (d_mobj_player[target_idx * num_instances + instance_id])
    {
	// count environment kills against you
	if (!source)
	    d_player_frags[d_mobj_player[target_idx * num_instances + instance_id]][d_mobj_player[target_idx * num_instances + instance_id]-players]++;

	d_mobj_flags[target_idx * num_instances + instance_id] &= ~MF_SOLID;
	d_player_playerstate[d_mobj_player[target_idx * num_instances + instance_id]] = PST_DEAD;
	P_DropWeapon (d_mobj_player[target_idx * num_instances + instance_id]);

	if (d_mobj_player[target_idx * num_instances + instance_id] == &players[consoleplayer]
	    && automapactive)
	{
	    // don't die in auto map,
	    // switch view prior to dying
	    AM_Stop ();
	}

    }

    if (d_mobj_health[target_idx * num_instances + instance_id] < -c_mobjinfo[d_mobj_type[target_idx * num_instances + instance_id]].spawnhealth
	&& c_mobjinfo[d_mobj_type[target_idx * num_instances + instance_id]].xdeathstate)
    {
	P_SetMobjState_GPU (target_idx,  c_mobjinfo[d_mobj_type[target_idx * num_instances + instance_id]].xdeathstate);
    }
    else
	P_SetMobjState_GPU (target_idx,  c_mobjinfo[d_mobj_type[target_idx * num_instances + instance_id]].deathstate);
    d_mobj_tics[target_idx * num_instances + instance_id] -= gpu_random()&3;

    if (d_mobj_tics[target_idx * num_instances + instance_id] < 1)
	d_mobj_tics[target_idx * num_instances + instance_id] = 1;

    //	I_StartSound (&actor->r, actor->info->deathsound);


    // Drop stuff.
    // This determines the kind of object spawned
    // during the death frame of a thing.
    switch (d_mobj_type[target_idx * num_instances + instance_id])
    {
      case MT_WOLFSS:
      case MT_POSSESSED:
	item = MT_CLIP;
	break;

      case MT_SHOTGUY:
	item = MT_SHOTGUN;
	break;

      case MT_CHAINGUY:
	item = MT_CHAINGUN;
	break;

      default:
	return;
    }

    mo = P_SpawnMobj_GPU (d_mobj_x[target_idx * num_instances + instance_id],d_mobj_y[target_idx * num_instances + instance_id],ONFLOORZ, item);
    mo->flags |= MF_DROPPED;	// special versions of items
}




//
// P_DamageMobj
// Damages both enemies and players
// "inflictor" is the thing that caused the damage
//  creature or missile, can be NULL (slime, etc)
// "source" is the thing to target after taking damage
//  creature or NULL
// Source and inflictor are the same for melee attacks.
// Source can be NULL for slime, barrel explosions
// and other environmental stuff.
//
static inline void P_DamageMobj_GPU(int target_idx, int inflictor_idx, int source_idx, int damage, int instance_id, int num_instances)
{
    unsigned	ang;
    int		saved;
    player_t*	player;
    fixed_t	thrust;
    int		temp;

    if ( !(d_mobj_flags[target_idx * num_instances + instance_id] & MF_SHOOTABLE) )
	return;	// shouldn't happen...

    if (d_mobj_health[target_idx * num_instances + instance_id] <= 0)
	return;

    if ( d_mobj_flags[target_idx * num_instances + instance_id] & MF_SKULLFLY )
    {
	d_mobj_momx[target_idx * num_instances + instance_id] = d_mobj_momy[target_idx * num_instances + instance_id] = d_mobj_momz[target_idx * num_instances + instance_id] = 0;
    }

    player = d_mobj_player[target_idx * num_instances + instance_id];
    if (player && gameskill == sk_baby)
	damage >>= 1; 	// take half damage in trainer mode


    // Some close combat weapons should not
    // inflict thrust and push the victim out of reach,
    // thus kick away unless using the chainsaw.
    if (inflictor
	&& !(d_mobj_flags[target_idx * num_instances + instance_id] & MF_NOCLIP)
	&& (!source
	    || !d_mobj_player[source_idx * num_instances + instance_id]
	    || d_player_readyweapon[d_mobj_player[source_idx * num_instances + instance_id]] != wp_chainsaw))
    {
	ang = R_PointToAngle2 ( d_mobj_x[inflictor_idx * num_instances + instance_id],
				d_mobj_y[inflictor_idx * num_instances + instance_id],
				d_mobj_x[target_idx * num_instances + instance_id],
				d_mobj_y[target_idx * num_instances + instance_id]);

	thrust = damage*(FRACUNIT>>3)*100/c_mobjinfo[d_mobj_type[target_idx * num_instances + instance_id]].mass;

	// make fall forwards sometimes
	if ( damage < 40
	     && damage > d_mobj_health[target_idx * num_instances + instance_id]
	     && d_mobj_z[target_idx * num_instances + instance_id] - d_mobj_z[inflictor_idx * num_instances + instance_id] > 64*FRACUNIT
	     && (gpu_random ()&1) )
	{
	    ang += ANG180;
	    thrust *= 4;
	}

	ang >>= ANGLETOFINESHIFT;
	d_mobj_momx[target_idx * num_instances + instance_id] += FixedMul (thrust, finecosine[ang]);
	d_mobj_momy[target_idx * num_instances + instance_id] += FixedMul (thrust, finesine[ang]);
    }

    // player specific
    if (player)
    {
	// end of game hell hack
	if (d_sector_special[d_subsector_sector[d_mobj_subsector[target_idx * num_instances + instance_id]]] == 11
	    && damage >= d_mobj_health[target_idx * num_instances + instance_id])
	{
	    damage = d_mobj_health[target_idx * num_instances + instance_id] - 1;
	}


	// Below certain threshold,
	// ignore damage in GOD mode, or with INVUL power.
	if ( damage < 1000
	     && ( (d_player_cheats[instance_id]&CF_GODMODE)
		  || d_player_powers[instance_id][pw_invulnerability] ) )
	{
	    return;
	}

	if (d_player_armortype[instance_id])
	{
	    if (d_player_armortype[instance_id] == 1)
		saved = damage/3;
	    else
		saved = damage/2;

	    if (d_player_armorpoints[instance_id] <= saved)
	    {
		// armor is used up
		saved = d_player_armorpoints[instance_id];
		d_player_armortype[instance_id] = 0;
	    }
	    d_player_armorpoints[instance_id] -= saved;
	    damage -= saved;
	}
	d_player_health[instance_id] -= damage; 	// mirror mobj health here for Dave
	if (d_player_health[instance_id] < 0)
	    d_player_health[instance_id] = 0;

	d_player_attacker[instance_id] = source_idx;
	d_player_damagecount[instance_id] += damage;	// add damage after armor / invuln

	if (d_player_damagecount[instance_id] > 100)
	    d_player_damagecount[instance_id] = 100;	// teleport stomp does 10k points...

	temp = damage < 100 ? damage : 100;

	if (player == &players[consoleplayer])
	    I_Tactile (40,10,40+temp*2);
    }

    // do the damage
    d_mobj_health[target_idx * num_instances + instance_id] -= damage;
    if (d_mobj_health[target_idx * num_instances + instance_id] <= 0)
    {
	P_KillMobj (source_idx,  target_idx);
	return;
    }

    if ( (gpu_random () < c_mobjinfo[d_mobj_type[target_idx * num_instances + instance_id]].painchance)
	 && !(d_mobj_flags[target_idx * num_instances + instance_id]&MF_SKULLFLY) )
    {
	d_mobj_flags[target_idx * num_instances + instance_id] |= MF_JUSTHIT;	// fight back!

	P_SetMobjState_GPU (target_idx,  c_mobjinfo[d_mobj_type[target_idx * num_instances + instance_id]].painstate);
    }

    d_mobj_reactiontime[target_idx * num_instances + instance_id] = 0;		// we're awake now...

    if ( (!d_mobj_threshold[target_idx * num_instances + instance_id] || d_mobj_type[target_idx * num_instances + instance_id] == MT_VILE)
	 && source && source != target
	 && d_mobj_type[source_idx * num_instances + instance_id] != MT_VILE)
    {
	// if not intent on another player,
	// chase after this one
	d_mobj_target[target_idx * num_instances + instance_id] = source_idx;
	d_mobj_threshold[target_idx * num_instances + instance_id] = BASETHRESHOLD;
	if (d_mobj_state[target_idx * num_instances + instance_id] == &states[c_mobjinfo[d_mobj_type[target_idx * num_instances + instance_id]].spawnstate]
	    && c_mobjinfo[d_mobj_type[target_idx * num_instances + instance_id]].seestate != S_NULL)
	    P_SetMobjState_GPU (target_idx,  c_mobjinfo[d_mobj_type[target_idx * num_instances + instance_id]].seestate);
    }

}

