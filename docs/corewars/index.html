<!DOCTYPE html>
<html>
<head>
    <title>ModelForecast CoreWars Arena</title>
    <meta charset="UTF-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="tournament_loader.js"></script>
    <script src="arena_tournament_integration.js"></script>
    <script src="tournament_selector.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            background: #050508;
            color: #00fff7;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 8px 16px;
            background: rgba(5, 5, 8, 0.95);
            border-bottom: 1px solid #1a1a2e;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }
        #title { font-size: 16px; font-weight: bold; }
        #stats { display: flex; gap: 20px; }
        .stat { opacity: 0.8; }
        .stat-value { color: #fff; font-weight: bold; }
        #controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        button {
            background: #00fff7;
            color: #050508;
            border: none;
            padding: 4px 10px;
            cursor: pointer;
            font-family: monospace;
            font-size: 11px;
            font-weight: bold;
        }
        button:hover { background: #00cccc; }
        button.active { background: #ff6b00; color: #fff; }
        #leaderboard {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: rgba(5, 5, 8, 0.95);
            border-top: 1px solid #1a1a2e;
            z-index: 100;
            display: flex;
            justify-content: center;
            gap: 30px;
            padding: 10px 20px;
            overflow-x: auto;
        }
        .llm-pile {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 100px;
        }
        .pile-stack {
            width: 60px;
            height: 40px;
            position: relative;
        }
        .pile-card {
            position: absolute;
            width: 50px;
            height: 30px;
            border-radius: 3px;
            border: 1px solid rgba(255,255,255,0.3);
        }
        .pile-name {
            font-size: 10px;
            margin-top: 4px;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .rank-badge {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            font-size: 9px;
            font-weight: bold;
            padding: 2px 5px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid;
            min-width: 35px;
            justify-content: center;
        }
        .rank-badge.rank-1 {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 255, 255, 0.1));
            border-color: #ffd700;
            color: #ffd700;
        }
        .rank-badge.rank-2 {
            background: linear-gradient(135deg, rgba(192, 192, 192, 0.3), rgba(255, 255, 255, 0.1));
            border-color: #c0c0c0;
            color: #c0c0c0;
        }
        .rank-badge.rank-3 {
            background: linear-gradient(135deg, rgba(205, 127, 50, 0.3), rgba(255, 255, 255, 0.1));
            border-color: #cd7f32;
            color: #cd7f32;
        }
        .rank-badge.rank-4,
        .rank-badge.rank-5 {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.6);
        }
        .rank-badge-icon {
            font-size: 11px;
        }
        .codename-badge {
            font-size: 8px;
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
            margin-left: 2px;
        }
        .pile-wins {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }
        #canvas-container {
            width: 100vw;
            height: calc(100vh - 120px);
            margin-top: 40px;
        }
        #tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00fff7;
            padding: 8px 12px;
            font-size: 11px;
            pointer-events: none;
            display: none;
            z-index: 200;
        }
        #stats-overlay {
            position: fixed;
            top: 50px;
            right: 10px;
            background: rgba(5, 5, 8, 0.92);
            border: 1px solid #00fff7;
            border-radius: 4px;
            padding: 12px 16px;
            font-size: 11px;
            z-index: 99;
            min-width: 220px;
            box-shadow: 0 4px 12px rgba(0, 255, 247, 0.15);
        }
        #stats-overlay .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 4px 0;
            padding: 2px 0;
        }
        #stats-overlay .stat-label {
            color: #00fff7;
            opacity: 0.8;
        }
        #stats-overlay .stat-value {
            color: #fff;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        #stats-overlay .dominant-llm {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(0, 255, 247, 0.3);
            text-align: center;
        }
        #stats-overlay .dominant-llm-name {
            font-size: 13px;
            font-weight: bold;
            margin-top: 4px;
        }

        #detail-panel {
            position: fixed;
            right: 10px;
            top: 50px;
            width: 200px;
            background: rgba(5, 5, 8, 0.95);
            border: 1px solid #1a1a2e;
            padding: 10px;
            font-size: 11px;
            display: none;
            z-index: 100;
        }
        #detail-panel h3 { margin-bottom: 8px; font-size: 12px; }
        #detail-panel .row { display: flex; justify-content: space-between; margin: 4px 0; }
        .w0-color { color: #00fff7; }
        .w1-color { color: #ff6b00; }

        #shape-controls {
            position: fixed;
            top: 180px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 100;
        }

        #shape-controls button {
            background: rgba(0, 255, 247, 0.1);
            border: 1px solid #00fff7;
            color: #00fff7;
            padding: 6px 12px;
            font-family: monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        #shape-controls button:hover {
            background: rgba(0, 255, 247, 0.3);
        }

        #shape-controls button.active {
            background: #00fff7;
            color: #050508;
        }

        #camera-mode {
            position: fixed;
            top: 50px;
            left: 10px;
            font-size: 10px;
            color: #666;
            z-index: 100;
        }

        /* Tournament Selector */
        #tournament-selector-panel {
            position: fixed;
            top: 70px;
            left: 10px;
            background: rgba(5, 5, 8, 0.95);
            border: 1px solid #00fff7;
            border-radius: 4px;
            padding: 10px 12px;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            color: #00fff7;
            z-index: 99;
            min-width: 280px;
            box-shadow: 0 4px 12px rgba(0, 255, 247, 0.15);
        }

        #tournament-selector-panel .panel-title {
            font-weight: bold;
            color: #fff;
            margin-bottom: 8px;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #tournament-selector-panel select {
            width: 100%;
            background: rgba(0, 255, 247, 0.1);
            border: 1px solid #00fff7;
            color: #00fff7;
            padding: 6px 8px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            border-radius: 3px;
            cursor: pointer;
            margin-bottom: 8px;
        }

        #tournament-selector-panel select:hover {
            background: rgba(0, 255, 247, 0.2);
        }

        #tournament-selector-panel select:focus {
            outline: none;
            border-color: #fff;
            box-shadow: 0 0 8px rgba(0, 255, 247, 0.3);
        }

        #tournament-selector-panel .tournament-info {
            font-size: 9px;
            color: #888;
            line-height: 1.4;
        }

        #tournament-selector-panel .tournament-info .label {
            color: #666;
            display: inline-block;
            width: 70px;
        }

        #tournament-selector-panel .tournament-info .value {
            color: #00fff7;
        }

        /* Win Streak Display */
        .pile-streak {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            font-weight: bold;
            color: #ff6b00;
            text-shadow: 0 0 10px #ff6b00, 0 0 20px #ff6b00;
            animation: pulse 0.5s ease-in-out infinite alternate;
            white-space: nowrap;
        }
        @keyframes pulse {
            from { transform: translateX(-50%) scale(1); }
            to { transform: translateX(-50%) scale(1.1); }
        }

        /* Redcode Syntax Highlighting */
        .rc-opcode { color: #9d7cd8; font-weight: bold; }
        .rc-pseudo { color: #ff9e64; }
        .rc-modifier { color: #7dcfff; }
        .rc-address { color: #f7768e; }
        .rc-number { color: #9ece6a; }
        .rc-label { color: #c0caf5; }
        .rc-comment { color: #565f89; font-style: italic; }
        .rc-directive { color: #bb9af7; }

        #code-panel {
            position: fixed;
            left: 10px;
            top: 50px;
            width: calc(100vw - 40px);
            max-width: 1400px;
            max-height: calc(100vh - 80px);
            background: rgba(5, 5, 8, 0.97);
            border: 2px solid #1a1a2e;
            border-radius: 8px;
            padding: 0;
            font-size: 11px;
            overflow: hidden;
            z-index: 100;
            display: none;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
        }
        #code-panel.visible { display: flex; flex-direction: column; }
        #code-panel-header {
            background: rgba(10, 10, 20, 0.95);
            padding: 12px 16px;
            border-bottom: 2px solid #1a1a2e;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #code-panel-header h4 {
            margin: 0;
            font-size: 14px;
            color: #00fff7;
            font-weight: 600;
        }
        #code-panel-close {
            background: none;
            border: 1px solid #565f89;
            color: #c0caf5;
            padding: 4px 12px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 11px;
            transition: all 0.2s;
        }
        #code-panel-close:hover {
            background: rgba(255, 107, 0, 0.2);
            border-color: #ff6b00;
            color: #ff6b00;
        }
        #code-panel-content {
            display: flex;
            gap: 16px;
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }
        .code-warrior {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(10, 10, 20, 0.5);
            border-radius: 6px;
            overflow: hidden;
        }
        .code-warrior-header {
            padding: 10px 12px;
            border-bottom: 2px solid #1a1a2e;
            background: rgba(15, 15, 25, 0.8);
        }
        .code-warrior-header.w0 { border-color: #00fff7; background: rgba(0, 255, 255, 0.05); }
        .code-warrior-header.w1 { border-color: #ff6b00; background: rgba(255, 107, 0, 0.05); }
        .code-warrior-title {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 0;
        }
        .code-warrior-strategy {
            font-size: 10px;
            color: #9aa5ce;
            line-height: 1.4;
            margin-top: 6px;
            padding-top: 6px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        .code-warrior-strategy-label {
            color: #bb9af7;
            font-weight: 600;
            margin-bottom: 3px;
        }
        .code-warrior-type {
            display: inline-block;
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
            font-weight: 600;
            opacity: 0.9;
        }
        .type-bomber { background: rgba(255, 107, 0, 0.3); color: #ffaa66; }
        .type-scanner { background: rgba(155, 206, 106, 0.3); color: #9ece6a; }
        .type-replicator { background: rgba(187, 154, 247, 0.3); color: #bb9af7; }
        .type-imp { background: rgba(0, 255, 247, 0.3); color: #00fff7; }
        .type-hybrid { background: rgba(255, 255, 100, 0.3); color: #e0db74; }
        .code-warrior-body {
            padding: 12px;
            overflow-y: auto;
            flex: 1;
        }
        .code-warrior pre {
            margin: 0;
            white-space: pre-wrap;
            line-height: 1.6;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        /* Loading Overlay */
        #loading-overlay {
            position: fixed;
            inset: 0;
            background: #050508;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease-out;
        }
        #loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .spinner {
            width: 60px;
            height: 60px;
            border: 3px solid #1a1a2e;
            border-top-color: #00fff7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .loading-text {
            margin-top: 20px;
            color: #00fff7;
            font-size: 14px;
            opacity: 0.8;
        }

        /* ============== HERO INTRO - LOUD CINEMATIC ============== */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=JetBrains+Mono:wght@400;700&display=swap');

        #hero-intro {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 950;
            display: none;
            overflow: hidden;
        }
        #hero-intro.active { display: block; }
        #hero-intro.exiting {
            animation: heroExit 0.8s ease-in forwards;
        }

        /* Scanlines overlay */
        #hero-intro::before {
            content: '';
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 247, 0.03) 2px,
                rgba(0, 255, 247, 0.03) 4px
            );
            pointer-events: none;
            z-index: 10;
        }

        /* CRT flicker */
        #hero-intro::after {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(0, 255, 247, 0.02);
            animation: flicker 0.1s infinite;
            pointer-events: none;
            z-index: 11;
        }

        @keyframes flicker {
            0%, 100% { opacity: 0.02; }
            50% { opacity: 0.04; }
        }

        @keyframes heroExit {
            0% { transform: scale(1); opacity: 1; filter: blur(0); }
            100% { transform: scale(1.1); opacity: 0; filter: blur(20px); }
        }

        /* CHALLENGE banner - MASSIVE */
        .hero-challenge {
            position: absolute;
            top: 8vh;
            left: 0;
            right: 0;
            text-align: center;
            z-index: 5;
        }
        .hero-challenge-label {
            font-family: 'Orbitron', monospace;
            font-size: clamp(12px, 2vw, 18px);
            letter-spacing: 0.5em;
            color: #ff6b00;
            text-transform: uppercase;
            margin-bottom: 1vh;
            animation: pulse-glow 2s ease-in-out infinite;
        }
        .hero-challenge-text {
            font-family: 'Orbitron', monospace;
            font-size: clamp(24px, 5vw, 64px);
            font-weight: 900;
            color: #fff;
            text-shadow:
                0 0 20px #00fff7,
                0 0 40px #00fff7,
                0 0 80px rgba(0, 255, 247, 0.5);
            animation: text-glow 3s ease-in-out infinite alternate;
            padding: 0 5vw;
            line-height: 1.2;
        }

        @keyframes pulse-glow {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; text-shadow: 0 0 20px #ff6b00; }
        }
        @keyframes text-glow {
            from { text-shadow: 0 0 20px #00fff7, 0 0 40px #00fff7; }
            to { text-shadow: 0 0 40px #00fff7, 0 0 80px #00fff7, 0 0 120px rgba(0, 255, 247, 0.3); }
        }

        /* SIDE-BY-SIDE COMBATANTS GRID */
        .hero-combatants {
            position: absolute;
            top: 18vh;
            left: 3vw;
            right: 3vw;
            bottom: 8vh;
            display: grid;
            grid-template-columns: minmax(0, 1fr) 80px minmax(0, 1fr);  /* FORCED equal */
            gap: 1vw;
            z-index: 5;
        }

        .hero-warrior {
            display: flex;
            flex-direction: column;
            gap: 1.5vh;
            min-width: 0;
            max-width: 100%;
            overflow: hidden;
        }

        /* W0 (cyan) vs W1 (orange) color coding */
        .hero-w0 .hero-model-name { color: #00fff7; }
        .hero-w0 .hero-code { border-color: #00fff7; }
        .hero-w0 .hero-code-header { color: #00fff7; }
        .hero-w1 .hero-model-name { color: #ff6b00; }
        .hero-w1 .hero-code { border-color: #ff6b00; }
        .hero-w1 .hero-code-header { color: #ff6b00; }

        /* MODEL NAME - Sized for side-by-side */
        .hero-model-name {
            font-family: 'Orbitron', monospace;
            font-size: clamp(24px, 4vw, 56px);
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            animation: glitch 3s infinite;
            position: relative;
            text-align: center;
        }
        .hero-model-name::before,
        .hero-model-name::after {
            content: attr(data-text);
            position: absolute;
            left: 0;
            right: 0;
        }
        .hero-model-name::before {
            animation: glitch-1 0.3s infinite;
            color: #ff6b00;
            clip-path: polygon(0 0, 100% 0, 100% 35%, 0 35%);
        }
        .hero-model-name::after {
            animation: glitch-2 0.3s infinite;
            color: #00ff00;
            clip-path: polygon(0 65%, 100% 65%, 100% 100%, 0 100%);
        }

        @keyframes glitch {
            0%, 90%, 100% { transform: translate(0); }
            92% { transform: translate(-2px, 1px); }
            94% { transform: translate(2px, -1px); }
            96% { transform: translate(-1px, 2px); }
            98% { transform: translate(1px, -2px); }
        }
        @keyframes glitch-1 {
            0%, 90%, 100% { transform: translate(0); opacity: 0; }
            92% { transform: translate(4px, 0); opacity: 0.8; }
            94% { transform: translate(-4px, 0); opacity: 0; }
        }
        @keyframes glitch-2 {
            0%, 90%, 100% { transform: translate(0); opacity: 0; }
            93% { transform: translate(-3px, 0); opacity: 0.8; }
            95% { transform: translate(3px, 0); opacity: 0; }
        }

        /* THINKING TEXT - Compact for side-by-side */
        .hero-thinking-text {
            font-family: 'JetBrains Mono', monospace;
            font-size: clamp(10px, 1.2vw, 14px);
            color: rgba(255, 255, 255, 0.75);
            line-height: 1.5;
            max-height: 10vh;
            overflow: hidden;
            word-break: break-word;
            animation: fade-in-up 1s ease-out 0.5s both;
        }

        @keyframes fade-in-up {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* CODE SECTION - Terminal style */
        .hero-code {
            flex: 1;
            min-height: 0;
            background: rgba(0, 10, 15, 0.9);
            border: 2px solid;
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow:
                0 0 30px rgba(0, 255, 247, 0.2),
                inset 0 0 50px rgba(0, 255, 247, 0.05);
        }
        .hero-code-header {
            background: rgba(0, 255, 247, 0.1);
            padding: 6px 12px;
            border-bottom: 1px solid currentColor;
            font-family: 'Orbitron', monospace;
            font-size: clamp(9px, 1vw, 12px);
        }
        .hero-code-body {
            flex: 1;
            padding: 10px 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: clamp(9px, 1.1vw, 13px);
            color: #e0e0e0;
            line-height: 1.6;
            overflow-y: auto;
        }
        .hero-code-body .line {
            opacity: 0;
            animation: type-line 0.1s ease-out forwards;
        }
        .hero-code-body .line.rc-opcode { color: #ff79c6; font-weight: bold; }
        .hero-code-body .line.rc-comment { color: #6272a4; }
        .hero-code-body .line.rc-label { color: #50fa7b; }

        @keyframes type-line {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* VS BADGE - Grid center column */
        .hero-vs {
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 6;
        }
        .hero-vs-text {
            font-family: 'Orbitron', monospace;
            font-size: clamp(32px, 6vw, 80px);
            font-weight: 900;
            color: #fff;
            text-shadow:
                0 0 30px #ff6b00,
                0 0 60px #ff6b00;
            animation: vs-pulse 1s ease-in-out infinite alternate;
        }
        @keyframes vs-pulse {
            from { text-shadow: 0 0 50px #ff6b00, 0 0 100px #ff6b00; }
            to { text-shadow: 0 0 80px #ff6b00, 0 0 150px #ff6b00, 0 0 200px rgba(255, 107, 0, 0.3); }
        }

        /* Corner decorations */
        .hero-corner {
            position: absolute;
            width: 100px;
            height: 100px;
            border: 2px solid #00fff7;
            opacity: 0.5;
            z-index: 3;
        }
        .hero-corner.tl { top: 20px; left: 20px; border-right: none; border-bottom: none; }
        .hero-corner.tr { top: 20px; right: 20px; border-left: none; border-bottom: none; }
        .hero-corner.bl { bottom: 20px; left: 20px; border-right: none; border-top: none; }
        .hero-corner.br { bottom: 20px; right: 20px; border-left: none; border-top: none; }

        /* Skip hint */
        .hero-skip {
            position: absolute;
            bottom: 2vh;
            right: 3vw;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.4);
            z-index: 7;
            animation: fade-pulse 2s ease-in-out infinite;
        }
        @keyframes fade-pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.8; }
        }

        /* Replay Modal */
        #replay-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        #replay-modal.visible { display: flex; }
        #replay-container {
            position: relative;
            width: 90vw;
            max-width: 1200px;
            height: 80vh;
            background: #050508;
            border: 2px solid #00fff7;
            display: flex;
            flex-direction: column;
        }
        #replay-header {
            padding: 12px 16px;
            background: rgba(0, 255, 247, 0.1);
            border-bottom: 1px solid #00fff7;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #replay-title {
            font-size: 18px;
            font-weight: bold;
            color: #00fff7;
        }
        #replay-close {
            background: #ff6b00;
            color: #fff;
            border: none;
            padding: 6px 16px;
            cursor: pointer;
            font-family: monospace;
            font-size: 14px;
            font-weight: bold;
        }
        #replay-close:hover { background: #ff5500; }
        #replay-canvas-container {
            flex: 1;
            position: relative;
            background: #000;
        }
        #replay-controls {
            padding: 12px 16px;
            background: rgba(5, 5, 8, 0.98);
            border-top: 1px solid #1a1a2e;
            display: flex;
            gap: 12px;
            align-items: center;
        }
        #replay-controls button {
            background: #00fff7;
            color: #050508;
            border: none;
            padding: 6px 14px;
            cursor: pointer;
            font-family: monospace;
            font-size: 12px;
            font-weight: bold;
        }
        #replay-controls button:hover { background: #00cccc; }
        #replay-controls button.active { background: #ff6b00; color: #fff; }
        #replay-timeline {
            flex: 1;
            height: 30px;
            background: #1a1a2e;
            border-radius: 3px;
            position: relative;
            cursor: pointer;
        }
        #replay-progress {
            height: 100%;
            background: linear-gradient(90deg, #00fff7, #00cccc);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }
        #replay-stats {
            display: flex;
            gap: 16px;
            font-size: 11px;
        }
        #replay-stats .stat { opacity: 0.8; }
        #replay-stats .stat-value { color: #fff; font-weight: bold; }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div class="loading-text">Setting up arena...</div>
    </div>

    <!-- HERO INTRO - LOUD CINEMATIC (SIDE BY SIDE) -->
    <div id="hero-intro">
        <div class="hero-corner tl"></div>
        <div class="hero-corner tr"></div>
        <div class="hero-corner bl"></div>
        <div class="hero-corner br"></div>

        <div class="hero-challenge">
            <div class="hero-challenge-label">THE CHALLENGE</div>
            <div class="hero-challenge-text" id="hero-challenge-text">
                Write a CoreWars warrior to dominate the arena
            </div>
        </div>

        <!-- SIDE BY SIDE COMBATANTS -->
        <div class="hero-combatants">
            <!-- LEFT WARRIOR (w0) -->
            <div class="hero-warrior hero-w0">
                <div class="hero-model-name" id="hero-model-name-w0" data-text="CLAUDE">CLAUDE</div>
                <div class="hero-thinking-text" id="hero-thinking-w0"></div>
                <div class="hero-code">
                    <div class="hero-code-header">● REDCODE</div>
                    <div class="hero-code-body" id="hero-code-w0"></div>
                </div>
            </div>

            <!-- VS DIVIDER -->
            <div class="hero-vs">
                <div class="hero-vs-text">VS</div>
            </div>

            <!-- RIGHT WARRIOR (w1) -->
            <div class="hero-warrior hero-w1">
                <div class="hero-model-name" id="hero-model-name-w1" data-text="GPT">GPT</div>
                <div class="hero-thinking-text" id="hero-thinking-w1"></div>
                <div class="hero-code">
                    <div class="hero-code-header">● REDCODE</div>
                    <div class="hero-code-body" id="hero-code-w1"></div>
                </div>
            </div>
        </div>

        <div class="hero-skip">Press SPACE or click to skip →</div>
    </div>

    <div id="gpu-flash" style="position:fixed;inset:0;background:#00fff7;opacity:0;pointer-events:none;z-index:500;transition:opacity 0.1s;"></div>
    <div id="mode-indicator" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);font-size:48px;font-weight:bold;color:#00fff7;text-shadow:0 0 20px #00fff7;z-index:400;opacity:0;transition:opacity 0.3s;pointer-events:none;"></div>
    <div id="hud">
        <a id="title" href="https://github.com/jw409/modelforecast" target="_blank" style="color: inherit; text-decoration: none;">
            Arena of Awakening <span style="font-size: 10px; opacity: 0.6; font-weight: normal;">// LLM Battle Visualization</span>
        </a>
        <div id="stats">
            <span class="stat">Battles: <span class="stat-value" id="battle-count">0</span></span>
            <span class="stat">Complete: <span class="stat-value" id="complete-count">0</span></span>
            <span class="stat">Cycle: <span class="stat-value" id="global-cycle">0</span></span>
            <span class="stat">Zoom: <span class="stat-value" id="zoom-level">1.0x</span></span>
            <span class="stat">FPS: <span class="stat-value" id="fps-display">60</span></span>
        </div>
        <div id="controls">
            <button id="play">Play All</button>
            <button id="pause">Pause</button>
            <button id="reset">Reset</button>
            <button id="fit">Fit View</button>
            <button id="show-code">Show Code</button>
            <button id="auto-shapes">Auto Shapes</button>
            <button id="heatmap">Heatmap</button>
        </div>
    </div>

    <div id="shape-controls">
        <button id="shape-plane" class="active">Plane</button>
        <button id="shape-cube">Cube</button>
        <button id="shape-sphere">Sphere</button>
        <button id="shape-cylinder">Cylinder</button>
        <button id="shape-heart">Heart</button>
        <button id="shape-pear">Pear</button>
        <button id="shape-oval">Oval</button>
        <button id="shape-torus">Torus</button>
        <button id="shape-helix">Helix</button>
        <button id="shape-galaxy">Galaxy</button>
        <button id="shape-grapes">Grapes</button>
        <button id="shape-tornado">Tornado</button>
    </div>

    <div id="camera-mode">CAM: follow</div>

    <!-- Tournament Selector -->
    <div id="tournament-selector-panel">
        <div class="panel-title">Tournament Version</div>
        <select id="tournament-selector">
            <option value="">Loading tournaments...</option>
        </select>
        <div class="tournament-info">
            <div><span class="label">Warriors:</span> <span class="value" id="tournament-warriors">-</span></div>
            <div><span class="label">Matchups:</span> <span class="value" id="tournament-matchups">-</span></div>
            <div><span class="label">Date:</span> <span class="value" id="tournament-date">-</span></div>
        </div>
    </div>

    <div id="canvas-container"></div>
    <div id="stats-overlay">
        <div class="stat-row">
            <span class="stat-label">Battles/sec:</span>
            <span class="stat-value" id="stat-battles-per-sec">0.0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Avg Duration:</span>
            <span class="stat-value" id="stat-avg-duration">0.0s</span>
        </div>
        <div class="dominant-llm">
            <div class="stat-label">Most Dominant</div>
            <div class="dominant-llm-name" id="stat-dominant-llm">—</div>
        </div>
    </div>

    <div id="leaderboard"></div>
    <div id="tooltip"></div>
    <div id="detail-panel">
        <h3 id="detail-title">Battle Details</h3>
        <div class="row"><span>Status:</span><span id="detail-status">-</span></div>
        <div class="row"><span class="w0-color" id="detail-w0">W0:</span><span id="detail-w0-score">0</span></div>
        <div class="row"><span class="w1-color" id="detail-w1">W1:</span><span id="detail-w1-score">0</span></div>
        <div class="row"><span>Cycle:</span><span id="detail-cycle">0</span></div>
        <div class="row"><span>Frame:</span><span id="detail-frame">0/0</span></div>
    </div>

    <div id="code-panel">
        <div id="code-panel-header">
            <h4>⚔️ Warrior Code Comparison</h4>
            <button id="code-panel-close">Close</button>
        </div>
        <div id="code-panel-content">
            <div class="code-warrior">
                <div class="code-warrior-header w0">
                    <div class="code-warrior-title">
                        <span class="w0-color" id="code-w0-name">Warrior 0</span>
                        <span id="code-w0-type" class="code-warrior-type"></span>
                    </div>
                    <div id="code-w0-strategy" class="code-warrior-strategy"></div>
                </div>
                <div class="code-warrior-body">
                    <pre id="code-w0"></pre>
                </div>
            </div>
            <div class="code-warrior">
                <div class="code-warrior-header w1">
                    <div class="code-warrior-title">
                        <span class="w1-color" id="code-w1-name">Warrior 1</span>
                        <span id="code-w1-type" class="code-warrior-type"></span>
                    </div>
                    <div id="code-w1-strategy" class="code-warrior-strategy"></div>
                </div>
                <div class="code-warrior-body">
                    <pre id="code-w1"></pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============== Audio System (Minimal UI Feedback) ==============
        const AudioFeedback = {
            ctx: null,

            init() {
                // Lazy init on first user interaction
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
            },

            // Tiny tick on spawn (very short, high freq)
            playSpawnTick() {
                this.init();
                const now = this.ctx.currentTime;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.frequency.value = 1200; // High frequency
                osc.type = 'sine';

                gain.gain.setValueAtTime(0.03, now); // Very quiet
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.02); // 20ms fade

                osc.start(now);
                osc.stop(now + 0.02);
            },

            // Soft boop on battle complete (gentle, mid freq)
            playCompleteBoop() {
                this.init();
                const now = this.ctx.currentTime;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.connect(gain);
                gain.connect(this.ctx.destination);

                osc.frequency.value = 440; // A4 note
                osc.type = 'sine';

                gain.gain.setValueAtTime(0.05, now); // Quiet
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08); // 80ms fade

                osc.start(now);
                osc.stop(now + 0.08);
            }
        };

        // ============== Configuration ==============
        const GRID_COLS = 128;
        const GRID_ROWS = 64;
        const TOTAL_BATTLES = GRID_COLS * GRID_ROWS;  // 8192
        const CORE_SIZE = 8000;
        const CELL_WIDTH = 100;
        const CELL_HEIGHT = 80;
        const BATTLE_SPACING = 1.0;  // Grid spacing
        const BATTLE_WIDTH = 1.05;  // Slightly larger than spacing = OVERLAP = NO GAPS
        const BATTLE_HEIGHT = 1.05;

        // LLMs in the tournament (ranked by GPU tournament results)
        const LLMS = [
            { id: 'claude-sonnet', name: 'Claude Sonnet 4.5', color: 0x00cccc, rank: 1, codename: 'Silk', winRate: '76% vs GPT-5.1', warriorFile: 'anthropic_claude-sonnet-4.5' },
            { id: 'deepseek-v3', name: 'DeepSeek V3', color: 0xff6b00, rank: 2, codename: 'Hydra', winRate: '100% vs KatCoder', warriorFile: 'deepseek_deepseek-chat-v3-0324' },
            { id: 'gpt-5.1', name: 'GPT-5.1', color: 0x74aa9c, rank: 3, codename: 'StoneGate', winRate: '—', warriorFile: 'openai_gpt-5.1' },
            { id: 'kat-coder', name: 'KAT Coder', color: 0xffd700, rank: 4, codename: 'IMP swarm', winRate: '—', warriorFile: 'kwaipilot_kat-coder-pro_free' },
            { id: 'claude-opus', name: 'Claude Opus 4.5', color: 0x00fff7, rank: 5, codename: 'Granite', winRate: '—', warriorFile: 'anthropic_claude-opus-4.5' },
            { id: 'gemini-2.5', name: 'Gemini 2.5', color: 0x4285f4, rank: null, codename: null, winRate: null, warriorFile: 'google_gemini-3-pro-preview' },
        ];

        // Colors - ENHANCED for maximum visual impact
        // Cyan vs Orange creates stark, watchable contrast
        const COLORS = {
            dead: new THREE.Color(0x010102),        // Much darker - maximum contrast
            w0: new THREE.Color(0x00ffff),          // Pure bright cyan
            w1: new THREE.Color(0xff5500),          // Pure bright orange
            grid: new THREE.Color(0x0a0a15),        // Very dark blue-gray
            highlight: new THREE.Color(0xffffff),
        };

        // ============== Redcode Syntax Highlighting ==============
        function highlightRedcode(code) {
            if (!code) return '';

            // Escape HTML
            let html = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            // Process line by line to handle comments correctly
            return html.split('\n').map(line => {
                // Check for full-line comment or directive
                if (line.trim().startsWith(';')) {
                    // Check for directives (;name, ;author, ;strategy, ;redcode, ;assert)
                    const directiveMatch = line.match(/^(\s*;)(redcode|name|author|strategy|assert|trace|break|debug)\b(.*)$/i);
                    if (directiveMatch) {
                        return `<span class="rc-comment">${directiveMatch[1]}</span><span class="rc-directive">${directiveMatch[2]}</span><span class="rc-comment">${directiveMatch[3]}</span>`;
                    }
                    return `<span class="rc-comment">${line}</span>`;
                }

                // Split line into code and inline comment
                const commentIdx = line.indexOf(';');
                let codePart = commentIdx >= 0 ? line.substring(0, commentIdx) : line;
                let commentPart = commentIdx >= 0 ? line.substring(commentIdx) : '';

                // Highlight code part
                // Opcodes (case insensitive)
                codePart = codePart.replace(/\b(DAT|MOV|ADD|SUB|MUL|DIV|MOD|JMP|JMZ|JMN|DJN|SPL|SLT|CMP|SEQ|SNE|NOP|LDP|STP)\b/gi,
                    '<span class="rc-opcode">$1</span>');

                // Pseudo-opcodes
                codePart = codePart.replace(/\b(EQU|ORG|END|FOR|ROF|PIN)\b/gi,
                    '<span class="rc-pseudo">$1</span>');

                // Modifiers (.A, .B, .AB, .BA, .F, .X, .I)
                codePart = codePart.replace(/\.(A|B|AB|BA|F|X|I)\b/gi,
                    '<span class="rc-modifier">.$1</span>');

                // Addressing modes
                codePart = codePart.replace(/([#$@<>*{}])/g,
                    '<span class="rc-address">$1</span>');

                // Numbers (after addressing modes to avoid double-highlighting)
                codePart = codePart.replace(/\b(-?\d+)\b/g,
                    '<span class="rc-number">$1</span>');

                // Labels at start of line (word before opcode, not a keyword)
                codePart = codePart.replace(/^(\s*)([a-zA-Z_][a-zA-Z0-9_]*)(\s+)(?=<span class="rc-)/,
                    '$1<span class="rc-label">$2</span>$3');

                // Combine with comment
                if (commentPart) {
                    return codePart + `<span class="rc-comment">${commentPart}</span>`;
                }
                return codePart;
            }).join('\n');
        }


        // ============== Strategy Analysis ==============
        function analyzeWarriorStrategy(code) {
            const analysis = {
                type: 'unknown',
                strategies: [],
                features: []
            };

            if (!code) return analysis;

            const lines = code.toLowerCase().split('\n');

            // Extract strategy comments
            lines.forEach(line => {
                if (line.includes(';strategy')) {
                    const strategyText = line.substring(line.indexOf(';strategy') + 9).trim();
                    if (strategyText) {
                        analysis.strategies.push(strategyText);
                    }
                }
            });

            // Detect warrior type based on code patterns
            const codeText = code.toLowerCase();
            const hasScanning = /sne|seq|cmp/.test(codeText);
            const hasBombing = /dat.*#0|mov.*dat|mov\..*#0/.test(codeText);
            const hasReplication = /spl.*mov|mov.*spl|replicat/.test(codeText);
            const hasImp = /(mov\.i.*<|mov\.i.*>|imp|gate)/.test(codeText);
            const hasDwarf = /add.*mov.*jmp|bomber/.test(codeText);

            // Classify type
            const typeCount = [hasScanning, hasBombing, hasReplication, hasImp].filter(Boolean).length;

            if (typeCount >= 2) {
                analysis.type = 'hybrid';
            } else if (hasImp) {
                analysis.type = 'imp';
            } else if (hasScanning) {
                analysis.type = 'scanner';
            } else if (hasReplication) {
                analysis.type = 'replicator';
            } else if (hasBombing || hasDwarf) {
                analysis.type = 'bomber';
            }

            // Detect specific features
            if (hasScanning) analysis.features.push('scanning');
            if (hasBombing) analysis.features.push('bombing');
            if (hasReplication) analysis.features.push('replication');
            if (hasImp) analysis.features.push('imp-style movement');
            if (hasDwarf) analysis.features.push('dwarf pattern');
            if (/equ|gap|step|dist/.test(codeText)) analysis.features.push('parameterized');
            if (/spl/.test(codeText)) analysis.features.push('multiprocess');

            return analysis;
        }

        // ============== Warrior Code Display ==============
        const codePanel = document.getElementById('code-panel');
        const codeW0 = document.getElementById('code-w0');
        const codeW1 = document.getElementById('code-w1');
        const codeW0Name = document.getElementById('code-w0-name');
        const codeW1Name = document.getElementById('code-w1-name');

        // Cache for loaded warriors
        const warriorCache = {};

        async function loadWarrior(name) {
            if (warriorCache[name]) return warriorCache[name];

            // Map LLM IDs to actual warrior filenames
            const filenameMap = {
                'claude-opus': 'anthropic_claude-opus-4.5',
                'claude-sonnet': 'anthropic_claude-sonnet-4.5',
                'gpt-5.1': 'openai_gpt-5.1-chat',
                'deepseek-v3': 'deepseek_deepseek-chat-v3-0324',
                'gemini-2.5': 'google_gemini-3-pro-preview',
                'kat-coder': 'kwaipilot_kat-coder-pro_free'
            };

            const filename = filenameMap[name] || name;

            try {
                // Try loading from warriors directory
                const response = await fetch(`gpu_mars/warriors/tournament_001/${filename}.red`);
                if (response.ok) {
                    const code = await response.text();
                    warriorCache[name] = code;
                    return code;
                }
            } catch (e) {
                console.log(`Could not load warrior: ${name}`);
            }
            return `; Warrior: ${name}\n; (Source not available)`;
        }

        async function displayWarriorCode(battle) {
            if (!battle || !codePanel) return;

            // Get warrior names from battle data
            const w0Name = battle.w0?.name || battle.w0Llm?.id || 'Warrior 0';
            const w1Name = battle.w1?.name || battle.w1Llm?.id || 'Warrior 1';

            // Update names
            if (codeW0Name) codeW0Name.textContent = w0Name;
            if (codeW1Name) codeW1Name.textContent = w1Name;

            // Load and display code
            const [w0Code, w1Code] = await Promise.all([
                loadWarrior(w0Name),
                loadWarrior(w1Name)
            ]);

            // Analyze strategies
            const w0Analysis = analyzeWarriorStrategy(w0Code);
            const w1Analysis = analyzeWarriorStrategy(w1Code);

            // Update code with syntax highlighting
            if (codeW0) codeW0.innerHTML = highlightRedcode(w0Code);
            if (codeW1) codeW1.innerHTML = highlightRedcode(w1Code);

            // Update warrior types
            const w0TypeEl = document.getElementById('code-w0-type');
            const w1TypeEl = document.getElementById('code-w1-type');
            if (w0TypeEl) {
                w0TypeEl.textContent = w0Analysis.type.toUpperCase();
                w0TypeEl.className = `code-warrior-type type-${w0Analysis.type}`;
            }
            if (w1TypeEl) {
                w1TypeEl.textContent = w1Analysis.type.toUpperCase();
                w1TypeEl.className = `code-warrior-type type-${w1Analysis.type}`;
            }

            // Update strategy descriptions
            const w0StrategyEl = document.getElementById('code-w0-strategy');
            const w1StrategyEl = document.getElementById('code-w1-strategy');

            if (w0StrategyEl) {
                let strategyHTML = '';
                if (w0Analysis.strategies.length > 0) {
                    strategyHTML = '<div class="code-warrior-strategy-label">Strategy:</div>';
                    strategyHTML += w0Analysis.strategies.map(s => `• ${s}`).join('<br>');
                } else if (w0Analysis.features.length > 0) {
                    strategyHTML = '<div class="code-warrior-strategy-label">Detected:</div>';
                    strategyHTML += `• ${w0Analysis.features.join(', ')}`;
                }
                w0StrategyEl.innerHTML = strategyHTML;
                w0StrategyEl.style.display = strategyHTML ? 'block' : 'none';
            }

            if (w1StrategyEl) {
                let strategyHTML = '';
                if (w1Analysis.strategies.length > 0) {
                    strategyHTML = '<div class="code-warrior-strategy-label">Strategy:</div>';
                    strategyHTML += w1Analysis.strategies.map(s => `• ${s}`).join('<br>');
                } else if (w1Analysis.features.length > 0) {
                    strategyHTML = '<div class="code-warrior-strategy-label">Detected:</div>';
                    strategyHTML += `• ${w1Analysis.features.join(', ')}`;
                }
                w1StrategyEl.innerHTML = strategyHTML;
                w1StrategyEl.style.display = strategyHTML ? 'block' : 'none';
            }

            // Show panel
            codePanel.classList.add('visible');
        }

        function hideWarriorCode() {
            if (codePanel) codePanel.classList.remove('visible');
        }

        // Flying cards queue for victory animations
        let flyingCards = [];

        // Particle explosions queue for victory effects
        let particleExplosions = [];

        // ============== Sound Effects (Web Audio API) ==============
        const AudioFX = {
            context: null,
            enabled: true,

            init() {
                // Create audio context on first user interaction
                if (!this.context) {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                }
            },

            // Play victory chime - bright, satisfying tone
            playVictory(winnerIndex) {
                if (!this.enabled || !this.context) return;

                const now = this.context.currentTime;
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);

                // Different tones for each winner (cyan higher, orange lower)
                const baseFreq = winnerIndex === 0 ? 880 : 660;  // A5 vs E5
                oscillator.frequency.setValueAtTime(baseFreq, now);
                oscillator.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, now + 0.1);

                // Quick attack, gentle decay
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.15, now + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

                oscillator.start(now);
                oscillator.stop(now + 0.3);
            },

            // Play completion sound - subtle whoosh
            playComplete() {
                if (!this.enabled || !this.context) return;

                const now = this.context.currentTime;
                const bufferSize = this.context.sampleRate * 0.2;
                const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                const data = buffer.getChannelData(0);

                // Generate filtered noise whoosh
                for (let i = 0; i < bufferSize; i++) {
                    const t = i / bufferSize;
                    const envelope = Math.sin(t * Math.PI);
                    data[i] = (Math.random() * 2 - 1) * envelope * 0.05;
                }

                const source = this.context.createBufferSource();
                const filter = this.context.createBiquadFilter();
                const gain = this.context.createGain();

                source.buffer = buffer;
                filter.type = 'highpass';
                filter.frequency.value = 2000;

                source.connect(filter);
                filter.connect(gain);
                gain.connect(this.context.destination);

                gain.gain.value = 0.3;

                source.start(now);
            }
        };

        // Initialize audio on first click
        document.addEventListener('click', () => AudioFX.init(), { once: true });

        // ============== State ==============
        let battles = [];
        let playing = true;  // Auto-play on load
        let globalFrame = 0;
        let selectedBattle = null;
        let hoveredBattle = null;
        let leaderboard = {};
        let sortedByLlm = null;  // Currently sorted LLM or null
        let animatingSort = false;
        let performanceTier = 'high';  // 'low', 'medium', 'high'
        let heatmapEnabled = false;

        // Performance stats tracking
        let statsTracker = {
            battleCompletions: [],
            battleDurations: [],  // Track actual battle durations
            totalCycles: 0,
            lastUpdate: performance.now(),

            recordCompletion(battle) {
                const now = performance.now();
                this.battleCompletions.push(now);
                this.totalCycles += battle.cycle || 0;

                // Record battle duration using cycle count
                // battle.cycle represents the number of execution cycles completed
                const durationMs = battle.cycle || 0;
                this.battleDurations.push({ timestamp: now, duration: durationMs });

                // Keep only last 10 seconds of data
                const cutoff = now - 10000;
                this.battleCompletions = this.battleCompletions.filter(t => t > cutoff);
                this.battleDurations = this.battleDurations.filter(d => d.timestamp > cutoff);
            },

            getBattlesPerSecond() {
                if (this.battleCompletions.length === 0) return 0;
                const now = performance.now();

                // Count battles in last 5 seconds
                const recent = this.battleCompletions.filter(t => t > now - 5000);
                if (recent.length === 0) return 0;

                // Calculate rate: battles / actual time window
                const oldestTime = recent[0];
                const timeSpanSec = (now - oldestTime) / 1000;

                // Avoid division by zero, require at least 0.1s of data
                if (timeSpanSec < 0.1) return 0;

                return recent.length / timeSpanSec;
            },

            getAverageDuration() {
                if (this.battleDurations.length === 0) return 0;

                // Average the last 20 battle durations (or all if less)
                const recentDurations = this.battleDurations.slice(-20);
                const totalMs = recentDurations.reduce((sum, d) => sum + d.duration, 0);
                return totalMs / recentDurations.length / 1000; // Convert to seconds
            },


            updateUI() {
                const now = performance.now();
                if (now - this.lastUpdate < 500) return; // Update every 500ms
                this.lastUpdate = now;

                // Battles per second
                const bps = this.getBattlesPerSecond();
                document.getElementById('stat-battles-per-sec').textContent = bps.toFixed(1);

                // Average duration
                const avgDur = this.getAverageDuration();
                document.getElementById('stat-avg-duration').textContent = avgDur.toFixed(2) + 's';

                // Most dominant LLM
                let maxWins = 0;
                let dominantLlm = null;
                LLMS.forEach(llm => {
                    const wins = leaderboard[llm.id].wins;
                    if (wins > maxWins) {
                        maxWins = wins;
                        dominantLlm = llm;
                    }
                });

                const dominantElem = document.getElementById('stat-dominant-llm');
                if (dominantLlm) {
                    dominantElem.textContent = `${dominantLlm.name} (${maxWins})`;
                    dominantElem.style.color = `#${dominantLlm.color.toString(16).padStart(6, '0')}`;
                } else {
                    dominantElem.textContent = '—';
                }
            }
        };


        // Initialize leaderboard
        LLMS.forEach(llm => { leaderboard[llm.id] = { wins: 0, cards: [], streak: 0 }; });
        let lastWinner = null;  // Track last winner for streak detection

        // ============== Performance Benchmark ==============
        function runBenchmark() {
            return new Promise(resolve => {
                const testSize = 100;  // Test with 100 texture updates
                const testData = new Uint8Array(CELL_WIDTH * CELL_HEIGHT * 4);
                const testTextures = [];

                // Create test textures
                for (let i = 0; i < testSize; i++) {
                    const tex = new THREE.DataTexture(
                        new Uint8Array(testData),
                        CELL_WIDTH, CELL_HEIGHT, THREE.RGBAFormat
                    );
                    tex.magFilter = THREE.NearestFilter;
                    tex.minFilter = THREE.NearestFilter;
                    testTextures.push(tex);
                }

                // Warm up
                testTextures.forEach(tex => {
                    for (let j = 0; j < 100; j++) tex.image.data[j] = j;
                    tex.needsUpdate = true;
                });
                renderer.render(scene, camera);

                // Benchmark
                const start = performance.now();
                for (let frame = 0; frame < 10; frame++) {
                    testTextures.forEach(tex => {
                        for (let j = 0; j < 1000; j++) tex.image.data[j] = (j + frame) % 256;
                        tex.needsUpdate = true;
                    });
                    renderer.render(scene, camera);
                }
                const elapsed = performance.now() - start;

                // Cleanup
                testTextures.forEach(tex => tex.dispose());

                // Calculate tier based on time per 100 texture updates
                const msPerBatch = elapsed / 10;
                console.log(`Benchmark: ${msPerBatch.toFixed(1)}ms per 100 texture updates`);

                if (msPerBatch < 10) {
                    performanceTier = 'high';  // Can handle 8192 battles
                    resolve({ tier: 'high', zoom: 1, visibleBattles: 8192 });
                } else if (msPerBatch < 30) {
                    performanceTier = 'medium';  // Zoom to show ~2000 battles
                    resolve({ tier: 'medium', zoom: 2, visibleBattles: 2000 });
                } else {
                    performanceTier = 'low';  // Zoom to show ~500 battles
                    resolve({ tier: 'low', zoom: 4, visibleBattles: 500 });
                }
            });
        }

        // ============== Frustum Culling ==============
        const frustum = new THREE.Frustum();
        const projScreenMatrix = new THREE.Matrix4();

        function updateFrustum() {
            projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            frustum.setFromProjectionMatrix(projScreenMatrix);
        }

        function isInViewport(battle) {
            // Quick bounding sphere check - use stored position if mesh not initialized
            const pos = battle.mesh ? battle.mesh.position : new THREE.Vector3(battle.posX, battle.posY, 0);
            const radius = Math.max(BATTLE_WIDTH, BATTLE_HEIGHT);
            return frustum.containsPoint(pos) ||
                   frustum.intersectsSphere(new THREE.Sphere(pos, radius));
        }

        // ============== Three.js Setup ==============
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x010102);  // Much darker for maximum battle contrast

        // Orthographic camera for 2D flat view
        const aspect = window.innerWidth / (window.innerHeight - 120);
        const frustumSize = 50;
        const orthoCamera = new THREE.OrthographicCamera(
            -frustumSize * aspect / 2, frustumSize * aspect / 2,
            frustumSize / 2, -frustumSize / 2,
            0.1, 1000
        );
        orthoCamera.position.set(GRID_COLS * BATTLE_SPACING / 2, GRID_ROWS * BATTLE_SPACING / 2, 100);
        orthoCamera.lookAt(GRID_COLS * BATTLE_SPACING / 2, GRID_ROWS * BATTLE_SPACING / 2, 0);

        // Perspective camera for 3D shape views
        const SPHERE_RADIUS = 100;
        const perspCamera = new THREE.PerspectiveCamera(60, aspect, 0.1, 2000);
        perspCamera.position.set(0, 0, 50);  // Start close for dramatic first view
        perspCamera.lookAt(0, 0, 0);

        // Active camera (switches between ortho and persp)
        let camera = orthoCamera;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight - 120);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // OrbitControls for pan/zoom (let for reassignment when switching cameras)
        let controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableRotate = false;
        controls.screenSpacePanning = true;
        controls.minZoom = 0.1;
        controls.maxZoom = 20;
        controls.target.set(GRID_COLS * BATTLE_SPACING / 2, GRID_ROWS * BATTLE_SPACING / 2, 0);
        controls.update();

        // ============== Flying Card Animation (3D Directional) ==============
        class FlyingCard {
            constructor(startPos, targetLlm, color) {
                this.startPos = startPos.clone();
                this.targetLlm = targetLlm;
                this.color = color;
                this.progress = 0;
                this.duration = 1.5; // seconds - fast flight to leaderboard
                this.complete = false;

                // FIXED: Calculate target as DOWN to leaderboard, not outward
                this.calculateLeaderboardTarget(targetLlm);

                // Create card mesh - LARGER in 3D modes for visibility
                const is3D = ShapeManager.currentShape !== 'plane';
                const cardSize = is3D ? 5.0 : 2.0;
                const geometry = new THREE.PlaneGeometry(cardSize, cardSize * 0.67);
                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.95  // Very visible
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(startPos);
                // FIXED: Add emissive glow for brightness and visibility
                this.mesh.material.emissive.setHex(color);
                this.mesh.material.emissiveIntensity = 0.8;
                scene.add(this.mesh);

                // Add glow trail - FIXED: Make glow brighter and emissive
                const glowGeometry = new THREE.PlaneGeometry(2.0, 1.4);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.7,  // Brighter glow
                    emissive: new THREE.Color(color),
                    emissiveIntensity: 0.9
                });
                this.glow = new THREE.Mesh(glowGeometry, glowMaterial);
                this.glow.position.z = -0.1;
                this.mesh.add(this.glow);

                // Trail particles
                this.trailPositions = [];
            }

            // FIXED: Calculate target as DOWNWARD to leaderboard
            calculateLeaderboardTarget(targetLlm) {
                // Find which pile index corresponds to this LLM (sorted by wins)
                const sorted = [...LLMS].sort((a, b) =>
                    leaderboard[b.id].wins - leaderboard[a.id].wins
                );
                const targetPileIndex = sorted.findIndex(l => l.id === targetLlm.id);

                // Calculate screen position of the target pile
                // Leaderboard is at bottom, piles are centered with 30px gap
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                const numPiles = LLMS.length;
                const pileWidth = 100; // min-width from CSS
                const gap = 30;
                const totalWidth = (pileWidth * numPiles) + (gap * (numPiles - 1));
                const startX = (screenWidth - totalWidth) / 2;
                const pileX = startX + (targetPileIndex * (pileWidth + gap)) + (pileWidth / 2);
                const pileY = screenHeight - 40; // 80px height / 2 = 40px from bottom

                // Convert screen coordinates to normalized device coordinates (NDC)
                const ndcX = (pileX / screenWidth) * 2 - 1;
                const ndcY = -(pileY / screenHeight) * 2 + 1;

                // Unproject from screen space to world space
                // Use a fixed depth (z) for consistency
                const targetVector = new THREE.Vector3(ndcX, ndcY, 0.5);
                targetVector.unproject(camera);

                // For orthographic camera, the unprojected point is directly usable
                // For perspective camera, we need to project along the ray
                if (camera.isPerspectiveCamera) {
                    const direction = targetVector.sub(camera.position).normalize();
                    // Project to a plane at z=0 (or another consistent depth)
                    const distance = -camera.position.z / direction.z;
                    this.targetPos = camera.position.clone().add(direction.multiplyScalar(distance));
                } else {
                    // For orthographic, just use the unprojected point
                    this.targetPos = targetVector;
                }
            }

            detectCubeFace(pos) {
                const ax = Math.abs(pos.x), ay = Math.abs(pos.y), az = Math.abs(pos.z);
                if (ax > ay && ax > az) return new THREE.Vector3(Math.sign(pos.x), 0, 0);
                if (ay > ax && ay > az) return new THREE.Vector3(0, Math.sign(pos.y), 0);
                return new THREE.Vector3(0, 0, Math.sign(pos.z));
            }

            update(deltaTime) {
                if (this.complete) return;

                this.progress += deltaTime / this.duration;

                if (this.progress >= 1) {
                    this.progress = 1;
                    this.complete = true;
                    scene.remove(this.mesh);
                    return;
                }

                // Ease out cubic for smooth deceleration
                const t = 1 - Math.pow(1 - this.progress, 3);

                // Smooth 3D arc trajectory
                const arcHeight = 50;
                const arc = Math.sin(this.progress * Math.PI) * arcHeight;

                // Interpolate position
                this.mesh.position.lerpVectors(this.startPos, this.targetPos, t);

                // Add arc perpendicular to flight direction
                const flightDir = this.targetPos.clone().sub(this.startPos).normalize();
                const perpendicular = new THREE.Vector3(-flightDir.y, flightDir.x, 0).normalize();
                this.mesh.position.add(perpendicular.multiplyScalar(arc * 0.5));

                // Look at camera (billboard effect)
                this.mesh.lookAt(camera.position);

                // Spin during flight
                this.mesh.rotateZ(deltaTime * 5);

                // Scale: grow then shrink
                const scaleCurve = Math.sin(this.progress * Math.PI);
                const scale = 1 + scaleCurve * 0.8;
                this.mesh.scale.set(scale, scale, 1);

                // Fade both card and glow towards end
                const fadeStart = 0.7;
                if (this.progress > fadeStart) {
                    const fadeProgress = (this.progress - fadeStart) / (1 - fadeStart);
                    this.mesh.material.opacity = 1.0 - fadeProgress;
                    this.glow.material.opacity = 0.6 * (1 - fadeProgress);
                } else {
                    // Pulsing glow during flight
                    this.glow.material.opacity = 0.6 + Math.sin(this.progress * Math.PI * 6) * 0.2;
                }
            }
        }

        // ============== Particle Explosion Class ==============
        class ParticleExplosion {
            constructor(center, color, particleCount = 18) {
                this.center = center.clone();
                this.color = color;
                this.particles = [];
                this.complete = false;
                this.duration = 0.65; // seconds
                this.startTime = performance.now();

                // Create particles that explode outward
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                const velocities = [];

                for (let i = 0; i < particleCount; i++) {
                    // Random direction on sphere
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;

                    // Convert spherical to cartesian
                    const vx = Math.sin(phi) * Math.cos(theta);
                    const vy = Math.sin(phi) * Math.sin(theta);
                    const vz = Math.cos(phi);

                    // Speed: 20-40 units/sec
                    const speed = 20 + Math.random() * 20;

                    velocities.push([vx * speed, vy * speed, vz * speed]);

                    // Start at center
                    positions.push(center.x, center.y, center.z);

                    // Add color with slight variation
                    const r = (color >> 16) & 0xff;
                    const g = (color >> 8) & 0xff;
                    const b = color & 0xff;
                    const brighten = 0.9 + Math.random() * 0.2;
                    colors.push(
                        Math.min(255, r * brighten) / 255,
                        Math.min(255, g * brighten) / 255,
                        Math.min(255, b * brighten) / 255
                    );
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));

                const material = new THREE.PointsMaterial({
                    size: 2.0,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1.0,
                    sizeAttenuation: true
                });

                this.points = new THREE.Points(geometry, material);
                this.velocities = velocities;
                this.geometry = geometry;
                scene.add(this.points);
            }

            update(deltaTime) {
                if (this.complete) return;

                const elapsed = performance.now() - this.startTime;
                const progress = elapsed / (this.duration * 1000);

                if (progress >= 1) {
                    this.complete = true;
                    scene.remove(this.points);
                    this.geometry.dispose();
                    this.points.material.dispose();
                    return;
                }

                // Update positions
                const positions = this.geometry.attributes.position.array;
                for (let i = 0; i < this.velocities.length; i++) {
                    const idx = i * 3;
                    const vel = this.velocities[i];
                    positions[idx] += vel[0] * deltaTime;
                    positions[idx + 1] += vel[1] * deltaTime;
                    positions[idx + 2] += vel[2] * deltaTime;
                }
                this.geometry.attributes.position.needsUpdate = true;

                // Fade out over duration
                this.points.material.opacity = 1.0 - progress;
            }
        }

        // ============== Battle Class ==============
        // Shared geometry for all battles (huge memory savings)
        const sharedBattleGeometry = new THREE.PlaneGeometry(BATTLE_WIDTH, BATTLE_HEIGHT);
        const sharedBorderGeometry = new THREE.EdgesGeometry(sharedBattleGeometry);

        class Battle {
            constructor(index, col, row, w0Llm, w1Llm) {
                this.index = index;
                this.col = col;
                this.row = row;
                this.originalCol = col;  // For sorting reset
                this.originalRow = row;
                this.w0Llm = w0Llm;
                this.w1Llm = w1Llm;
                this.frames = [];
                this.currentFrame = 0;
                this.core = null;  // Lazy: created on demand
                this.w0Territory = 0;
                this.w1Territory = 0;
                this.cycle = 0;
                this.winner = null;  // null, 0, 1, or 'tie'
                this.complete = false;
                this.inViewport = true;  // Frustum culling flag
                this.pulseStartTime = null;  // For victory pulse/glow animation

                
                // Momentum tracking
                this.prevW0Territory = 0;
                this.prevW1Territory = 0;
                this.momentum = 0;  // -1 to 1: negative = w0 gaining, positive = w1 gaining
                this.momentumStrength = 0;  // 0 to 1: how strong the shift is

                // Animation state for sorting
                this.targetPosition = null;
                this.animationProgress = 1;  // 1 = complete

                // Victory pulse animation
                this.victoryPulseStart = null;
                this.victoryPulseIntensity = 0;

                // LAZY: Texture/mesh created on first spawn
                this.textureData = null;
                this.texture = null;
                this.material = null;
                this.mesh = null;
                this.border = null;
                this.initialized = false;

                // Store position for lazy init
                this.posX = col * BATTLE_SPACING + BATTLE_WIDTH / 2;
                this.posY = row * BATTLE_SPACING + BATTLE_HEIGHT / 2;

                // Spawn state
                this.spawned = false;
            }

            // Lazy initialization - only creates GPU resources when needed
            ensureInitialized() {
                if (this.initialized) return;
                // NOTE: initialized flag set at END of this method to avoid race conditions

                // Create texture
                this.textureData = new Uint8Array(CELL_WIDTH * CELL_HEIGHT * 4);
                this.texture = new THREE.DataTexture(
                    this.textureData, CELL_WIDTH, CELL_HEIGHT, THREE.RGBAFormat
                );
                this.texture.magFilter = THREE.NearestFilter;
                this.texture.minFilter = THREE.NearestFilter;
                this.texture.needsUpdate = true;

                // Create mesh (using shared geometry)
                this.material = new THREE.MeshBasicMaterial({ map: this.texture });
                this.mesh = new THREE.Mesh(sharedBattleGeometry, this.material);
                this.mesh.position.set(this.posX, this.posY, 0);
                this.mesh.userData = { battle: this };
                this.mesh.visible = false;
                scene.add(this.mesh);

                // Border mesh (using shared geometry) - SUBTLE
                const borderMaterial = new THREE.LineBasicMaterial({
                    color: COLORS.grid,
                    transparent: true,
                    opacity: 0.3  // Subtle border - not overpowering
                });
                this.border = new THREE.LineSegments(sharedBorderGeometry, borderMaterial);
                this.border.position.copy(this.mesh.position);
                this.border.visible = false;
                scene.add(this.border);

                // LLM IDENTITY GLOW - Background that shows who's fighting
                // Blends the two LLM colors for a unique hue per matchup
                const w0Color = new THREE.Color(this.w0Llm.color);
                const w1Color = new THREE.Color(this.w1Llm.color);
                const blendedColor = w0Color.clone().lerp(w1Color, 0.5);

                const glowGeometry = new THREE.PlaneGeometry(BATTLE_WIDTH * 1.2, BATTLE_HEIGHT * 1.2);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: blendedColor,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide
                });

                this.identityGlow = new THREE.Mesh(glowGeometry, glowMaterial);
                this.identityGlow.position.copy(this.mesh.position);
                this.identityGlow.position.z = -0.1;  // Behind battle
                this.identityGlow.visible = false;
                scene.add(this.identityGlow);

                // CORNER ACCENTS - Small markers showing w0/w1 colors
                const accentSize = 0.15;
                const accentOffset = 0.42;  // Position at corners

                // W0 corner (top-left, cyan-ish)
                const w0AccentGeo = new THREE.CircleGeometry(accentSize, 8);
                const w0AccentMat = new THREE.MeshBasicMaterial({
                    color: this.w0Llm.color,
                    transparent: true,
                    opacity: 0.8
                });
                this.w0Accent = new THREE.Mesh(w0AccentGeo, w0AccentMat);
                this.w0Accent.position.set(
                    this.mesh.position.x - BATTLE_WIDTH * accentOffset,
                    this.mesh.position.y + BATTLE_HEIGHT * accentOffset,
                    0.05
                );
                this.w0Accent.visible = false;
                scene.add(this.w0Accent);

                // W1 corner (bottom-right, orange-ish)
                const w1AccentGeo = new THREE.CircleGeometry(accentSize, 8);
                const w1AccentMat = new THREE.MeshBasicMaterial({
                    color: this.w1Llm.color,
                    transparent: true,
                    opacity: 0.8
                });
                this.w1Accent = new THREE.Mesh(w1AccentGeo, w1AccentMat);
                this.w1Accent.position.set(
                    this.mesh.position.x + BATTLE_WIDTH * accentOffset,
                    this.mesh.position.y - BATTLE_HEIGHT * accentOffset,
                    0.05
                );
                this.w1Accent.visible = false;
                scene.add(this.w1Accent);

                // Update momentum arrow position
                if (this.momentumArrow) {
                    this.momentumArrow.position.x = this.mesh.position.x;
                    this.momentumArrow.position.y = this.mesh.position.y;
                }

                // Create momentum arrow (triangle indicator)
                const arrowShape = new THREE.Shape();
                arrowShape.moveTo(0, 0.3);
                arrowShape.lineTo(0.15, -0.15);
                arrowShape.lineTo(-0.15, -0.15);
                arrowShape.lineTo(0, 0.3);
                const arrowGeometry = new THREE.ShapeGeometry(arrowShape);
                const arrowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0,
                    side: THREE.DoubleSide
                });
                this.momentumArrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                this.momentumArrow.position.copy(this.mesh.position);
                this.momentumArrow.position.z = 0.5;  // Above battle
                scene.add(this.momentumArrow);

                // Create core array
                this.core = new Uint8Array(CORE_SIZE);

                // Generate demo data
                this.generateDemoData();

                // Debug: Log frame count on first battle only
                if (this.index === 0) {
                    console.log(`[Battle ${this.index}] Initialized with ${this.frames.length} frames`);
                }

                // Mark as initialized AFTER all resources created (avoids race conditions)
                this.initialized = true;
            }

            generateDemoData() {
                // Simulate 400 frames (40 seconds at 10fps)
                const numFrames = 400;
                const core = new Uint8Array(CORE_SIZE);

                // Random starting positions
                const w0Start = Math.floor(Math.random() * 4000) + 1000;
                const w1Start = (w0Start + 4000) % CORE_SIZE;

                // Initial placement
                for (let i = 0; i < 10; i++) {
                    core[(w0Start + i) % CORE_SIZE] = 1;
                    core[(w1Start + i) % CORE_SIZE] = 2;
                }

                // Determine winner (weighted by LLM strength for demo)
                const w0Strength = LLMS.findIndex(l => l.id === this.w0Llm.id);
                const w1Strength = LLMS.findIndex(l => l.id === this.w1Llm.id);
                const r = Math.random();
                if (r < 0.4) {
                    this.winner = w0Strength <= w1Strength ? 0 : 1;
                } else if (r < 0.8) {
                    this.winner = w0Strength >= w1Strength ? 1 : 0;
                } else {
                    this.winner = 'tie';
                }

                let w0Pos = w0Start;
                let w1Pos = w1Start;

                for (let f = 0; f < numFrames; f++) {
                    const deltas = [];
                    const progress = f / numFrames;

                    // W0: bomber pattern
                    if (Math.random() < 0.3) {
                        const step = [7, 13, 17, 23][Math.floor(Math.random() * 4)];
                        const target = (w0Pos + step * (f + 1)) % CORE_SIZE;
                        if (core[target] !== 1) {
                            core[target] = 1;
                            deltas.push([target, 1]);
                        }
                    }

                    // W1: imp spiral
                    if (f % 3 === 0) {
                        w1Pos = (w1Pos + 1) % CORE_SIZE;
                        if (core[w1Pos] !== 2) {
                            core[w1Pos] = 2;
                            deltas.push([w1Pos, 2]);
                        }
                    }

                    // Late game bias
                    if (progress > 0.7 && this.winner !== 'tie' && Math.random() < 0.15) {
                        const winner = this.winner;
                        const loser = 1 - winner;
                        for (let i = 0; i < CORE_SIZE; i++) {
                            if (core[i] === loser + 1 && Math.random() < 0.03) {
                                core[i] = winner + 1;
                                deltas.push([i, winner + 1]);
                                break;
                            }
                        }
                    }

                    // Count territories
                    let w0 = 0, w1 = 0;
                    for (let i = 0; i < CORE_SIZE; i++) {
                        if (core[i] === 1) w0++;
                        else if (core[i] === 2) w1++;
                    }

                    this.frames.push({
                        deltas,
                        w0, w1,
                        cycle: f * 200,
                        isKeyframe: f % 30 === 0,
                        coreSnapshot: f % 30 === 0 ? new Uint8Array(core) : null
                    });
                }

                // Initialize display
                this.updateTexture();
            }

            // Animate position for sorting
            animatePosition(deltaTime) {
                if (this.animationProgress >= 1 || !this.targetPosition) return;

                this.animationProgress += deltaTime * 2;  // 0.5 second animation
                if (this.animationProgress > 1) this.animationProgress = 1;

                // Ease out cubic
                const t = 1 - Math.pow(1 - this.animationProgress, 3);

                // Interpolate position
                const startX = this.col * BATTLE_SPACING + BATTLE_WIDTH / 2;
                const startY = this.row * BATTLE_SPACING + BATTLE_HEIGHT / 2;
                this.mesh.position.x = startX + (this.targetPosition.x - startX) * t;
                this.mesh.position.y = startY + (this.targetPosition.y - startY) * t;
                this.border.position.copy(this.mesh.position);

                // Move identity visuals with the battle
                if (this.identityGlow) this.identityGlow.position.copy(this.mesh.position);
                if (this.w0Accent) {
                    this.w0Accent.position.set(
                        this.mesh.position.x - BATTLE_WIDTH * 0.42,
                        this.mesh.position.y + BATTLE_HEIGHT * 0.42,
                        0.05
                    );
                }
                if (this.w1Accent) {
                    this.w1Accent.position.set(
                        this.mesh.position.x + BATTLE_WIDTH * 0.42,
                        this.mesh.position.y - BATTLE_HEIGHT * 0.42,
                        0.05
                    );
                }

                // When done, update col/row to new position
                if (this.animationProgress >= 1) {
                    this.col = Math.round((this.targetPosition.x - BATTLE_WIDTH / 2) / BATTLE_SPACING);
                    this.row = Math.round((this.targetPosition.y - BATTLE_HEIGHT / 2) / BATTLE_SPACING);
                }
            }

            // Set target for animated move
            setTargetPosition(col, row) {
                this.targetPosition = new THREE.Vector3(
                    col * BATTLE_SPACING + BATTLE_WIDTH / 2,
                    row * BATTLE_SPACING + BATTLE_HEIGHT / 2,
                    0
                );
                this.animationProgress = 0;
            }

            // Spawn: reveal this battle with optional fade-in
            spawn() {
                if (this.spawned) return;
                this.ensureInitialized();  // Lazy init on first spawn
                this.spawned = true;
                this.mesh.visible = true;
                this.border.visible = true;

                // Show LLM identity visuals
                if (this.identityGlow) this.identityGlow.visible = true;
                if (this.w0Accent) this.w0Accent.visible = true;
                if (this.w1Accent) this.w1Accent.visible = true;

                // DEBUG: Log spawn with frame count
                if (this.index === 0) {
                    console.log(`[Battle ${this.index}] SPAWNED with ${this.frames.length} frames`);
                }
                AudioFeedback.playSpawnTick();  // Tiny tick sound
            }

            advanceFrame() {
                // DEBUG: Check if frames exist
                if (this.frames.length === 0) {
                    console.error(`[Battle ${this.index}] advanceFrame called but frames.length = 0! spawned: ${this.spawned}, initialized: ${this.initialized}`);
                    return false;
                }

                // DEBUG: Log state every 50 frames for first battle
                if (this.index === 0 && this.currentFrame % 50 === 0) {
                    console.log(`[Battle 0] Frame ${this.currentFrame}/${this.frames.length}, complete: ${this.complete}, spawned: ${this.spawned}`);
                }

                if (this.currentFrame >= this.frames.length - 1) {
                    if (!this.complete) {
                        this.complete = true;
                        // Debug: Log first completion
                        if (battles.filter(b => b.complete).length === 0) {
                            console.log(`[Battle ${this.index}] FIRST COMPLETION! Frame ${this.currentFrame}/${this.frames.length}`);
                        }
                        this.onComplete();
                    }
                    return false;
                }

                // Skip texture updates if not in viewport (frustum culling)
                if (!this.inViewport && !this.complete) {
                    this.currentFrame++;
                    const frame = this.frames[this.currentFrame];
                    // Still update internal state
                    if (frame.isKeyframe && frame.coreSnapshot) {
                        this.core.set(frame.coreSnapshot);
                    } else {
                        for (const [addr, value] of frame.deltas) {
                            this.core[addr] = value;
                        }
                    }
                    this.w0Territory = frame.w0;
                    this.w1Territory = frame.w1;
                    this.cycle = frame.cycle;
                    return true;  // Don't update texture
                }

                this.currentFrame++;
                const frame = this.frames[this.currentFrame];

                // Apply deltas
                if (frame.isKeyframe && frame.coreSnapshot) {
                    this.core.set(frame.coreSnapshot);
                } else {
                    for (const [addr, value] of frame.deltas) {
                        this.core[addr] = value;
                    }
                }

                this.w0Territory = frame.w0;
                this.w1Territory = frame.w1;
                this.cycle = frame.cycle;

                // Calculate momentum from territory changes
                const w0Delta = this.w0Territory - this.prevW0Territory;
                const w1Delta = this.w1Territory - this.prevW1Territory;
                const totalDelta = Math.abs(w0Delta) + Math.abs(w1Delta);

                if (totalDelta > 0) {
                    this.momentum = (w1Delta - w0Delta) / totalDelta;
                    this.momentumStrength = Math.min(totalDelta / 50, 1.0);  // Normalize
                } else {
                    this.momentumStrength *= 0.9;  // Decay
                }

                this.prevW0Territory = this.w0Territory;
                this.prevW1Territory = this.w1Territory;

                // Update momentum arrow
                if (this.momentumArrow && this.momentumStrength > 0.1 && !this.complete) {
                    this.momentumArrow.material.opacity = this.momentumStrength * 0.8;

                    // Color and rotate based on which side has momentum
                    if (this.momentum < -0.1) {
                        // W0 (cyan) has momentum - point up
                        this.momentumArrow.material.color.setHex(0x00fff7);
                        this.momentumArrow.rotation.z = 0;
                    } else if (this.momentum > 0.1) {
                        // W1 (orange) has momentum - point down
                        this.momentumArrow.material.color.setHex(0xff6b00);
                        this.momentumArrow.rotation.z = Math.PI;
                    } else {
                        this.momentumArrow.material.opacity = 0;  // Hide if balanced
                    }

                    // Pulse the arrow
                    const pulse = 1 + Math.sin(Date.now() * 0.01) * 0.2;
                    this.momentumArrow.scale.set(pulse, pulse, 1);
                } else if (this.momentumArrow) {
                    this.momentumArrow.material.opacity = 0;
                }

                // Update border glow based on momentum
                if (!this.complete && this.border && this.momentumStrength > 0.2) {
                    // Mix colors based on momentum direction
                    const w0Color = new THREE.Color(0x00fff7);
                    const w1Color = new THREE.Color(0xff6b00);
                    const t = (this.momentum + 1) / 2;  // Map -1..1 to 0..1
                    this.border.material.color.lerpColors(w0Color, w1Color, t);

                    // Increase border brightness based on strength
                    const brightness = 1.0 + this.momentumStrength * 2.0;
                    this.border.material.color.multiplyScalar(brightness);
                }

                this.updateTexture();
                return true;
            }

            updateTexture() {
                const deadColor = [2, 2, 4, 255];        // Much darker dead cells for maximum contrast
                const w0Color = [0, 255, 255, 255];      // Pure bright cyan (removed green tint)
                const w1Color = [255, 160, 0, 255];      // Brighter orange (boosted middle value)

                for (let i = 0; i < CORE_SIZE; i++) {
                    const pi = i * 4;
                    const v = this.core[i];
                    const color = v === 1 ? w0Color : v === 2 ? w1Color : deadColor;
                    this.textureData[pi] = color[0];
                    this.textureData[pi + 1] = color[1];
                    this.textureData[pi + 2] = color[2];
                    this.textureData[pi + 3] = color[3];
                }
                this.texture.needsUpdate = true;
            }

            onComplete() {
                AudioFeedback.playCompleteBoop();  // Soft boop sound
                statsTracker.recordCompletion(this);

                // Add to winner's pile and spawn flying card
                if (this.winner !== 'tie' && this.winner !== null) {
                    const winnerLlm = this.winner === 0 ? this.w0Llm : this.w1Llm;
                    leaderboard[winnerLlm.id].wins++;

                    // Update win streaks
                    if (lastWinner === winnerLlm.id) {
                        leaderboard[winnerLlm.id].streak++;
                    } else {
                        // Reset previous winner's streak
                        if (lastWinner) {
                            leaderboard[lastWinner].streak = 0;
                        }
                        leaderboard[winnerLlm.id].streak = 1;
                        lastWinner = winnerLlm.id;
                    }
                    leaderboard[winnerLlm.id].cards.push(this);

                    // Spawn flying card animation
                    const card = new FlyingCard(
                        this.mesh.position.clone(),
                        winnerLlm,
                        this.winner === 0 ? COLORS.w0 : COLORS.w1
                    );
                    flyingCards.push(card);

                    // Spawn particle explosion in winner's color
                    const particleColor = this.winner === 0 ? 0x00ffff : 0xff5500;
                    const explosion = new ParticleExplosion(
                        this.mesh.position.clone(),
                        particleColor,
                        18  // 15-20 particles
                    );
                    particleExplosions.push(explosion);

                    updateLeaderboardUI();
                }

                // Start victory pulse animation
                this.pulseStartTime = performance.now();

                // Flash border (guard against uninitialized battles)
                if (this.border && this.border.material) {
                    this.border.material.color.setHex(
                        this.winner === 0 ? 0x00fff7 :
                        this.winner === 1 ? 0xff6b00 :
                        0xffffff
                    );
                }
            
                // Start victory pulse animation
                this.victoryPulseStart = performance.now();
                this.victoryPulseIntensity = 1.0;

                // Play victory sound
                if (this.winner !== 'tie' && this.winner !== null) {
                    AudioFX.playVictory(this.winner);
                } else {
                    AudioFX.playComplete();
                }
            }

            updatePulse(currentTime) {
                // Guard against uninitialized battles
                if (!this.initialized || !this.border) return;

                if (!this.pulseStartTime || !this.complete) return;



                const elapsed = currentTime - this.pulseStartTime;


                const PULSE_DURATION = 500; // 0.5 seconds in milliseconds



                if (elapsed > PULSE_DURATION) {


                    this.pulseStartTime = null;


                    return;


                }



                // Pulse intensity: 0 -> 1 -> 0 (sine wave)


                const t = elapsed / PULSE_DURATION;


                const intensity = Math.sin(t * Math.PI);



                // Get winner color (bright cyan for w0, bright orange for w1)


                const baseColor = this.winner === 0 ? 0x00ffff : this.winner === 1 ? 0xff5500 : 0xffffff;



                // Extract RGB components


                const r = ((baseColor >> 16) & 0xff) / 255;


                const g = ((baseColor >> 8) & 0xff) / 255;


                const b = (baseColor & 0xff) / 255;



                // Interpolate to bright white (add intensity)


                const pulseR = Math.min(1, r + intensity * 0.8);


                const pulseG = Math.min(1, g + intensity * 0.8);


                const pulseB = Math.min(1, b + intensity * 0.8);



                this.border.material.color.setRGB(pulseR, pulseG, pulseB);


            }



            highlight(on) {
                this.border.material.color.set(on ? COLORS.highlight : COLORS.grid);
            }
        }

        // ============== Binary Recording Decoder ==============
        class CWRecording {
            constructor(buffer) {
                this.view = new DataView(buffer);
                this.parseHeader();
            }

            parseHeader() {
                const magic = String.fromCharCode(
                    this.view.getUint8(0), this.view.getUint8(1),
                    this.view.getUint8(2), this.view.getUint8(3)
                );
                if (magic !== 'CWRC') throw new Error('Invalid format');

                this.version = this.view.getUint16(4, true);
                this.coreSize = this.view.getUint16(6, true);
                this.maxCycles = this.view.getUint32(8, true);
                this.frameCount = this.view.getUint32(12, true);
                this.totalCycles = this.view.getUint32(16, true);
                this.winner = this.view.getUint8(20);
                this.flags = this.view.getUint8(21);
                this.keyframeInterval = this.view.getUint16(22, true);
                this.w0Final = this.view.getUint32(24, true);
                this.w1Final = this.view.getUint32(28, true);

                this.w0Name = this.readString(64, 32);
                this.w1Name = this.readString(96, 32);
                this.frameOffset = 128;
            }

            readString(offset, maxLen) {
                let str = '';
                for (let i = 0; i < maxLen; i++) {
                    const c = this.view.getUint8(offset + i);
                    if (c === 0) break;
                    str += String.fromCharCode(c);
                }
                return str;
            }

            *frames() {
                let offset = this.frameOffset;
                const core = new Uint8Array(this.coreSize);

                while (offset < this.view.byteLength) {
                    const frameType = this.view.getUint8(offset);
                    const flags = this.view.getUint8(offset + 1);
                    const deltaCount = this.view.getUint16(offset + 2, true);
                    offset += 4;

                    if (frameType === 1) {
                        // Keyframe
                        const rleCount = this.view.getUint16(offset, true);
                        const w0 = this.view.getUint16(offset + 2, true);
                        const w1 = this.view.getUint16(offset + 4, true);
                        const cycle = this.view.getUint32(offset + 6, true);
                        offset += 10;

                        let coreIdx = 0;
                        for (let i = 0; i < rleCount; i++) {
                            const value = this.view.getUint8(offset);
                            const runLen = this.view.getUint16(offset + 1, true);
                            offset += 3;
                            for (let j = 0; j < runLen && coreIdx < this.coreSize; j++) {
                                core[coreIdx++] = value;
                            }
                        }
                        yield { type: 'K', core: new Uint8Array(core), w0, w1, cycle };
                    } else {
                        // Delta frame
                        const w0 = this.view.getUint16(offset, true);
                        const w1 = this.view.getUint16(offset + 2, true);
                        const cycle = this.view.getUint32(offset + 4, true);
                        offset += 8;

                        const writes = [];
                        for (let i = 0; i < deltaCount; i++) {
                            const packed = this.view.getUint16(offset, true);
                            offset += 2;
                            const addr = packed & 0x1FFF;
                            const value = (packed >> 13) & 0x3;
                            const isAction = (packed >> 15) & 1;
                            core[addr] = value;
                            if (isAction) writes.push(addr);
                        }
                        yield { type: 'D', core: new Uint8Array(core), w0, w1, cycle, writes };
                    }
                }
            }
        }

        // ============== Initialize Grid ==============
        function initializeGrid() {
            battles = [];
            let idx = 0;

            for (let row = 0; row < GRID_ROWS; row++) {
                for (let col = 0; col < GRID_COLS; col++) {
                    // Assign LLMs based on position (each LLM faces all others)
                    const w0Llm = LLMS[col % LLMS.length];
                    const w1Llm = LLMS[row % LLMS.length];

                    const battle = new Battle(idx, col, row, w0Llm, w1Llm);
                    battles.push(battle);
                    idx++;
                }
            }

            document.getElementById('battle-count').textContent = battles.length;
            updateLeaderboardUI();
        }

        // ============== Leaderboard UI ==============
        function updateLeaderboardUI() {
            const container = document.getElementById('leaderboard');
            container.innerHTML = '';

            // Sort by wins
            const sorted = [...LLMS].sort((a, b) =>
                leaderboard[b.id].wins - leaderboard[a.id].wins
            );

            sorted.forEach(llm => {
                const pile = document.createElement('div');
                pile.className = 'llm-pile';
                pile.style.cursor = 'pointer';
                pile.onclick = () => sortBattlesByLlm(llm);

                const stack = document.createElement('div');
                stack.className = 'pile-stack';

                // Show stacked cards (max 5 visual)
                const numCards = Math.min(leaderboard[llm.id].wins, 5);
                for (let i = 0; i < numCards; i++) {
                    const card = document.createElement('div');
                    card.className = 'pile-card';
                    card.style.background = `#${llm.color.toString(16).padStart(6, '0')}`;
                    card.style.left = `${i * 2}px`;
                    card.style.bottom = `${i * 3}px`;
                    card.style.transform = `rotate(${(Math.random() - 0.5) * 10}deg)`;
                    stack.appendChild(card);
                }

                pile.appendChild(stack);

                const wins = document.createElement('div');
                wins.className = 'pile-wins';
                wins.textContent = leaderboard[llm.id].wins;
                pile.appendChild(wins);

                // Show win streak if > 1
                if (leaderboard[llm.id].streak > 1) {
                    const streak = document.createElement('div');
                    streak.className = 'pile-streak';
                    const fireEmoji = '🔥';
                    streak.textContent = `${fireEmoji} ${leaderboard[llm.id].streak} win streak!`;
                    pile.appendChild(streak);
                }

                const name = document.createElement('div');
                name.className = 'pile-name';
                name.style.color = `#${llm.color.toString(16).padStart(6, '0')}`;

                // Add rank badge if ranked
                if (llm.rank) {
                    const rankBadge = document.createElement('div');
                    rankBadge.className = `rank-badge rank-${llm.rank}`;

                    // Rank number with trophy emoji for #1
                    const rankIcon = document.createElement('span');
                    rankIcon.className = 'rank-badge-icon';
                    rankIcon.textContent = llm.rank === 1 ? '🏆' : `#${llm.rank}`;
                    rankBadge.appendChild(rankIcon);

                    name.appendChild(rankBadge);
                }

                // Model name
                const nameSpan = document.createElement('span');
                nameSpan.textContent = llm.name + (sortedByLlm?.id === llm.id ? ' ★' : '');
                name.appendChild(nameSpan);

                // Add codename if available
                if (llm.codename) {
                    const codename = document.createElement('span');
                    codename.className = 'codename-badge';
                    codename.textContent = `"${llm.codename}"`;
                    name.appendChild(codename);
                }

                pile.appendChild(name);

                container.appendChild(pile);
            });
        }

        // ============== Sort Battles by LLM ==============
        function sortBattlesByLlm(llm) {
            if (animatingSort) return;

            // Toggle off if already sorted by this LLM
            if (sortedByLlm?.id === llm.id) {
                resetBattlePositions();
                return;
            }

            sortedByLlm = llm;
            animatingSort = true;

            // Separate battles into groups
            const wonByLlm = [];
            const lostByLlm = [];
            const other = [];

            battles.forEach(battle => {
                const winnerLlm = battle.winner === 0 ? battle.w0Llm :
                                  battle.winner === 1 ? battle.w1Llm : null;

                if (winnerLlm?.id === llm.id) {
                    wonByLlm.push(battle);
                } else if (battle.w0Llm.id === llm.id || battle.w1Llm.id === llm.id) {
                    lostByLlm.push(battle);
                } else {
                    other.push(battle);
                }
            });

            // Arrange: wins at top-left, losses next, others at bottom
            let idx = 0;

            // Wins section (highlighted)
            wonByLlm.forEach(battle => {
                if (!battle.initialized) return;  // Skip uninitialized battles
                const col = idx % GRID_COLS;
                const row = Math.floor(idx / GRID_COLS);
                battle.setTargetPosition(col, row);
                battle.border.material.color.setHex(llm.color);
                idx++;
            });

            // Losses section
            lostByLlm.forEach(battle => {
                if (!battle.initialized) return;  // Skip uninitialized battles
                const col = idx % GRID_COLS;
                const row = Math.floor(idx / GRID_COLS);
                battle.setTargetPosition(col, row);
                battle.border.material.color.set(COLORS.grid);
                idx++;
            });

            // Others (dimmed)
            other.forEach(battle => {
                if (!battle.initialized) return;  // Skip uninitialized battles
                const col = idx % GRID_COLS;
                const row = Math.floor(idx / GRID_COLS);
                battle.setTargetPosition(col, row);
                battle.border.material.color.set(COLORS.grid);
                battle.material.opacity = 0.3;
                idx++;
            });

            updateLeaderboardUI();

            // Mark animation complete after delay
            setTimeout(() => { animatingSort = false; }, 600);
        }

        function resetBattlePositions() {
            sortedByLlm = null;
            animatingSort = true;

            battles.forEach(battle => {
                if (!battle.initialized) return;  // Skip uninitialized battles
                battle.setTargetPosition(battle.originalCol, battle.originalRow);
                battle.border.material.color.set(
                    battle.complete ?
                        (battle.winner === 0 ? 0x00fff7 :
                         battle.winner === 1 ? 0xff6b00 : 0xffffff) :
                        COLORS.grid
                );
                battle.material.opacity = 1;
            });

            updateLeaderboardUI();
            setTimeout(() => { animatingSort = false; }, 600);
        }

        // ============== Animation Loop ==============
        let lastTime = 0;
        let prevAnimTime = 0;
        const frameInterval = 100; // 10 fps for battles
        let visibleCount = 0;

        // Adaptive FPS zoom - auto-zoom when performance drops
        const FPSMonitor = {
            frameTimes: [],
            lastFrameTime: 0,
            targetFPS: 24,
            minFPS: 12,
            lastCheck: 0,
            checkInterval: 2000,  // Check every 2s (less aggressive)
            autoZoomEnabled: true,
            maxZoom: 4,  // Don't zoom past 4x

            recordFrame(time) {
                if (this.lastFrameTime > 0) {
                    const frameTime = time - this.lastFrameTime;
                    this.frameTimes.push(frameTime);
                    if (this.frameTimes.length > 60) this.frameTimes.shift();
                }
                this.lastFrameTime = time;
            },

            getAverageFPS() {
                if (this.frameTimes.length < 10) return 60;
                const avgFrameTime = this.frameTimes.reduce((a, b) => a + b, 0) / this.frameTimes.length;
                return 1000 / avgFrameTime;  // Convert ms to fps
            },

            update(time) {
                if (!this.autoZoomEnabled) return;
                if (time - this.lastCheck < this.checkInterval) return;
                this.lastCheck = time;

                const avgFPS = this.getAverageFPS();

                // If FPS too low and not at max zoom, zoom in gently
                if (avgFPS < this.minFPS && camera.zoom < this.maxZoom) {
                    camera.zoom *= 1.15;  // Gentler 15% zoom
                    camera.updateProjectionMatrix();
                    console.log(`[FPS] ${avgFPS.toFixed(1)} fps → zoom ${camera.zoom.toFixed(1)}x`);
                }
                // If FPS good and zoomed in, slowly zoom back out
                else if (avgFPS > this.targetFPS && camera.zoom > 1.05) {
                    camera.zoom *= 0.97;  // Very slow zoom out
                    camera.updateProjectionMatrix();
                }
            }
        };

        function animate(time) {
            requestAnimationFrame(animate);

            // Calculate delta time for smooth animations
            const deltaTime = Math.min((time - prevAnimTime) / 1000, 0.1);  // Cap at 100ms
            prevAnimTime = time;

            // FPS monitoring and adaptive zoom
            FPSMonitor.recordFrame(time);
            FPSMonitor.update(time);

            // Update frustum for culling
            camera.updateMatrixWorld();
            updateFrustum();

            // Update battle position animations
            battles.forEach(battle => battle.animatePosition(deltaTime));
            battles.forEach(battle => battle.updatePulse(time));

            // Update ShapeManager morph animations
            ShapeManager.update(time);

            // Update Sequencer (cinematic spawn pacing)
            Sequencer.update(time);

            // Update CameraDirector (orbit mode auto-rotation)
            CameraDirector.update(deltaTime * 1000);  // Pass delta in ms

            // Update AutoShowcase (shape cycling)
            AutoShowcase.update(time);

            // Always update visible count for HUD (even when paused)
            visibleCount = 0;
            battles.forEach(battle => {
                battle.inViewport = isInViewport(battle);
                if (battle.inViewport && battle.spawned) visibleCount++;
            });

            // Update battles at fixed interval
            if (playing && time - lastTime > frameInterval) {
                lastTime = time;
                globalFrame++;

                let completeCount = 0;
                let maxCycle = 0;
                let spawnedCount = 0;
                let advancedCount = 0;

                battles.forEach(battle => {
                    if (battle.spawned) spawnedCount++;
                    // CRITICAL: Only advance battles that have been spawned
                    if (battle.spawned && !battle.complete) {
                        battle.advanceFrame();
                        advancedCount++;
                    }
                    if (battle.complete) completeCount++;
                    maxCycle = Math.max(maxCycle, battle.cycle);
                });

                // Debug logging every 100 frames
                if (globalFrame % 100 === 0) {
                    console.log(`[Frame ${globalFrame}] Spawned: ${spawnedCount}, Advanced: ${advancedCount}, Complete: ${completeCount}`);
                }

                document.getElementById('complete-count').textContent = completeCount;
                document.getElementById('global-cycle').textContent = maxCycle;

                // Update detail panel if selected
                if (selectedBattle) {
                    updateDetailPanel(selectedBattle);
                }
            }

            // Update flying cards (always, regardless of playing state)
            flyingCards.forEach(card => card.update(deltaTime));
            flyingCards = flyingCards.filter(card => !card.complete);

            // Update particle explosions (always, regardless of playing state)
            particleExplosions.forEach(explosion => explosion.update(deltaTime));
            particleExplosions = particleExplosions.filter(explosion => !explosion.complete);

            // Update victory pulse animations
            battles.forEach(battle => {
                if (battle.victoryPulseStart && battle.border && battle.border.material) {
                    const elapsed = time - battle.victoryPulseStart;
                    const pulseDuration = 2000; // 2 seconds

                    if (elapsed < pulseDuration) {
                        // Pulse scale: 1.0 -> 1.3 -> 1.0 over 2 seconds
                        const progress = elapsed / pulseDuration;
                        const pulseScale = 1.0 + Math.sin(progress * Math.PI * 3) * 0.3 * (1 - progress);

                        // Brighten border color
                        const baseColor = battle.winner === 0 ? 0x00fff7 :
                                         battle.winner === 1 ? 0xff6b00 : 0xffffff;
                        const brightness = 1.0 + Math.sin(progress * Math.PI * 3) * 0.5 * (1 - progress);

                        const r = ((baseColor >> 16) & 0xff) / 255 * brightness;
                        const g = ((baseColor >> 8) & 0xff) / 255 * brightness;
                        const b = (baseColor & 0xff) / 255 * brightness;

                        battle.border.material.color.setRGB(
                            Math.min(1, r),
                            Math.min(1, g),
                            Math.min(1, b)
                        );

                        battle.border.scale.set(pulseScale, pulseScale, 1);
                    } else {
                        // Pulse complete, reset to final state
                        battle.victoryPulseStart = null;
                        battle.border.scale.set(1, 1, 1);
                        battle.border.material.color.setHex(
                            battle.winner === 0 ? 0x00fff7 :
                            battle.winner === 1 ? 0xff6b00 : 0xffffff
                        );
                    }
                }
            });

            // Update replay viewer (guard for initialization order)
            if (typeof ReplayViewer !== 'undefined') ReplayViewer.update(time);

            // Update zoom display with visible count
            const zoom = camera.zoom.toFixed(1);
            document.getElementById('zoom-level').textContent = `${zoom}x (${visibleCount} visible)`;
            document.getElementById('fps-display').textContent = FPSMonitor.getAverageFPS().toFixed(0);

            statsTracker.updateUI();

            renderer.render(scene, camera);
        }

        // ============== Raycaster for Selection ==============
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.getElementById('tooltip');

        function onMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(battles.map(b => b.mesh));

            // Clear previous hover
            if (hoveredBattle) {
                hoveredBattle.highlight(hoveredBattle === selectedBattle);
            }

            if (intersects.length > 0) {
                hoveredBattle = intersects[0].object.userData.battle;
                hoveredBattle.highlight(true);

                // Show tooltip
                tooltip.style.display = 'block';
                tooltip.style.left = event.clientX + 15 + 'px';
                tooltip.style.top = event.clientY + 15 + 'px';
                tooltip.innerHTML = `
                    <strong>${hoveredBattle.w0Llm.name}</strong> vs <strong>${hoveredBattle.w1Llm.name}</strong><br>
                    ${hoveredBattle.complete ?
                        (hoveredBattle.winner === 'tie' ? 'TIE' :
                         hoveredBattle.winner === 0 ? hoveredBattle.w0Llm.name + ' wins' :
                         hoveredBattle.w1Llm.name + ' wins') + '<br><em style="color:#ff6b00">Click to replay</em>' :
                        'In progress...'}
                `;
            } else {
                hoveredBattle = null;
                tooltip.style.display = 'none';
            }
        }

        function onClick(event) {
            if (hoveredBattle) {
                // If battle is complete, open replay viewer
                if (hoveredBattle.complete) {
                    ReplayViewer.open(hoveredBattle);
                    return;
                }

                // Otherwise, show detail panel as before
                // Deselect previous
                if (selectedBattle) {
                    selectedBattle.highlight(false);
                }

                selectedBattle = hoveredBattle;
                selectedBattle.highlight(true);

                // Show detail panel
                document.getElementById('detail-panel').style.display = 'block';
                updateDetailPanel(selectedBattle);

                // Update code panel if it's visible
                const codePanel = document.getElementById('code-panel');
                if (codePanel.classList.contains('visible')) {
                    displayWarriorCode(selectedBattle);
                }
            }
        }

        function updateDetailPanel(battle) {
            document.getElementById('detail-title').textContent =
                `${battle.w0Llm.name} vs ${battle.w1Llm.name}`;
            document.getElementById('detail-w0').textContent = battle.w0Llm.name + ':';
            document.getElementById('detail-w1').textContent = battle.w1Llm.name + ':';
            document.getElementById('detail-w0-score').textContent = battle.w0Territory;
            document.getElementById('detail-w1-score').textContent = battle.w1Territory;
            document.getElementById('detail-cycle').textContent = battle.cycle;
            document.getElementById('detail-frame').textContent =
                `${battle.currentFrame}/${battle.frames.length}`;
            document.getElementById('detail-status').textContent =
                battle.complete ?
                    (battle.winner === 'tie' ? 'TIE' :
                     battle.winner === 0 ? 'W0 Wins' : 'W1 Wins') :
                    'In Progress';
        }

        // ============== Controls ==============
        document.getElementById('play').onclick = () => {
            playing = true;
            document.getElementById('play').classList.add('active');
        };

        document.getElementById('pause').onclick = () => {
            playing = false;
            document.getElementById('play').classList.remove('active');
        };

        document.getElementById('reset').onclick = () => {
            playing = false;
            document.getElementById('play').classList.remove('active');
            globalFrame = 0;

            // Reset all battles
            battles.forEach(battle => {
                if (!battle.initialized) return;  // Skip uninitialized battles
                battle.currentFrame = 0;
                battle.core.fill(0);
                battle.w0Territory = 0;
                battle.w1Territory = 0;
                battle.cycle = 0;
                battle.complete = false;
                battle.border.material.color.set(COLORS.grid);
                battle.updateTexture();
            });

            // Reset leaderboard
            LLMS.forEach(llm => {
                leaderboard[llm.id] = { wins: 0, cards: [], streak: 0 };
            });
            lastWinner = null;
            updateLeaderboardUI();

            document.getElementById('complete-count').textContent = '0';
            document.getElementById('global-cycle').textContent = '0';
        };

        document.getElementById('fit').onclick = () => {
            camera.zoom = 1;
            camera.position.set(
                GRID_COLS * BATTLE_SPACING / 2,
                GRID_ROWS * BATTLE_SPACING / 2,
                100
            );
            controls.target.set(
                GRID_COLS * BATTLE_SPACING / 2,
                GRID_ROWS * BATTLE_SPACING / 2,
                0
            );
            controls.update();
        };

        document.getElementById('show-code').addEventListener('click', () => {
            const codePanel = document.getElementById('code-panel');
            const btn = document.getElementById('show-code');
            if (codePanel.classList.contains('visible')) {
                codePanel.classList.remove('visible');
                btn.textContent = 'Show Code';
                btn.classList.remove('active');
            } else {
                codePanel.classList.add('visible');
                btn.textContent = 'Hide Code';
                btn.classList.add('active');
                // If there's a selected battle, display its warriors
                if (selectedBattle) {
                    displayWarriorCode(selectedBattle);
                }
            }
        });
        document.getElementById('code-panel-close').addEventListener('click', () => {
            const codePanel = document.getElementById('code-panel');
            const btn = document.getElementById('show-code');
            codePanel.classList.remove('visible');
            btn.textContent = 'Show Code';
            btn.classList.remove('active');
        });

        document.getElementById('auto-shapes').addEventListener('click', () => {
            const btn = document.getElementById('auto-shapes');
            if (AutoShowcase.enabled) {
                AutoShowcase.stop();
                btn.classList.remove('active');
            } else {
                AutoShowcase.start();
                btn.classList.add('active');
            }
        });

        // ============== Window Resize ==============
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / (window.innerHeight - 120);

            // Handle both camera types
            if (camera === orthoCamera) {
                camera.left = -frustumSize * aspect / 2;
                camera.right = frustumSize * aspect / 2;
            } else if (camera === perspCamera) {
                camera.aspect = aspect;
            }
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight - 120);
        });

        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('click', onClick);

        // ============== Sequencer (Cinematic Spawn Timing) ==============
        const Sequencer = {
            // FAST pacing: quick spiral from center (total ~8s not 60s)
            stages: [
                // FAST spawn after heroes - total ~4 seconds for all battles
                { count: 4, duration: 100 },       // Heroes already spawned
                { count: 64, duration: 300 },      // Quick burst
                { count: 256, duration: 500 },     // Rapid expansion
                { count: 1024, duration: 800 },    // Fill out
                { count: 4096, duration: 1000 },   // Major fill
                { count: 8192, duration: 500 },    // Final wave - everything else
            ],
            currentStage: 0,
            spawnedCount: 0,
            stageStartTime: 0,
            started: false,
            waitingForHeroIntro: true,  // Wait for HeroIntro to finish
            heroMode: false,
            heroStartTime: 0,
            showcaseTriggered: false,
            currentHeroIndex: 0,  // Initialize here for HeroIntro access
            heroQueue: [],        // Will be populated in start()

            start(time) {
                this.started = true;
                this.stageStartTime = time;
                this.currentStage = 0;
                this.spawnedCount = 0;

                // 4 HERO BATTLES - diverse LLM matchups near center
                // Each hero gets a full intro panel before spawning
                const centerCol = Math.floor(GRID_COLS / 2);
                const centerRow = Math.floor(GRID_ROWS / 2);

                // Pick 4 positions with good LLM variety (based on col%6, row%6)
                // Hero 1: center (Claude Opus vs GPT-5.1)
                // Hero 2: offset for Claude Sonnet vs DeepSeek
                // Hero 3: offset for GPT vs KAT Coder
                // Hero 4: offset for Gemini vs DeepSeek
                this.heroQueue = [
                    centerRow * GRID_COLS + centerCol,           // Hero 1: center
                    (centerRow + 1) * GRID_COLS + (centerCol - 4), // Hero 2: down-left
                    (centerRow - 1) * GRID_COLS + (centerCol + 3), // Hero 3: up-right
                    (centerRow + 2) * GRID_COLS + (centerCol - 1), // Hero 4: further down
                ];
                this.currentHeroIndex = 0;

                // Build spiral spawn order from center outward
                this.buildSpiralOrder();

                // Mark all hero battles as spawned so spiral order skips them
                this.heroSpawnedSet = new Set(this.heroQueue);

                // DON'T activate hero here - wait for HeroIntro to finish first
                // HeroIntro.start() is called from start() in main, which sets waitingForHeroIntro
                this.spawnedCount = this.heroQueue.length;  // Pre-count heroes

                // Position camera TIGHT on hero battle at CENTER (fills viewport)
                const heroX = centerCol * BATTLE_SPACING + BATTLE_WIDTH / 2;
                const heroY = centerRow * BATTLE_SPACING + BATTLE_HEIGHT / 2;
                perspCamera.position.set(heroX, heroY, 6);  // CLOSE - fills viewport
                perspCamera.lookAt(heroX, heroY, 0);
                camera = perspCamera;
                controls.dispose();
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableRotate = false;
                controls.enableZoom = false;
                controls.enablePan = false;
                controls.target.set(heroX, heroY, 0);
                controls.update();

                console.log(`[Sequencer] 🎯 4 HEROES QUEUED at indices: ${this.heroQueue.join(', ')}`);
            },

            // Build spawn order spiraling from center outward
            buildSpiralOrder() {
                const centerCol = Math.floor(GRID_COLS / 2);
                const centerRow = Math.floor(GRID_ROWS / 2);
                const allCells = [];
                for (let r = 0; r < GRID_ROWS; r++) {
                    for (let c = 0; c < GRID_COLS; c++) {
                        const dist = Math.sqrt((c - centerCol) ** 2 + (r - centerRow) ** 2);
                        allCells.push({ idx: r * GRID_COLS + c, dist });
                    }
                }
                allCells.sort((a, b) => a.dist - b.dist);
                this.spawnOrder = allCells.map(cell => cell.idx);
                this.spawnOrderIdx = 0;
            },

            activateHero(battle, time) {
                const HERO_SCALE = 7;  // LARGE hero to fill viewport
                battle.spawn();
                battle.mesh.scale.set(HERO_SCALE, HERO_SCALE, 1);
                battle.border.scale.set(HERO_SCALE, HERO_SCALE, 1);

                // Scale LLM identity visuals for hero mode
                if (battle.identityGlow) battle.identityGlow.scale.set(HERO_SCALE, HERO_SCALE, 1);
                if (battle.w0Accent) {
                    battle.w0Accent.scale.set(HERO_SCALE, HERO_SCALE, 1);
                    battle.w0Accent.position.set(
                        battle.mesh.position.x - BATTLE_WIDTH * 0.42 * HERO_SCALE,
                        battle.mesh.position.y + BATTLE_HEIGHT * 0.42 * HERO_SCALE,
                        0.05
                    );
                }
                if (battle.w1Accent) {
                    battle.w1Accent.scale.set(HERO_SCALE, HERO_SCALE, 1);
                    battle.w1Accent.position.set(
                        battle.mesh.position.x + BATTLE_WIDTH * 0.42 * HERO_SCALE,
                        battle.mesh.position.y - BATTLE_HEIGHT * 0.42 * HERO_SCALE,
                        0.05
                    );
                }

                battle.isHero = true;
                this.heroMode = true;
                this.heroStartTime = time;
                this.currentHeroBattle = battle;

                // Move camera closer for the LARGE hero
                const pos = battle.mesh.position;
                perspCamera.position.set(pos.x, pos.y, 12);  // Closer camera for 7x scale
                perspCamera.lookAt(pos);
                controls.target.copy(pos);

                // Add glowing background ring (MASSIVE for drama)
                if (this.heroGlow) scene.remove(this.heroGlow);
                const glowGeo = new THREE.RingGeometry(6, 20, 32);  // Much bigger ring for 7x scale
                const glowMat = new THREE.MeshBasicMaterial({
                    color: 0x00fff7,
                    transparent: true,
                    opacity: 0.4,  // More visible
                    side: THREE.DoubleSide
                });
                this.heroGlow = new THREE.Mesh(glowGeo, glowMat);
                this.heroGlow.position.copy(battle.mesh.position);
                this.heroGlow.position.z = -0.5;  // Behind the battle
                scene.add(this.heroGlow);

                // Add particle field background
                if (!this.bgParticles) {
                    const particleCount = 500;
                    const positions = new Float32Array(particleCount * 3);
                    for (let i = 0; i < particleCount * 3; i += 3) {
                        positions[i] = (Math.random() - 0.5) * 50;      // x
                        positions[i + 1] = (Math.random() - 0.5) * 50;  // y
                        positions[i + 2] = (Math.random() - 0.5) * 20 - 5;  // z (behind)
                    }
                    const particleGeo = new THREE.BufferGeometry();
                    particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    const particleMat = new THREE.PointsMaterial({
                        color: 0x00fff7,
                        size: 0.1,
                        transparent: true,
                        opacity: 0.5
                    });
                    this.bgParticles = new THREE.Points(particleGeo, particleMat);
                    scene.add(this.bgParticles);
                }
                this.bgParticles.position.copy(battle.mesh.position);
            },

            update(time) {
                // Auto-start on first update call - MUST happen before waitingForHeroIntro check
                // so that heroQueue is populated for HeroIntro to use
                if (!this.started) {
                    this.start(time);
                }

                // PERF LOG: Show state every 2 seconds
                if (!this._lastLog || time - this._lastLog > 2000) {
                    this._lastLog = time;
                    console.log(`[Sequencer] state: waiting=${this.waitingForHeroIntro} hero=${this.heroMode} heroIdx=${this.currentHeroIndex}/${this.heroQueue.length} spawned=${this.spawnedCount}/${battles.length} stage=${this.currentStage}`);
                }

                // Wait for HeroIntro to finish before continuing
                if (this.waitingForHeroIntro) return;

                // HERO MODE: Pulse, then transition to next hero or end
                if (this.heroMode && this.currentHeroBattle) {
                    const heroElapsed = time - this.heroStartTime;
                    const hero = this.currentHeroBattle;

                    // Hero 1: quick (5s), Heroes 2-4: moderate (8s each) - FAST pacing
                    const heroDuration = this.currentHeroIndex === 0 ? 5000 : 8000;

                    if (heroElapsed < heroDuration) {
                        // Stable hero scale - subtle breathing at 7x scale
                        const pulse = 7.0 + Math.sin(heroElapsed * 0.0008) * 0.3;  // 6.7-7.3 range (very subtle)
                        hero.mesh.scale.set(pulse, pulse, 1);
                        hero.border.scale.set(pulse, pulse, 1);

                        // Subtle glow pulse
                        if (this.heroGlow) {
                            const glowPulse = 1.2 + Math.sin(heroElapsed * 0.001) * 0.1;
                            this.heroGlow.scale.set(glowPulse, glowPulse, 1);
                            this.heroGlow.material.opacity = 0.3 + Math.sin(heroElapsed * 0.003) * 0.15;
                            this.heroGlow.rotation.z += 0.002;
                        }

                        // Rotate particles
                        if (this.bgParticles) {
                            this.bgParticles.rotation.z += 0.001;
                        }
                    } else {
                        // Shrink current hero from 7x to 1x
                        const shrinkDuration = 600;  // Slightly longer for larger scale
                        const shrinkProgress = Math.min((heroElapsed - heroDuration) / shrinkDuration, 1);
                        const scale = 7.0 - shrinkProgress * 6.0;  // 7 → 1
                        hero.mesh.scale.set(scale, scale, 1);
                        hero.border.scale.set(scale, scale, 1);
                        if (hero.identityGlow) hero.identityGlow.scale.set(scale, scale, 1);

                        if (shrinkProgress >= 1) {
                            hero.mesh.scale.set(1, 1, 1);
                            hero.border.scale.set(1, 1, 1);
                            // Reset identity visuals to normal scale and position
                            if (hero.identityGlow) hero.identityGlow.scale.set(1, 1, 1);
                            if (hero.w0Accent) {
                                hero.w0Accent.scale.set(1, 1, 1);
                                hero.w0Accent.position.set(
                                    hero.mesh.position.x - BATTLE_WIDTH * 0.42,
                                    hero.mesh.position.y + BATTLE_HEIGHT * 0.42,
                                    0.05
                                );
                            }
                            if (hero.w1Accent) {
                                hero.w1Accent.scale.set(1, 1, 1);
                                hero.w1Accent.position.set(
                                    hero.mesh.position.x + BATTLE_WIDTH * 0.42,
                                    hero.mesh.position.y - BATTLE_HEIGHT * 0.42,
                                    0.05
                                );
                            }
                            this.currentHeroIndex++;

                            // Next hero in queue? Activate DIRECTLY (no more intro panels!)
                            if (this.currentHeroIndex < this.heroQueue.length) {
                                const nextIdx = this.heroQueue[this.currentHeroIndex];
                                const nextHero = battles[nextIdx];

                                // Direct activation - NO intro panel for heroes 2-4
                                this.cleanupHeroEffects();  // Clean up current hero's glow
                                this.activateHero(nextHero, time);
                                console.log(`[Sequencer] 🎯 HERO #${this.currentHeroIndex + 1} ACTIVATED (no intro)`);
                            } else {
                                // All heroes done - CLEANUP hero effects and START SPIRAL SPAWN
                                this.heroMode = false;
                                this.waitingForHeroIntro = false;  // Ensure this is cleared!
                                this.cleanupHeroEffects();
                                // Reset stage timing so spiral spawn starts fresh
                                this.stageStartTime = time;
                                this.currentStage = 0;
                                // Spawn all remaining battles FAST after hero mode
                                console.log('[Sequencer] 💥 ALL 4 HEROES DONE - starting RAPID spiral spawn');
                            }
                        }
                    }
                }

                // After hero phase (or if not in hero mode), continue with spiral spawn
                if (!this.heroMode) {
                    this.updateSpiralSpawn(time);
                }
            },

            // Clean up hero glow and particles when hero mode ends
            cleanupHeroEffects() {
                if (this.heroGlow) {
                    scene.remove(this.heroGlow);
                    this.heroGlow.geometry.dispose();
                    this.heroGlow.material.dispose();
                    this.heroGlow = null;
                }
                if (this.bgParticles) {
                    scene.remove(this.bgParticles);
                    this.bgParticles.geometry.dispose();
                    this.bgParticles.material.dispose();
                    this.bgParticles = null;
                }
            },

            // Continue update() after hero phase - this is the SPIRAL SPAWN phase
            // FPS-ADAPTIVE: Spawn rate adjusts to maintain smooth 30+ FPS on ANY device
            updateSpiralSpawn(time) {
                // Pull camera back smoothly after hero mode ends
                if (!this.heroMode && perspCamera.position.z < 150) {
                    perspCamera.position.z += 3;  // Faster pullback
                }

                if (this.spawnedCount >= battles.length) {
                    // All done - start AutoShowcase if not already
                    if (!AutoShowcase.enabled && !this.showcaseTriggered) {
                        this.showcaseTriggered = true;
                        console.log('[Sequencer] Spiral complete - starting AutoShowcase');
                        setTimeout(() => AutoShowcase.start(), 2000);
                    }
                    return;
                }

                // FPS-ADAPTIVE SPAWN: Adjust spawn rate based on current FPS
                const currentFPS = FPSMonitor.getAverageFPS();
                let spawnsThisFrame;

                if (currentFPS >= 50) {
                    spawnsThisFrame = 100;  // Fast device: aggressive spawn
                } else if (currentFPS >= 30) {
                    spawnsThisFrame = 50;   // Medium device: moderate spawn
                } else if (currentFPS >= 20) {
                    spawnsThisFrame = 20;   // Slow device: gentle spawn
                } else {
                    spawnsThisFrame = 5;    // Very slow: minimal spawn to recover
                }

                // Spawn battles using SPIRAL ORDER (center outward)
                const endIdx = Math.min(this.spawnedCount + spawnsThisFrame, battles.length);
                while (this.spawnedCount < endIdx) {
                    const battleIdx = this.spawnOrder[this.spawnedCount];
                    if (battles[battleIdx] && !battles[battleIdx].spawned) {
                        battles[battleIdx].spawn();
                    }
                    this.spawnedCount++;
                }

                // Log progress every 1000 spawns
                if (this.spawnedCount % 1000 === 0 || this.spawnedCount === battles.length) {
                    console.log(`[Sequencer] Spawned ${this.spawnedCount}/${battles.length} @ ${currentFPS.toFixed(0)} FPS`);
                }
            },

            getStageTarget(stageIdx = this.currentStage) {
                let total = 0;
                for (let i = 0; i <= stageIdx && i < this.stages.length; i++) {
                    total += this.stages[i].count;
                }
                return Math.min(total, battles.length);
            },

            spawnRemaining() {
                while (this.spawnedCount < battles.length) {
                    // USE SPIRAL ORDER for remaining too
                    const battleIdx = this.spawnOrder[this.spawnedCount];
                    if (battles[battleIdx] && !battles[battleIdx].spawned) {
                        battles[battleIdx].spawn();
                    }
                    this.spawnedCount++;
                }

                // All spawned - start AutoShowcase!
                if (!AutoShowcase.enabled) {
                    console.log('[Sequencer] All battles spawned - starting AutoShowcase');
                    setTimeout(() => AutoShowcase.start(), 2000);  // 2s delay before shapes cycle
                }
            },

            // Get count of spawned battles
            getSpawnedCount() {
                return this.spawnedCount;
            }
        };

        window.Sequencer = Sequencer;

        // ============== HeroIntro (LOUD Cinematic) ==============
        const HeroIntro = {
            active: false,
            skipped: false,
            metadata: null,
            codeLines: [],
            currentCodeLine: 0,
            codeTimer: null,

            // Load warrior metadata from JSON
            async loadMetadata(warriorName) {
                try {
                    // Try different naming patterns
                    const patterns = [
                        `gpu_mars/warriors/tournament_001/${warriorName}.json`,
                        `gpu_mars/warriors/tournament_001/anthropic_${warriorName}.json`,
                    ];

                    for (const url of patterns) {
                        try {
                            const resp = await fetch(url);
                            if (resp.ok) {
                                return await resp.json();
                            }
                        } catch (e) { /* try next */ }
                    }
                    return null;
                } catch (e) {
                    console.warn('[HeroIntro] Failed to load metadata:', e);
                    return null;
                }
            },

            // Extract challenge from LLM thinking (first paragraph usually echoes it)
            extractChallenge(rawResponse) {
                if (!rawResponse) return "Write a CoreWars warrior";

                // Strip <thinking> tags (may or may not have closing tag)
                const thinking = rawResponse
                    .replace(/<\/?thinking>/gi, '')
                    .trim();

                // First sentence often contains the challenge
                const firstSentence = thinking.split(/[.!?]/)[0];
                if (firstSentence && firstSentence.length < 200) {
                    return firstSentence.trim().replace(/^["']|["']$/g, '');
                }

                return "Write a warrior to defeat IMP and DWARF";
            },

            // Extract key thinking points (returns plain text, safe)
            extractThinkingText(rawResponse) {
                if (!rawResponse) return "";

                // Strip <thinking> tags (may or may not have closing tag)
                const thinking = rawResponse
                    .replace(/<\/?thinking>/gi, '')
                    .trim();

                // Get first 600 chars
                let excerpt = thinking.substring(0, 600);

                // Clean up whitespace
                excerpt = excerpt.replace(/\n\n+/g, '\n\n');
                excerpt = excerpt.replace(/\s+/g, ' ').trim();

                return `"${excerpt}..."`;
            },

            // Load .red warrior file as fallback when JSON has no code
            async loadWarriorFile(warriorName) {
                try {
                    // Map warrior names to .red files
                    const redFileMap = {
                        'anthropic_claude-opus-4.5': 'anthropic_claude-opus-4.5.red',
                        'anthropic_claude-sonnet-4.5': 'anthropic_claude-sonnet-4.5.red',
                        'openai_gpt-5.1': 'openai_gpt-5.1-chat.red',
                        'openai_gpt-5.1-chat': 'openai_gpt-5.1-chat.red',
                        'deepseek_deepseek-chat-v3-0324': 'deepseek_deepseek-chat-v3-0324.red',
                        'kwaipilot_kat-coder-pro_free': 'kwaipilot_kat-coder-pro_free.red',
                        'google_gemini-2.5-pro': 'google_gemini-2.5-pro.red',
                        'google_gemini-3-pro-preview': 'google_gemini-3-pro-preview.red'
                    };

                    const redFile = redFileMap[warriorName] || `${warriorName}.red`;
                    const url = `gpu_mars/warriors/tournament_001/${redFile}`;
                    const response = await fetch(url);

                    if (!response.ok) return null;
                    return await response.text();
                } catch (e) {
                    console.log(`[HeroIntro] Could not load .red file for ${warriorName}:`, e);
                    return null;
                }
            },

            // Format model name for display
            formatModelName(model) {
                if (!model) return "UNKNOWN";

                // Extract just the model name
                const parts = model.split('/');
                const name = parts[parts.length - 1];

                // Clean up and shorten
                return name
                    .replace(/-/g, ' ')
                    .replace(/\./g, ' ')
                    .toUpperCase()
                    .split(' ')
                    .slice(0, 3)
                    .join(' ');
            },

            // Parse code into lines with syntax highlighting hints
            parseCode(code) {
                if (!code) return [];
                return code.split('\n').map(line => {
                    let className = 'line';
                    if (line.trim().startsWith(';')) className += ' rc-comment';
                    else if (/^\w+\s/.test(line.trim()) && !/^(MOV|ADD|SUB|JMP|SPL|DAT|DJN|JMZ|JMN|CMP|SLT|SEQ|SNE)/i.test(line.trim())) {
                        className += ' rc-label';
                    } else if (/\b(MOV|ADD|SUB|JMP|SPL|DAT|DJN|JMZ|JMN|CMP|SLT|SEQ|SNE|MUL|DIV|MOD|NOP)\b/i.test(line)) {
                        className += ' rc-opcode';
                    }
                    return { text: line, className };
                });
            },

            // Start the hero intro (SIDE BY SIDE)
            async start(battle) {
                console.log('[HeroIntro] Starting side-by-side intro...');
                this.active = true;
                this.skipped = false;
                this.battle = battle;  // Store for activation after intro

                const panel = document.getElementById('hero-intro');
                panel.classList.add('active');
                panel.classList.remove('exiting');

                // Load metadata for BOTH warriors
                const w0Name = battle?.w0Llm?.warriorFile || 'anthropic_claude-opus-4.5';
                const w1Name = battle?.w1Llm?.warriorFile || 'openai_gpt-5.1';

                const [w0Meta, w1Meta] = await Promise.all([
                    this.loadMetadata(w0Name),
                    this.loadMetadata(w1Name)
                ]);

                // Populate W0 (left, cyan)
                if (w0Meta && w0Meta.extracted_redcode) {
                    const name0 = this.formatModelName(w0Meta.model);
                    const el0 = document.getElementById('hero-model-name-w0');
                    el0.textContent = name0;
                    el0.setAttribute('data-text', name0);

                    const thinkingText = w0Meta.raw_response
                        ? this.extractThinkingText(w0Meta.raw_response)
                        : '"Analyzing the battlefield..."';
                    document.getElementById('hero-thinking-w0').textContent = thinkingText;

                    this.w0Lines = this.parseCode(w0Meta.extracted_redcode);
                } else {
                    // JSON has no code - try loading the .red file directly
                    const name0 = w0Meta ? this.formatModelName(w0Meta.model) : w0Name.toUpperCase();
                    const el0 = document.getElementById('hero-model-name-w0');
                    el0.textContent = name0;
                    el0.setAttribute('data-text', name0);

                    // Try to load actual warrior code from .red file
                    const redCode = await this.loadWarriorFile(w0Name);
                    if (redCode) {
                        document.getElementById('hero-thinking-w0').textContent =
                            '"Executing battle strategy..."';
                        this.w0Lines = this.parseCode(redCode);
                    } else {
                        document.getElementById('hero-thinking-w0').textContent =
                            '"Warrior deployed to arena..."';
                        this.w0Lines = this.placeholderCode();
                    }
                }

                // Populate W1 (right, orange)
                if (w1Meta && w1Meta.extracted_redcode) {
                    const name1 = this.formatModelName(w1Meta.model);
                    const el1 = document.getElementById('hero-model-name-w1');
                    el1.textContent = name1;
                    el1.setAttribute('data-text', name1);

                    const thinkingText = w1Meta.raw_response
                        ? this.extractThinkingText(w1Meta.raw_response)
                        : '"Analyzing the battlefield..."';
                    document.getElementById('hero-thinking-w1').textContent = thinkingText;

                    this.w1Lines = this.parseCode(w1Meta.extracted_redcode);
                } else {
                    // JSON has no code - try loading the .red file directly
                    const name1 = w1Meta ? this.formatModelName(w1Meta.model) : w1Name.toUpperCase();
                    const el1 = document.getElementById('hero-model-name-w1');
                    el1.textContent = name1;
                    el1.setAttribute('data-text', name1);

                    // Try to load actual warrior code from .red file
                    const redCode = await this.loadWarriorFile(w1Name);
                    if (redCode) {
                        // Got real code! Show it
                        document.getElementById('hero-thinking-w1').textContent =
                            '"Executing battle strategy..."';
                        this.w1Lines = this.parseCode(redCode);
                    } else {
                        // No .red file either - use placeholder
                        document.getElementById('hero-thinking-w1').textContent =
                            '"Warrior deployed to arena..."';
                        this.w1Lines = this.placeholderCode();
                    }
                }

                // Animate both code panels simultaneously (slight stagger for effect)
                this.animateCodePanel('hero-code-w0', this.w0Lines, 0);
                this.animateCodePanel('hero-code-w1', this.w1Lines, 200);  // 200ms stagger

                // Set up skip handlers
                this.setupSkipHandlers();

                // Auto-advance after 3.5 seconds (quick intro, get to the battle)
                setTimeout(() => {
                    if (this.active && !this.skipped) {
                        this.finish();
                    }
                }, 3500);
            },

            animateCodePanel(containerId, codeLines, delay) {
                const codeBody = document.getElementById(containerId);
                if (!codeBody) return;

                // Clear
                while (codeBody.firstChild) {
                    codeBody.removeChild(codeBody.firstChild);
                }

                let lineIndex = 0;
                const typeNextLine = () => {
                    if (lineIndex >= codeLines.length || this.skipped) return;

                    const line = codeLines[lineIndex];
                    const div = document.createElement('div');
                    div.className = line.className;
                    div.textContent = line.text || '\u00A0';
                    div.style.animationDelay = '0s';
                    codeBody.appendChild(div);

                    lineIndex++;
                    setTimeout(typeNextLine, 60);  // FAST typing
                };

                setTimeout(typeNextLine, 100 + delay);  // Quick start
            },

            placeholderCode() {
                const lines = [
                    ';redcode',
                    ';name [Code Not Captured]',
                    ';author AI Model',
                    ';',
                    '; This warrior\'s code was not',
                    '; successfully captured from the',
                    '; LLM response. The battle still',
                    '; ran with the actual warrior.',
                    ';',
                    '; Check the warrior JSON file',
                    '; for more details.',
                    '',
                    'start   DAT.F   #0, #0',
                    '        END     start'
                ];
                return lines.map(line => ({
                    text: line,
                    className: 'line' + (line.startsWith(';') ? ' rc-comment' :
                              /\b(MOV|JMP|END|DAT)\b/.test(line) ? ' rc-opcode' : '')
                }));
            },

            setupSkipHandlers() {
                const skip = () => {
                    if (this.active && !this.skipped) {
                        this.finish();
                    }
                };

                // Click anywhere to skip
                document.getElementById('hero-intro').addEventListener('click', skip, { once: true });

                // Space to skip
                const keyHandler = (e) => {
                    if (e.code === 'Space' && this.active) {
                        e.preventDefault();
                        skip();
                        document.removeEventListener('keydown', keyHandler);
                    }
                };
                document.addEventListener('keydown', keyHandler);
            },

            finish() {
                if (this.skipped) return;
                this.skipped = true;
                this.active = false;

                console.log('[HeroIntro] Finishing...');

                // Clear any pending timers
                if (this.codeTimer) {
                    clearTimeout(this.codeTimer);
                }

                // Exit animation
                const panel = document.getElementById('hero-intro');
                panel.classList.add('exiting');

                // Remove after animation, then ACTIVATE the hero
                setTimeout(() => {
                    panel.classList.remove('active', 'exiting');
                    // Activate the current hero battle NOW (after intro done)
                    if (window.Sequencer && this.battle) {
                        const time = performance.now();
                        window.Sequencer.activateHero(this.battle, time);
                        console.log(`[HeroIntro] Activated hero #${window.Sequencer.currentHeroIndex + 1}`);
                        window.Sequencer.waitingForHeroIntro = false;
                    }
                }, 800);
            }
        };

        window.HeroIntro = HeroIntro;

        // ============== ShapeManager (3D Geometry) ==============
        const ShapeManager = {
            currentShape: 'plane',
            morphProgress: 1,  // 0-1, 1 = complete
            morphDuration: 2000,  // ms
            morphStartTime: 0,
            previousPositions: new Map(),

            // Get 3D position for a battle
            getPosition(index, total, cols = GRID_COLS, rows = GRID_ROWS) {
                switch(this.currentShape) {
                    case 'plane': return this.planePosition(index, cols, rows);
                    case 'cube': return this.cubePosition(index, total);
                    case 'sphere': return this.spherePosition(index, total);
                    case 'cylinder': return this.cylinderPosition(index, total, rows);
                    case 'heart': return this.heartPosition(index, total);
                    case 'pear': return this.pearPosition(index, total);
                    case 'oval': return this.ovalPosition(index, total);
                    case 'torus': return this.torusPosition(index, total);
                    case 'helix': return this.helixPosition(index, total);
                    case 'galaxy': return this.galaxyPosition(index, total);
                    case 'grapes': return this.grapesPosition(index, total);
                    case 'tornado': return this.tornadoPosition(index, total);
                    default: return this.planePosition(index, cols, rows);
                }
            },

            // PLANE: Current flat grid (z=0)
            planePosition(index, cols, rows) {
                const col = index % cols;
                const row = Math.floor(index / cols);
                return new THREE.Vector3(
                    col * BATTLE_SPACING + BATTLE_WIDTH / 2,
                    row * BATTLE_SPACING + BATTLE_HEIGHT / 2,
                    0
                );
            },

            // SPHERE: Golden angle distribution on sphere surface
            spherePosition(index, total) {
                const goldenAngle = Math.PI * (3 - Math.sqrt(5));
                const theta = goldenAngle * index;
                const y = 1 - (index / (total - 1 || 1)) * 2;
                const radiusAtY = Math.sqrt(1 - y * y);
                return new THREE.Vector3(
                    Math.cos(theta) * radiusAtY * SPHERE_RADIUS,
                    y * SPHERE_RADIUS,
                    Math.sin(theta) * radiusAtY * SPHERE_RADIUS
                );
            },

            // CUBE: Distribute across 6 faces
            cubePosition(index, total) {
                const size = 80;
                const perFace = Math.ceil(total / 6);
                const face = Math.floor(index / perFace);
                const faceIndex = index % perFace;
                const gridSize = Math.ceil(Math.sqrt(perFace));
                const fx = (faceIndex % gridSize) / gridSize - 0.5;
                const fy = Math.floor(faceIndex / gridSize) / gridSize - 0.5;

                const positions = [
                    new THREE.Vector3(size, fx * size * 2, fy * size * 2),
                    new THREE.Vector3(-size, fx * size * 2, fy * size * 2),
                    new THREE.Vector3(fx * size * 2, size, fy * size * 2),
                    new THREE.Vector3(fx * size * 2, -size, fy * size * 2),
                    new THREE.Vector3(fx * size * 2, fy * size * 2, size),
                    new THREE.Vector3(fx * size * 2, fy * size * 2, -size),
                ];
                return positions[face % 6];
            },

            // CYLINDER: Wrap around vertical axis
            cylinderPosition(index, total, rows) {
                const radius = 80;
                const height = 150;
                const col = index % GRID_COLS;
                const row = Math.floor(index / GRID_COLS);
                const theta = (col / GRID_COLS) * Math.PI * 2;
                const y = (row / rows - 0.5) * height;
                return new THREE.Vector3(
                    Math.cos(theta) * radius,
                    y,
                    Math.sin(theta) * radius
                );
            },

            // HEART: Parametric heart surface (cardioid)
            // Uses: x = 16sin³(t), y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
            heartPosition(index, total) {
                const scale = 6;
                // Map index to u,v on surface (like sphere, but heart equation)
                const goldenAngle = Math.PI * (3 - Math.sqrt(5));
                const t = goldenAngle * index;
                const v = 1 - (index / (total - 1 || 1)) * 2;  // -1 to 1

                // Parametric heart equations
                const sinT = Math.sin(t);
                const cosT = Math.cos(t);
                const x = 16 * Math.pow(sinT, 3);
                const y = 13 * cosT - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);

                // Add depth variation based on v parameter
                const z = v * 30;  // Front-to-back layering

                return new THREE.Vector3(x * scale, y * scale, z);
            },

            // PEAR: Hollow point design - concave front expands on impact
            // Like a hollow point bullet: wide base, hollow cavity at tip
            pearPosition(index, total) {
                const height = 150;
                const maxRadius = 70;
                const goldenAngle = Math.PI * (3 - Math.sqrt(5));

                // Map index to y position (bottom to top)
                const normalizedIndex = index / (total - 1 || 1);
                const y = normalizedIndex * height - height / 2;
                const normalizedY = (y + height / 2) / height;  // 0 at bottom, 1 at top

                // Hollow point profile:
                // - Wide base (bottom)
                // - Tapers toward top
                // - HOLLOW CAVITY at the very top (radius increases again)
                let radius;
                if (normalizedY < 0.7) {
                    // Main body: wide base tapering up
                    const taper = Math.pow(1 - normalizedY / 0.7, 0.5);
                    radius = maxRadius * (0.3 + taper * 0.7);
                } else {
                    // HOLLOW POINT: cavity opens up at tip
                    const cavityDepth = (normalizedY - 0.7) / 0.3;  // 0 to 1 in top 30%
                    const cavityRadius = Math.sin(cavityDepth * Math.PI) * 0.6;  // Opens then closes
                    const baseRadius = maxRadius * 0.3 * (1 - cavityDepth * 0.5);
                    radius = baseRadius + maxRadius * cavityRadius;
                }

                // Theta distributes points around the pear at each height
                const theta = goldenAngle * index;

                return new THREE.Vector3(
                    Math.cos(theta) * radius,
                    y,
                    Math.sin(theta) * radius
                );
            },

            // MORPH: Animate transition between shapes
            morphTo(newShape) {
                if (newShape === this.currentShape) return;

                // Store current positions
                this.previousPositions.clear();
                battles.forEach((b, i) => {
                    this.previousPositions.set(i, b.mesh.position.clone());
                });

                this.currentShape = newShape;
                this.morphProgress = 0;
                this.morphStartTime = performance.now();
                console.log(`[ShapeManager] Morphing to ${newShape}`);
            },

            // Update morph animation (call from animate loop)
            update(time) {
                if (this.morphProgress >= 1) return;

                const elapsed = time - this.morphStartTime;
                this.morphProgress = Math.min(1, elapsed / this.morphDuration);
                const eased = this.easeInOutCubic(this.morphProgress);

                battles.forEach((b, i) => {
                    const start = this.previousPositions.get(i);
                    if (!start) return;

                    const end = this.getPosition(i, battles.length);
                    b.mesh.position.lerpVectors(start, end, eased);
                    b.border.position.copy(b.mesh.position);

                    // Move identity visuals with the battle in 3D space
                    if (b.identityGlow) {
                        b.identityGlow.position.copy(b.mesh.position);
                        b.identityGlow.position.z -= 0.1;  // Slightly behind
                    }
                    if (b.w0Accent) {
                        b.w0Accent.position.set(
                            b.mesh.position.x - BATTLE_WIDTH * 0.42,
                            b.mesh.position.y + BATTLE_HEIGHT * 0.42,
                            b.mesh.position.z + 0.05
                        );
                    }
                    if (b.w1Accent) {
                        b.w1Accent.position.set(
                            b.mesh.position.x + BATTLE_WIDTH * 0.42,
                            b.mesh.position.y - BATTLE_HEIGHT * 0.42,
                            b.mesh.position.z + 0.05
                        );
                    }

                    // Orient mesh: face outward for sphere/cylinder, face camera for plane/cube
                    if (this.currentShape === 'sphere' || this.currentShape === 'cylinder') {
                        b.mesh.lookAt(0, b.mesh.position.y, 0);
                        // Orient identity elements too
                        if (b.identityGlow) b.identityGlow.lookAt(0, b.mesh.position.y, 0);
                        if (b.w0Accent) b.w0Accent.lookAt(0, b.mesh.position.y, 0);
                        if (b.w1Accent) b.w1Accent.lookAt(0, b.mesh.position.y, 0);
                    } else {
                        b.mesh.rotation.set(0, 0, 0);
                        if (b.identityGlow) b.identityGlow.rotation.set(0, 0, 0);
                        if (b.w0Accent) b.w0Accent.rotation.set(0, 0, 0);
                        if (b.w1Accent) b.w1Accent.rotation.set(0, 0, 0);
                    }
                });
            },

            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }
        };

        window.ShapeManager = ShapeManager;

        // ============== CameraDirector (Cinematography) ==============
        const CameraDirector = {
            mode: 'follow',  // 'follow', 'orbit', 'overview'
            orbitAngle: 0,
            orbitSpeed: 0.0003,
            orbitRadius: 200,

            // Camera position presets for dynamic cinematography
            positions: [
                { name: 'wide-high', pos: { x: 0, y: 120, z: 250 }, radius: 250, speed: 0.0002 },
                { name: 'close-orbit', pos: { x: 0, y: 40, z: 150 }, radius: 150, speed: 0.0005 },
                { name: 'top-down', pos: { x: 0, y: 200, z: 80 }, radius: 80, speed: 0.0003 },
                { name: 'dramatic-low', pos: { x: 0, y: 20, z: 200 }, radius: 200, speed: 0.0004 },
                { name: 'side-medium', pos: { x: 180, y: 60, z: 0 }, radius: 180, speed: 0.0003 },
                { name: 'dutch-angle', pos: { x: 120, y: 150, z: 120 }, radius: 180, speed: 0.00025 }
            ],
            currentPositionIndex: 0,
            positionChangeInterval: 4000,  // 4 seconds per position
            lastPositionChange: 0,

            // Smooth transition state
            transitioning: false,
            transitionStart: 0,
            transitionDuration: 1500,  // 1.5s smooth transition
            startPos: { x: 0, y: 0, z: 0 },
            targetPos: { x: 0, y: 0, z: 0 },
            startRadius: 200,
            targetRadius: 200,
            startSpeed: 0.0003,
            targetSpeed: 0.0003,

            setMode(newMode) {
                this.mode = newMode;
                updateCameraModeDisplay();
                console.log(`[CameraDirector] Mode: ${newMode}`);

                // Initialize position cycling when entering orbit mode
                if (newMode === 'orbit') {
                    this.lastPositionChange = performance.now();
                    this.currentPositionIndex = 0;
                    const pos = this.positions[0];
                    this.orbitRadius = pos.radius;
                    this.orbitSpeed = pos.speed;
                }
            },

            // Smooth interpolation (easing function)
            easeInOutQuad(t) {
                return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            },

            // Linear interpolation
            lerp(a, b, t) {
                return a + (b - a) * t;
            },

            update(deltaTime) {
                if (this.mode === 'orbit') {
                    const now = performance.now();

                    // Check if it's time to change camera position
                    if (!this.transitioning && (now - this.lastPositionChange) > this.positionChangeInterval) {
                        this.startTransition(now);
                    }

                    // Handle smooth transition between positions
                    if (this.transitioning) {
                        const elapsed = now - this.transitionStart;
                        const progress = Math.min(elapsed / this.transitionDuration, 1.0);
                        const t = this.easeInOutQuad(progress);

                        // Interpolate base position
                        const baseX = this.lerp(this.startPos.x, this.targetPos.x, t);
                        const baseY = this.lerp(this.startPos.y, this.targetPos.y, t);
                        const baseZ = this.lerp(this.startPos.z, this.targetPos.z, t);

                        // Interpolate orbit parameters
                        this.orbitRadius = this.lerp(this.startRadius, this.targetRadius, t);
                        this.orbitSpeed = this.lerp(this.startSpeed, this.targetSpeed, t);

                        if (progress >= 1.0) {
                            this.transitioning = false;
                            console.log(`[CameraDirector] Transition complete to ${this.positions[this.currentPositionIndex].name}`);
                        }
                    }

                    // Apply orbit rotation
                    this.orbitAngle += this.orbitSpeed * deltaTime;
                    const orbitX = Math.sin(this.orbitAngle) * this.orbitRadius;
                    const orbitZ = Math.cos(this.orbitAngle) * this.orbitRadius;

                    // Get base position (current or interpolated)
                    let basePos;
                    if (this.transitioning) {
                        const elapsed = performance.now() - this.transitionStart;
                        const progress = Math.min(elapsed / this.transitionDuration, 1.0);
                        const t = this.easeInOutQuad(progress);
                        basePos = {
                            x: this.lerp(this.startPos.x, this.targetPos.x, t),
                            y: this.lerp(this.startPos.y, this.targetPos.y, t),
                            z: this.lerp(this.startPos.z, this.targetPos.z, t)
                        };
                    } else {
                        basePos = this.positions[this.currentPositionIndex].pos;
                    }

                    // Combine base position with orbit
                    perspCamera.position.x = basePos.x + orbitX * 0.3;  // 30% orbit influence
                    perspCamera.position.y = basePos.y;
                    perspCamera.position.z = basePos.z + orbitZ * 0.3;
                    perspCamera.lookAt(0, 0, 0);
                }
            },

            startTransition(now) {
                this.transitioning = true;
                this.transitionStart = now;
                this.lastPositionChange = now;

                // Save current state
                this.startPos = { ...this.positions[this.currentPositionIndex].pos };
                this.startRadius = this.orbitRadius;
                this.startSpeed = this.orbitSpeed;

                // Move to next position
                this.currentPositionIndex = (this.currentPositionIndex + 1) % this.positions.length;
                const nextPos = this.positions[this.currentPositionIndex];

                this.targetPos = { ...nextPos.pos };
                this.targetRadius = nextPos.radius;
                this.targetSpeed = nextPos.speed;

                console.log(`[CameraDirector] Starting transition to ${nextPos.name}`);
            }
        };

        window.CameraDirector = CameraDirector;

        // ============== AutoShowcase (Shape Cycling) ==============
        const AutoShowcase = {
            shapes: ['sphere', 'pear', 'heart', 'cylinder', 'cube'],
            currentIndex: 0,
            interval: 12000,  // 12s per shape
            timer: 0,
            enabled: false,

            start() {
                this.enabled = true;
                this.currentIndex = 0;
                this.timer = performance.now();
                // Start with sphere
                ShapeManager.morphTo('sphere');
                CameraDirector.setMode('orbit');
                updateShapeButtons('sphere');
                switchToPerspective();
                console.log('[AutoShowcase] Started - cycling shapes every 12s');
            },

            stop() {
                this.enabled = false;
                console.log('[AutoShowcase] Stopped');
            },

            update(time) {
                if (!this.enabled) return;

                if (time - this.timer > this.interval) {
                    this.timer = time;
                    this.currentIndex = (this.currentIndex + 1) % this.shapes.length;
                    const nextShape = this.shapes[this.currentIndex];

                    ShapeManager.morphTo(nextShape);
                    updateShapeButtons(nextShape);
                    console.log(`[AutoShowcase] Morphing to ${nextShape}`);
                }
            }
        };

        window.AutoShowcase = AutoShowcase;

        // Helper to switch to perspective camera
        function switchToPerspective() {
            if (camera !== perspCamera) {
                camera = perspCamera;
                perspCamera.position.set(0, 50, 200);
                controls.dispose();
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableRotate = true;
                controls.enablePan = false;
                controls.target.set(0, 0, 0);
                controls.update();
            }
        }

        // Camera mode display update
        function updateCameraModeDisplay() {
            const el = document.getElementById('camera-mode');
            if (el) {
                el.textContent = `CAM: ${CameraDirector.mode}`;
            }
        }

        // ============== Shape Button Handlers ==============
        function updateShapeButtons(activeShape) {
            ['plane', 'cube', 'sphere', 'cylinder', 'heart', 'pear'].forEach(shape => {
                const btn = document.getElementById(`shape-${shape}`);
                if (btn) btn.classList.toggle('active', shape === activeShape);
            });
        }

        // Wire up shape toggle buttons
        document.getElementById('shape-plane').onclick = () => {
            console.log('[Shape] PLANE clicked - morphing...');
            Sequencer.heroMode = false;
            Sequencer.waitingForHeroIntro = false;
            ShapeManager.morphTo('plane');
            CameraDirector.setMode('follow');
            updateShapeButtons('plane');
            // Switch to ortho camera for plane
            if (camera !== orthoCamera) {
                camera = orthoCamera;
                controls.dispose();
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableRotate = false;
                controls.screenSpacePanning = true;
                controls.minZoom = 0.1;
                controls.maxZoom = 20;
                controls.update();
            }
        };

        document.getElementById('shape-cube').onclick = () => {
            console.log('[Shape] CUBE clicked - morphing...');
            // Force exit hero mode to allow shape change
            Sequencer.heroMode = false;
            Sequencer.waitingForHeroIntro = false;
            ShapeManager.morphTo('cube');
            CameraDirector.setMode('orbit');
            updateShapeButtons('cube');
            // Switch to perspective camera for 3D
            if (camera !== perspCamera) {
                camera = perspCamera;
                perspCamera.position.set(0, 100, 200);
                controls.dispose();
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableRotate = true;
                controls.enablePan = false;
                controls.target.set(0, 0, 0);
                controls.update();
            }
        };

        document.getElementById('shape-sphere').onclick = () => {
            console.log('[Shape] SPHERE clicked - morphing...');
            // Force exit hero mode to allow shape change
            Sequencer.heroMode = false;
            Sequencer.waitingForHeroIntro = false;
            ShapeManager.morphTo('sphere');
            CameraDirector.setMode('orbit');
            updateShapeButtons('sphere');
            // Switch to perspective camera for 3D
            if (camera !== perspCamera) {
                camera = perspCamera;
                perspCamera.position.set(0, SPHERE_RADIUS * 0.5, SPHERE_RADIUS * 2);
                controls.dispose();
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableRotate = true;
                controls.enablePan = false;
                controls.minDistance = SPHERE_RADIUS * 1.2;
                controls.maxDistance = SPHERE_RADIUS * 4;
                controls.target.set(0, 0, 0);
                controls.update();
            }
        };

        document.getElementById('shape-cylinder').onclick = () => {
            console.log('[Shape] CYLINDER clicked - morphing...');
            Sequencer.heroMode = false;
            Sequencer.waitingForHeroIntro = false;
            ShapeManager.morphTo('cylinder');
            CameraDirector.setMode('orbit');
            updateShapeButtons('cylinder');
            // Switch to perspective camera for 3D
            if (camera !== perspCamera) {
                camera = perspCamera;
                perspCamera.position.set(0, 50, 180);
                controls.dispose();
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableRotate = true;
                controls.enablePan = false;
                controls.target.set(0, 0, 0);
                controls.update();
            }
        };

        document.getElementById('shape-heart').onclick = () => {
            console.log('[Shape] HEART clicked - morphing...');
            Sequencer.heroMode = false;
            Sequencer.waitingForHeroIntro = false;
            ShapeManager.morphTo('heart');
            CameraDirector.setMode('orbit');
            updateShapeButtons('heart');
            // Switch to perspective camera for 3D
            if (camera !== perspCamera) {
                camera = perspCamera;
                perspCamera.position.set(0, 50, 200);
                controls.dispose();
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableRotate = true;
                controls.enablePan = false;
                controls.target.set(0, 0, 0);
                controls.update();
            }
        };

        document.getElementById('shape-pear').onclick = () => {
            console.log('[Shape] PEAR clicked - morphing...');
            Sequencer.heroMode = false;
            Sequencer.waitingForHeroIntro = false;
            ShapeManager.morphTo('pear');
            CameraDirector.setMode('orbit');
            updateShapeButtons('pear');
            // Switch to perspective camera for 3D
            if (camera !== perspCamera) {
                camera = perspCamera;
                perspCamera.position.set(0, 50, 200);
                controls.dispose();
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableRotate = true;
                controls.enablePan = false;
                controls.target.set(0, 0, 0);
                controls.update();
            }
        };

        // ============== Start ==============
        function start() {
            console.log('🚀 START() called');

            // Create all battles
            initializeGrid();
            console.log(`✅ Created ${battles.length} battles`);

            // Hide loading overlay now that battles are ready
            const overlay = document.getElementById('loading-overlay');
            if (overlay) overlay.classList.add('hidden');

            // Get center battle for hero intro
            const centerCol = Math.floor(GRID_COLS / 2);
            const centerRow = Math.floor(GRID_ROWS / 2);
            const centerIdx = centerRow * GRID_COLS + centerCol;
            const heroBattle = battles[centerIdx];

            // 🎬 HERO INTRO: Show LLM thinking before battle starts
            if (heroBattle && window.HeroIntro) {
                console.log('🎬 Starting Hero Intro for center battle');
                window.HeroIntro.start(heroBattle);
            } else {
                // Fallback: skip intro if no battle or HeroIntro not ready
                console.warn('⚠️ No hero battle or HeroIntro not ready, skipping intro');
                if (window.Sequencer) {
                    window.Sequencer.waitingForHeroIntro = false;
                }
            }

            // Start animation (Sequencer waits for HeroIntro to finish)
            animate(0);

            console.log('LLMs:', LLMS.map(l => l.name).join(', '));
        }

        // NOTE: start() moved after ReplayViewer definition to avoid TDZ error

        // ============== Replay System ==============
        const ReplayViewer = {
            modal: null,
            canvas: null,
            renderer: null,
            scene: null,
            camera: null,
            battle: null,
            replayFrame: 0,
            playing: false,
            lastFrameTime: 0,
            frameInterval: 50,  // 20 fps for replay (slower than normal)
            texture: null,
            textureData: null,
            mesh: null,

            init() {
                this.modal = document.getElementById('replay-modal');
                const container = document.getElementById('replay-canvas-container');

                // Create replay renderer
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x010102);  // Match main scene background

                // Ortho camera for 2D view
                const aspect = 1200 / 600;
                this.camera = new THREE.OrthographicCamera(
                    -50, 50, 50 / aspect, -50 / aspect, 0.1, 100
                );
                this.camera.position.z = 10;

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(1200, 600);
                container.appendChild(this.renderer.domElement);

                // Create texture for battle display
                this.textureData = new Uint8Array(CELL_WIDTH * CELL_HEIGHT * 4);
                this.texture = new THREE.DataTexture(
                    this.textureData, CELL_WIDTH, CELL_HEIGHT, THREE.RGBAFormat
                );
                this.texture.magFilter = THREE.NearestFilter;
                this.texture.minFilter = THREE.NearestFilter;

                // Create mesh
                const geometry = new THREE.PlaneGeometry(80, 40);
                const material = new THREE.MeshBasicMaterial({ map: this.texture });
                this.mesh = new THREE.Mesh(geometry, material);
                this.scene.add(this.mesh);

                // Wire up controls
                document.getElementById('replay-close').onclick = () => this.close();
                document.getElementById('replay-play').onclick = () => this.play();
                document.getElementById('replay-pause').onclick = () => this.pause();
                document.getElementById('replay-restart').onclick = () => this.restart();

                // Timeline click to seek
                document.getElementById('replay-timeline').onclick = (e) => {
                    const rect = e.target.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const percent = x / rect.width;
                    this.seek(percent);
                };

                // Resize handler
                window.addEventListener('resize', () => this.onResize());
            },

            open(battle) {
                if (!battle.complete) {
                    console.log('Cannot replay - battle not complete');
                    return;
                }

                this.battle = battle;
                this.replayFrame = 0;
                this.playing = false;
                this.lastFrameTime = 0;

                // Update title
                document.getElementById('replay-title').textContent =
                    `${battle.w0Llm.name} vs ${battle.w1Llm.name}`;
                document.getElementById('replay-w0').textContent = battle.w0Llm.name;
                document.getElementById('replay-w1').textContent = battle.w1Llm.name;

                // Show modal
                this.modal.classList.add('visible');

                // Render first frame
                this.renderFrame();
                this.updateStats();

                // Auto-play
                this.play();

                // Adjust canvas size
                this.onResize();

                console.log(`Replaying: ${battle.w0Llm.name} vs ${battle.w1Llm.name}, ${battle.frames.length} frames`);
            },

            close() {
                this.pause();
                this.modal.classList.remove('visible');
                this.battle = null;
            },

            play() {
                this.playing = true;
                document.getElementById('replay-play').classList.add('active');
                document.getElementById('replay-pause').classList.remove('active');
                this.lastFrameTime = performance.now();
            },

            pause() {
                this.playing = false;
                document.getElementById('replay-play').classList.remove('active');
                document.getElementById('replay-pause').classList.add('active');
            },

            restart() {
                this.replayFrame = 0;
                this.renderFrame();
                this.updateStats();
                this.play();
            },

            seek(percent) {
                this.replayFrame = Math.floor(percent * (this.battle.frames.length - 1));
                this.replayFrame = Math.max(0, Math.min(this.replayFrame, this.battle.frames.length - 1));
                this.renderFrame();
                this.updateStats();
            },

            update(time) {
                if (!this.battle || !this.playing) return;

                if (time - this.lastFrameTime > this.frameInterval) {
                    this.lastFrameTime = time;

                    this.replayFrame++;
                    if (this.replayFrame >= this.battle.frames.length) {
                        this.replayFrame = this.battle.frames.length - 1;
                        this.pause();
                    }

                    this.renderFrame();
                    this.updateStats();
                }

                this.renderer.render(this.scene, this.camera);
            },

            renderFrame() {
                if (!this.battle || this.replayFrame >= this.battle.frames.length) return;

                // Reconstruct core state up to this frame
                const core = new Uint8Array(CORE_SIZE);

                for (let i = 0; i <= this.replayFrame; i++) {
                    const frame = this.battle.frames[i];
                    if (frame.isKeyframe && frame.coreSnapshot) {
                        core.set(frame.coreSnapshot);
                    } else {
                        for (const [addr, value] of frame.deltas) {
                            core[addr] = value;
                        }
                    }
                }

                // Render to texture
                const deadColor = [2, 2, 4, 255];        // Much darker dead cells for maximum contrast
                const w0Color = [0, 255, 255, 255];      // Pure bright cyan (removed green tint)
                const w1Color = [255, 160, 0, 255];      // Brighter orange (boosted middle value)

                for (let i = 0; i < CORE_SIZE; i++) {
                    const pi = i * 4;
                    const v = core[i];
                    const color = v === 1 ? w0Color : v === 2 ? w1Color : deadColor;
                    this.textureData[pi] = color[0];
                    this.textureData[pi + 1] = color[1];
                    this.textureData[pi + 2] = color[2];
                    this.textureData[pi + 3] = color[3];
                }
                this.texture.needsUpdate = true;
            },

            updateStats() {
                if (!this.battle) return;

                const frame = this.battle.frames[this.replayFrame];
                if (!frame) return;

                document.getElementById('replay-frame').textContent =
                    `${this.replayFrame + 1}/${this.battle.frames.length}`;
                document.getElementById('replay-cycle').textContent = frame.cycle;
                document.getElementById('replay-w0-score').textContent = frame.w0;
                document.getElementById('replay-w1-score').textContent = frame.w1;

                // Update progress bar
                const percent = (this.replayFrame / (this.battle.frames.length - 1)) * 100;
                document.getElementById('replay-progress').style.width = `${percent}%`;
            },

            onResize() {
                if (!this.renderer) return;
                const container = document.getElementById('replay-canvas-container');
                const width = container.clientWidth;
                const height = container.clientHeight;

                this.renderer.setSize(width, height);

                const aspect = width / height;
                this.camera.left = -50;
                this.camera.right = 50;
                this.camera.top = 50 / aspect;
                this.camera.bottom = -50 / aspect;
                this.camera.updateProjectionMatrix();
            }
        };

        // Start the arena (after all definitions to avoid TDZ errors)
        start();

        // Expose key objects for testing
        window.camera = camera;
        window.battles = battles;
        window.scene = scene;

        // Initialize replay viewer on load
        window.addEventListener('load', () => {
            ReplayViewer.init();

            // Initialize tournament selector UI
            if (typeof initTournamentSelector !== 'undefined') {
                initTournamentSelector().then(() => {
                    // After selector is ready, update info when tournament loads
                    if (typeof updateTournamentInfo !== 'undefined') {
                        // Will be called by initTournamentLoader after data is loaded
                        const originalShowStats = window.showTournamentStats;
                        window.showTournamentStats = function() {
                            if (originalShowStats) originalShowStats();
                            if (currentTournamentPath) {
                                updateTournamentInfo(currentTournamentPath);
                            }
                        };
                    }
                });
            }

            // Load tournament results
            if (typeof initTournamentLoader !== 'undefined') {
                initTournamentLoader(LLMS, leaderboard, updateLeaderboardUI).then(() => {
                    // Update tournament info display after initial load
                    if (typeof updateTournamentInfo !== 'undefined' && currentTournamentPath) {
                        updateTournamentInfo(currentTournamentPath);
                    }
                });
            }
        });

</script>

    <!-- Replay Modal -->
    <div id="replay-modal">
        <div id="replay-container">
            <div id="replay-header">
                <div id="replay-title">Battle Replay</div>
                <button id="replay-close">Close</button>
            </div>
            <div id="replay-canvas-container"></div>
            <div id="replay-controls">
                <button id="replay-play">Play</button>
                <button id="replay-pause">Pause</button>
                <button id="replay-restart">Restart</button>
                <div id="replay-timeline">
                    <div id="replay-progress"></div>
                </div>
                <div id="replay-stats">
                    <span class="stat">Frame: <span class="stat-value" id="replay-frame">0/0</span></span>
                    <span class="stat">Cycle: <span class="stat-value" id="replay-cycle">0</span></span>
                    <span class="stat"><span class="w0-color" id="replay-w0">W0</span>: <span class="stat-value" id="replay-w0-score">0</span></span>
                    <span class="stat"><span class="w1-color" id="replay-w1">W1</span>: <span class="stat-value" id="replay-w1-score">0</span></span>
                </div>
            </div>
        </div>
    </div>

</body>
</html>
