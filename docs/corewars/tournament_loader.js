/**
 * Tournament Loader Module
 * Loads tournament results from JSON files and updates arena leaderboard
 *
 * Usage:
 *   const loader = new TournamentLoader();
 *   await loader.loadLatestTournament();
 *   loader.populateLeaderboard(llmsArray);
 */

class TournamentLoader {
    constructor() {
        this.tournamentData = null;
        this.rankings = {};
        this.matchupStats = {};
    }

    /**
     * Load tournament data from a JSON file
     * @param {string} filePath - Path to tournament JSON file (relative to HTML)
     * @returns {Promise<Object>} Tournament data
     */
    async loadTournament(filePath) {
        try {
            const response = await fetch(filePath);
            if (!response.ok) {
                throw new Error(`Failed to load tournament: ${response.statusText}`);
            }
            this.tournamentData = await response.json();
            this.processTournamentData();
            return this.tournamentData;
        } catch (error) {
            console.error('Error loading tournament:', error);
            return null;
        }
    }

    /**
     * Load the latest tournament file
     * Attempts to load from var/tournaments/ directory using manifest
     * @returns {Promise<Object>} Latest tournament data or null
     */
    async loadLatestTournament() {
        // Try to load from manifest.json (generated by generate_tournament_manifest.py)
        try {
            console.log('[TournamentLoader] Fetching manifest...');
            const response = await fetch('var/tournaments/manifest.json');
            if (response.ok) {
                const manifest = await response.json();
                console.log('[TournamentLoader] Manifest loaded:', manifest);
                if (manifest.tournaments && manifest.tournaments.length > 0) {
                    // First tournament in manifest is latest
                    const latestPath = manifest.tournaments[0].path;
                    console.log('[TournamentLoader] Loading latest tournament:', latestPath);
                    return await this.loadTournament(latestPath);
                }
            }
        } catch (error) {
            console.warn('Could not load tournament manifest:', error);
        }

        // Fallback: try directory listing (works only if server supports it)
        try {
            const response = await fetch('var/tournaments/');
            if (response.ok) {
                const html = await response.text();
                // Extract tournament filenames from directory listing
                const matches = html.match(/tournament_(\d{8}_\d{6})\.json/g);
                if (matches && matches.length > 0) {
                    // Sort to get latest
                    const latest = matches.sort().pop();
                    return await this.loadTournament(`var/tournaments/${latest}`);
                }
            }
        } catch (error) {
            console.warn('Could not auto-discover tournament files via directory listing');
        }

        // Last resort fallback
        console.warn('All discovery methods failed, trying default path');
        return await this.loadTournament('var/tournaments/tournament_latest.json');
    }

    /**
     * Process tournament data to calculate rankings and statistics
     */
    processTournamentData() {
        if (!this.tournamentData || !this.tournamentData.matchups) {
            console.error('Invalid tournament data structure');
            return;
        }

        // Initialize rankings for each warrior
        const rankings = {};
        this.tournamentData.warriors.forEach(warrior => {
            rankings[warrior] = {
                warrior,
                wins: 0,
                losses: 0,
                ties: 0,
                battleCount: 0,
                winRate: 0,
                opponents: {}
            };
        });

        // Process each matchup
        this.tournamentData.matchups.forEach(matchup => {
            // Skip matchups with errors
            if (matchup.error) {
                return;
            }

            const { w1, w2, w1_wins, w2_wins, ties, w1_pct, w2_pct } = matchup;

            // Initialize opponent stats if needed
            if (!rankings[w1].opponents[w2]) {
                rankings[w1].opponents[w2] = { wins: 0, losses: 0, ties: 0 };
            }
            if (!rankings[w2].opponents[w1]) {
                rankings[w2].opponents[w1] = { wins: 0, losses: 0, ties: 0 };
            }

            // Update stats for w1
            rankings[w1].wins += w1_wins;
            rankings[w1].losses += w2_wins;
            rankings[w1].ties += ties;
            rankings[w1].battleCount += matchup.battles;
            rankings[w1].opponents[w2].wins += w1_wins;
            rankings[w1].opponents[w2].losses += w2_wins;
            rankings[w1].opponents[w2].ties += ties;

            // Update stats for w2
            rankings[w2].wins += w2_wins;
            rankings[w2].losses += w1_wins;
            rankings[w2].ties += ties;
            rankings[w2].battleCount += matchup.battles;
            rankings[w2].opponents[w1].wins += w2_wins;
            rankings[w2].opponents[w1].losses += w1_wins;
            rankings[w2].opponents[w1].tie += ties;
        });

        // Calculate win rates
        Object.keys(rankings).forEach(warrior => {
            const stats = rankings[warrior];
            if (stats.battleCount > 0) {
                stats.winRate = ((stats.wins / stats.battleCount) * 100).toFixed(1);
            }
        });

        this.rankings = rankings;
        this.sortedRankings = Object.values(rankings).sort((a, b) => b.wins - a.wins);
    }

    /**
     * Get rankings sorted by wins
     * @returns {Array} Sorted array of warrior rankings
     */
    getRankings() {
        return this.sortedRankings || [];
    }

    /**
     * Get stats for a specific warrior
     * @param {string} warrior - Warrior name
     * @returns {Object} Warrior statistics
     */
    getWarriorStats(warrior) {
        return this.rankings[warrior] || null;
    }

    /**
     * Get head-to-head stats between two warriors
     * @param {string} w1 - First warrior
     * @param {string} w2 - Second warrior
     * @returns {Object} Head-to-head statistics
     */
    getHeadToHead(w1, w2) {
        const w1Stats = this.rankings[w1];
        const w2Stats = this.rankings[w2];

        if (!w1Stats || !w2Stats) return null;

        const w1VsW2 = w1Stats.opponents[w2] || { wins: 0, losses: 0, ties: 0 };
        return {
            warrior1: w1,
            warrior2: w2,
            w1Wins: w1VsW2.wins,
            w2Wins: w1VsW2.losses,
            ties: w1VsW2.ties
        };
    }

    /**
     * Populate leaderboard UI with tournament results
     * @param {Array} llmsArray - Array of LLM configuration objects
     * @param {Function} updateLeaderboardUIFunction - Callback to update UI
     */
    populateLeaderboard(llmsArray, updateLeaderboardUIFunction) {
        if (!this.rankings || Object.keys(this.rankings).length === 0) {
            console.warn('No tournament data available');
            return;
        }

        // Create mapping from warrior name to LLM config
        const llmMap = this.createLlmMapping(llmsArray);

        // Update LLM objects with tournament data
        llmsArray.forEach(llm => {
            const matchedWarrior = llmMap[llm.id];
            if (matchedWarrior) {
                const stats = this.rankings[matchedWarrior];
                if (stats) {
                    llm.tournamentWins = stats.wins;
                    llm.tournamentWinRate = stats.winRate;
                    llm.tournamentRank = this.getWarriorRank(matchedWarrior);
                    llm.tournamentOpponents = stats.opponents;
                }
            }
        });

        // Re-sort and update UI
        if (updateLeaderboardUIFunction) {
            updateLeaderboardUIFunction();
        }
    }

    /**
     * Create mapping from LLM IDs to warrior names
     * Uses heuristic matching based on name patterns
     * @param {Array} llmsArray - Array of LLM objects
     * @returns {Object} Mapping from llm.id to warrior name
     */
    createLlmMapping(llmsArray) {
        const mapping = {};

        if (!this.tournamentData || !this.tournamentData.warriors) {
            return mapping;
        }

        const warriors = this.tournamentData.warriors;

        llmsArray.forEach(llm => {
            // Try to find matching warrior
            let matched = null;

            // Direct match by ID (if warrior uses same format)
            if (warriors.includes(llm.id)) {
                matched = llm.id;
            }

            // Fuzzy matching by name components
            if (!matched) {
                const llmNameParts = llm.id.toLowerCase().split('-');
                matched = warriors.find(warrior => {
                    const warriorParts = warrior.toLowerCase().split('_');
                    // Check if any significant parts match
                    return llmNameParts.some(part =>
                        part.length > 2 && warriorParts.some(wpart => wpart.includes(part))
                    );
                });
            }

            // Fallback: use LLM name as key
            if (!matched && llm.name) {
                const nameParts = llm.name.toLowerCase().split(' ');
                matched = warriors.find(warrior => {
                    const warriorLower = warrior.toLowerCase();
                    return nameParts.some(part =>
                        part.length > 2 && warriorLower.includes(part)
                    );
                });
            }

            if (matched) {
                mapping[llm.id] = matched;
                console.log(`Mapped LLM "${llm.id}" to warrior "${matched}"`);
            }
        });

        return mapping;
    }

    /**
     * Get rank (1-based position) of warrior
     * @param {string} warrior - Warrior name
     * @returns {number} Rank position (1-based) or null
     */
    getWarriorRank(warrior) {
        if (!this.sortedRankings) return null;
        const index = this.sortedRankings.findIndex(r => r.warrior === warrior);
        return index >= 0 ? index + 1 : null;
    }

    /**
     * Generate summary stats
     * @returns {Object} Tournament summary
     */
    getSummary() {
        return {
            timestamp: this.tournamentData?.timestamp,
            totalWarriors: this.tournamentData?.warriors.length || 0,
            battlesPerMatchup: this.tournamentData?.battles_per_matchup || 0,
            totalMatchups: this.tournamentData?.matchups.length || 0,
            topWarrior: this.sortedRankings?.[0] || null,
            topThree: this.sortedRankings?.slice(0, 3) || []
        };
    }

    /**
     * Format warrior name for display
     * Converts "anthropic_claude-opus-4.5" to "Claude Opus 4.5"
     * @param {string} warrior - Warrior name
     * @returns {string} Formatted name
     */
    static formatWarriorName(warrior) {
        // Remove provider prefix
        let name = warrior.split('_').pop();

        // Handle common patterns
        name = name
            .replace(/^anthropic-/, '')
            .replace(/^openai-/, '')
            .replace(/^deepseek-/, '')
            .replace(/^google-/, '')
            .replace(/-/g, ' ')
            .replace(/_/g, ' ');

        // Capitalize each word
        return name
            .split(' ')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    }

    /**
     * Export rankings as CSV
     * @returns {string} CSV formatted rankings
     */
    exportAsCSV() {
        let csv = 'Rank,Warrior,Wins,Losses,Ties,Total Battles,Win Rate\n';

        this.sortedRankings.forEach((stats, index) => {
            csv += `${index + 1},"${stats.warrior}",${stats.wins},${stats.losses},${stats.ties},${stats.battleCount},${stats.winRate}%\n`;
        });

        return csv;
    }
}

// Export for use in HTML
if (typeof module !== 'undefined' && module.exports) {
    module.exports = TournamentLoader;
}
